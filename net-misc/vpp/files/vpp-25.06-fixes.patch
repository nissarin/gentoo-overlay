From 0e5c0f4dd485a55dc613da2a27a487d426c44f44 Mon Sep 17 00:00:00 2001
From: Damjan Marion <damarion@cisco.com>
Date: Mon, 30 Jun 2025 15:53:21 +0200
Subject: [PATCH 1/7] vppinfra: avoid string truncation errors by some gcc
 versions

Type: fix
Change-Id: If33251e1eac7e437ae803363d960896da02ae567
Signed-off-by: Damjan Marion <damarion@cisco.com>
---
 src/vppinfra/devicetree.c | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/src/vppinfra/devicetree.c b/src/vppinfra/devicetree.c
index 309308c92..5d1423142 100644
--- a/src/vppinfra/devicetree.c
+++ b/src/vppinfra/devicetree.c
@@ -118,7 +118,9 @@ clib_dt_read_from_sysfs (clib_dt_main_t *dm)
 
 		  if (read (fd, p->data, st.st_size) == st.st_size)
 		    {
-		      strncpy (p->name, e->d_name, sizeof (p->name));
+		      snprintf (p->name, sizeof (p->name), "%.*s",
+				(int) sizeof (p->name) - 1, e->d_name);
+
 		      p->size = st.st_size;
 		      vec_add1 (n->properties, p);
 		      if (strncmp ("name", p->name, 5) == 0)
-- 
2.49.1


From 726d33f20e5576903900a3e4443ea13fbf2e0133 Mon Sep 17 00:00:00 2001
From: Matus Fabian <matfabia@cisco.com>
Date: Fri, 27 Jun 2025 13:40:51 +0200
Subject: [PATCH 2/7] http: fix http header table hash keys leak

Type: fix

Change-Id: I60ebf767a1f96a1290b7738d6859241739ce452c
Signed-off-by: Matus Fabian <matfabia@cisco.com>
---
 src/plugins/http/http.h | 10 ++++++++++
 1 file changed, 10 insertions(+)

diff --git a/src/plugins/http/http.h b/src/plugins/http/http.h
index 434ff965b..30df16405 100644
--- a/src/plugins/http/http.h
+++ b/src/plugins/http/http.h
@@ -714,11 +714,16 @@ always_inline void
 http_reset_header_table (http_header_table_t *ht)
 {
   int i;
+  hash_pair_t *p;
   for (i = 0; i < vec_len (ht->concatenated_values); i++)
     vec_free (ht->concatenated_values[i]);
   vec_reset_length (ht->concatenated_values);
   vec_reset_length (ht->values);
   vec_reset_length (ht->buf);
+  hash_foreach_pair (p, ht->value_by_name, ({
+		       void *k = uword_to_pointer (p->key, void *);
+		       clib_mem_free (k);
+		     }));
   hash_free (ht->value_by_name);
 }
 
@@ -742,11 +747,16 @@ always_inline void
 http_free_header_table (http_header_table_t *ht)
 {
   int i;
+  hash_pair_t *p;
   for (i = 0; i < vec_len (ht->concatenated_values); i++)
     vec_free (ht->concatenated_values[i]);
   vec_free (ht->concatenated_values);
   vec_free (ht->values);
   vec_free (ht->buf);
+  hash_foreach_pair (p, ht->value_by_name, ({
+		       void *k = uword_to_pointer (p->key, void *);
+		       clib_mem_free (k);
+		     }));
   hash_free (ht->value_by_name);
 }
 
-- 
2.49.1


From ea5d02ffab72a3032f0cc8df550fb1c46c59530d Mon Sep 17 00:00:00 2001
From: Vladimir Zhigulin <vladimir.jigulin@travelping.com>
Date: Fri, 4 Jul 2025 10:47:14 +0200
Subject: [PATCH 3/7] fib: take barrier on LB pool put

Fixes ASAN crash after fib update with multiple
workers

Type: fix

Change-Id: I3d0112b608ffa5b5559311c6d494d27d6c1db511
Signed-off-by: Vladimir Zhigulin <vladimir.jigulin@travelping.com>
---
 src/vnet/dpo/load_balance.c | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/src/vnet/dpo/load_balance.c b/src/vnet/dpo/load_balance.c
index f6f9392a4..c0f04f0ab 100644
--- a/src/vnet/dpo/load_balance.c
+++ b/src/vnet/dpo/load_balance.c
@@ -894,6 +894,7 @@ load_balance_destroy (load_balance_t *lb)
 {
     dpo_id_t *buckets;
     int i;
+    u8 need_barrier_sync;
 
     buckets = load_balance_get_buckets(lb);
 
@@ -911,7 +912,14 @@ load_balance_destroy (load_balance_t *lb)
     fib_urpf_list_unlock(lb->lb_urpf);
     load_balance_map_unlock(lb->lb_map);
 
+    need_barrier_sync = pool_put_will_expand (load_balance_pool, lb);
+    if (PREDICT_FALSE (need_barrier_sync))
+	vlib_worker_thread_barrier_sync (vlib_get_main());
+
     pool_put(load_balance_pool, lb);
+
+    if (PREDICT_FALSE (need_barrier_sync))
+	vlib_worker_thread_barrier_release (vlib_get_main());
 }
 
 static void
-- 
2.49.1


From d73a8aab2ca6d9a5b957b98ebe98e91a78ff7626 Mon Sep 17 00:00:00 2001
From: Stanislav Zaikin <stanislav.zaikin@46labs.com>
Date: Mon, 26 May 2025 09:52:57 +0200
Subject: [PATCH 4/7] linux-cp: do not lock table when it's not needed

Do not lock table when lcp is not installing routes (e.g. zero nexthops
or ipv6 multicast routes), otherwise it will stay locked forever.

Type: fix

Signed-off-by: Stanislav Zaikin <stanislav.zaikin@46labs.com>
Change-Id: I4070ce0e0823b5afbd56c5cd79ae39a02c7d4300
---
 src/plugins/linux-cp/lcp_router.c | 13 ++++++++++++-
 1 file changed, 12 insertions(+), 1 deletion(-)

diff --git a/src/plugins/linux-cp/lcp_router.c b/src/plugins/linux-cp/lcp_router.c
index 27f53357a..4c13c360e 100644
--- a/src/plugins/linux-cp/lcp_router.c
+++ b/src/plugins/linux-cp/lcp_router.c
@@ -1332,7 +1332,6 @@ lcp_router_route_add (struct rtnl_route *rr, int is_replace)
   lcp_router_route_mk_prefix (rr, &pfx);
   entry_flags = lcp_router_route_mk_entry_flags (rtype, table_id, rproto);
 
-  nlt = lcp_router_table_add_or_lock (table_id, pfx.fp_proto);
   /* Skip any kernel routes and IPv6 LL or multicast routes */
   if (rproto == RTPROT_KERNEL ||
       (FIB_PROTOCOL_IP6 == pfx.fp_proto &&
@@ -1360,6 +1359,8 @@ lcp_router_route_add (struct rtnl_route *rr, int is_replace)
 
   if (0 != vec_len (np.paths))
     {
+      nlt = lcp_router_table_add_or_lock (table_id, pfx.fp_proto);
+
       if (rtype == RTN_MULTICAST)
 	{
 	  /* it's not clear to me how linux expresses the RPF paramters
@@ -1423,6 +1424,16 @@ lcp_router_route_add (struct rtnl_route *rr, int is_replace)
       LCP_ROUTER_DBG ("no paths for route: %d:%U %U",
 		      rtnl_route_get_table (rr), format_fib_prefix, &pfx,
 		      format_fib_entry_flags, entry_flags);
+
+      nlt =
+	lcp_router_table_find (lcp_router_table_k2f (table_id), pfx.fp_proto);
+
+      if (is_replace && nlt)
+	{
+	  fib_source_t fib_src;
+	  fib_src = lcp_router_proto_fib_source (rproto);
+	  fib_table_entry_delete (nlt->nlt_fib_index, &pfx, fib_src);
+	}
     }
   vec_free (np.paths);
 }
-- 
2.49.1


From 1346e8f98458844fd2263f5c6c6bfc16cce19aa1 Mon Sep 17 00:00:00 2001
From: Klement Sekera <klement.sekera@gmail.com>
Date: Wed, 9 Jul 2025 14:34:11 +0200
Subject: [PATCH 5/7] arp: fix dump API

Add missing fib index to table id conversion in dump API.

Type: fix
Change-Id: Id5f7325ca31875abb39b33156f3938a051888ad3
Signed-off-by: Klement Sekera <klement.sekera@gmail.com>
---
 src/vnet/arp/arp_api.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/src/vnet/arp/arp_api.c b/src/vnet/arp/arp_api.c
index 170bace2b..083fa50aa 100644
--- a/src/vnet/arp/arp_api.c
+++ b/src/vnet/arp/arp_api.c
@@ -86,7 +86,8 @@ send_proxy_arp_details (const ip4_address_t * lo_addr,
   clib_memset (mp, 0, sizeof (*mp));
   mp->_vl_msg_id = ntohs (VL_API_PROXY_ARP_DETAILS + REPLY_MSG_ID_BASE);
   mp->context = ctx->context;
-  mp->proxy.table_id = htonl (fib_index);
+  mp->proxy.table_id = clib_host_to_net_u32 (
+    fib_table_get_table_id (fib_index, FIB_PROTOCOL_IP4));
 
   ip4_address_encode (lo_addr, mp->proxy.low);
   ip4_address_encode (hi_addr, mp->proxy.hi);
-- 
2.49.1


From e94b25796c1abbbf625f977fc73fce1c7b197120 Mon Sep 17 00:00:00 2001
From: Andrew Yourtchenko <ayourtch@gmail.com>
Date: Fri, 4 Jul 2025 18:07:27 +0200
Subject: [PATCH 6/7] memif: avoid double-close of the socket on client abort
 with un-read data

In some cases, there are two times the clib_file_del is called:

1) from memif_disconnect -> memif_socket_close call site in memif_master_conn_fd_error
2) the supposedly defensive code at the end of memif_master_conn_fd_error.

This was observed upon using of an artisanal memif client, which did not correctly drain the data written by VPP to the notification socket - a simple Ctrl-C in the client was enough to trivially reproduce the issue.
In real world scenario using the stock client this is expected to be a fairly narrow race condition.

The issue can be demonstrated as follows:

diff --git a/src/vlib/file.c b/src/vlib/file.c
index 286b0d1f2..29138f485 100644
--- a/src/vlib/file.c
+++ b/src/vlib/file.c
@@ -200,6 +200,8 @@ epoll:
     {
       clib_file_t *f = e->data.ptr;
       clib_error_t *err;
+      clib_warning("EPOLL: count %d, fd index: %d, events: %x", n_fds_ready, f->index, e->events);
+

       if (PREDICT_FALSE (!f->active))
        {


vlib_file_poll:203: EPOLL: count 1, fd index: 6, events: 1
vlib_file_poll:203: EPOLL: count 1, fd index: 7, events: 1
vlib_file_poll:203: EPOLL: count 1, fd index: 7, events: 4
vlib_file_poll:203: EPOLL: count 1, fd index: 7, events: 1
vlib_file_poll:203: EPOLL: count 1, fd index: 7, events: 4
vlib_file_poll:203: EPOLL: count 1, fd index: 7, events: 1
vlib_file_poll:203: EPOLL: count 1, fd index: 7, events: 4
vlib_file_poll:203: EPOLL: count 1, fd index: 7, events: 1
vlib_file_poll:203: EPOLL: count 1, fd index: 7, events: 4
vlib_file_poll:203: EPOLL: count 1, fd index: 7, events: 1
vlib_file_poll:203: EPOLL: count 1, fd index: 7, events: 4
vlib_file_poll:203: EPOLL: count 1, fd index: 7, events: 1
vlib_file_poll:203: EPOLL: count 1, fd index: 7, events: 4
vlib_file_poll:203: EPOLL: count 1, fd index: 7, events: 11
memif_plugin       [error ]: memif0/0: default_socket_recvmsg: disconnected

Failing case, where the client did not drain the data sent to it:

DBGvpp# create interface memif master
DBGvpp# set int ip address memif0/0 192.0.2.1/24
DBGvpp# set interface state memif0/0 up
DBGvpp# vlib_file_poll:203: EPOLL: count 1, fd index: 6, events: 1
vlib_file_poll:203: EPOLL: count 1, fd index: 7, events: 1
vlib_file_poll:203: EPOLL: count 1, fd index: 7, events: 4
vlib_file_poll:203: EPOLL: count 1, fd index: 7, events: 1
vlib_file_poll:203: EPOLL: count 1, fd index: 7, events: 4
vlib_file_poll:203: EPOLL: count 1, fd index: 7, events: 1
vlib_file_poll:203: EPOLL: count 1, fd index: 7, events: 4
vlib_file_poll:203: EPOLL: count 1, fd index: 7, events: 1
vlib_file_poll:203: EPOLL: count 1, fd index: 7, events: 4
vlib_file_poll:203: EPOLL: count 1, fd index: 7, events: 1
vlib_file_poll:203: EPOLL: count 1, fd index: 7, events: 4
vlib_file_poll:203: EPOLL: count 1, fd index: 7, events: 1
vlib_file_poll:203: EPOLL: count 1, fd index: 7, events: 4
vlib_file_poll:203: EPOLL: count 1, fd index: 7, events: 19
memif_plugin       [warn  ]: Error on unknown file descriptor 21
vlib/file          [error ]: vlib_file_update: epoll_ctl() failed, errno 9
/home/ayourtch/vpp/src/vppinfra/pool.h:291 (_pool_put_index) assertion `!pool_is_free_index (p, index)' fails
received signal SIGABRT, PC 0xffffa7f10a50

Type: fix
Change-Id: I13247c431605470c6a59d7d4630cefa999733107
Signed-off-by: Andrew Yourtchenko <ayourtch@gmail.com>
---
 src/plugins/memif/socket.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/src/plugins/memif/socket.c b/src/plugins/memif/socket.c
index c2b11fc2e..5890e2d91 100644
--- a/src/plugins/memif/socket.c
+++ b/src/plugins/memif/socket.c
@@ -629,6 +629,7 @@ memif_master_conn_fd_error (clib_file_t * uf)
       err = clib_error_return (0, "connection fd error");
       memif_disconnect (mif, err);
       clib_error_free (err);
+      return 0;
     }
   else
     {
-- 
2.49.1


From 3bfc3dc444ab2f2c5fe1e9ccaed93b9e29fbe9b9 Mon Sep 17 00:00:00 2001
From: Florin Coras <fcoras@cisco.com>
Date: Thu, 10 Jul 2025 20:27:08 -0700
Subject: [PATCH 7/7] tls: fix cert and pkey leak

Free cert and pkey once assigned to make sure they're freed one the
ssl structs are freed.

Type: fix

Change-Id: I41546c8ae7bad169a1462b3b9a3807e4644a1c2c
Signed-off-by: Florin Coras <fcoras@cisco.com>
---
 src/plugins/tlsopenssl/tls_openssl.c | 7 ++++---
 1 file changed, 4 insertions(+), 3 deletions(-)

diff --git a/src/plugins/tlsopenssl/tls_openssl.c b/src/plugins/tlsopenssl/tls_openssl.c
index bcb3c965f..2e085dffe 100644
--- a/src/plugins/tlsopenssl/tls_openssl.c
+++ b/src/plugins/tlsopenssl/tls_openssl.c
@@ -714,6 +714,7 @@ openssl_set_ckpair (SSL *ssl, u32 ckpair_index)
     }
   SSL_use_certificate (ssl, srvcert);
   BIO_free (cert_bio);
+  X509_free (srvcert);
 
   cert_bio = BIO_new (BIO_s_mem ());
   BIO_write (cert_bio, ckpair->key, vec_len (ckpair->key));
@@ -725,6 +726,7 @@ openssl_set_ckpair (SSL *ssl, u32 ckpair_index)
     }
   SSL_use_PrivateKey (ssl, pkey);
   BIO_free (cert_bio);
+  EVP_PKEY_free (pkey);
   TLS_DBG (1, "TLS client using ckpair index: %d", ckpair_index);
   return 0;
 }
@@ -1020,6 +1022,7 @@ openssl_start_listen (tls_ctx_t * lctx)
     }
 
   BIO_free (cert_bio);
+  X509_free (srvcert);
 
   cert_bio = BIO_new (BIO_s_mem ());
   if (!cert_bio)
@@ -1042,6 +1045,7 @@ openssl_start_listen (tls_ctx_t * lctx)
     }
 
   BIO_free (cert_bio);
+  EVP_PKEY_free (pkey);
 
   if (lctx->alpn_list)
     SSL_CTX_set_alpn_select_cb (ssl_ctx, openssl_alpn_select_cb,
@@ -1073,9 +1077,6 @@ openssl_stop_listen (tls_ctx_t * lctx)
   olc_index = lctx->tls_ssl_ctx;
   olc = openssl_lctx_get (olc_index);
 
-  X509_free (olc->srvcert);
-  EVP_PKEY_free (olc->pkey);
-
   SSL_CTX_free (olc->ssl_ctx);
   openssl_listen_ctx_free (olc);
 
-- 
2.49.1

