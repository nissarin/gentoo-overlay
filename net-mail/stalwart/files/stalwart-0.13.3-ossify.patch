diff --git a/crates/common/src/auth/access_token.rs b/crates/common/src/auth/access_token.rs
index 1159eca7..786d205c 100644
--- a/crates/common/src/auth/access_token.rs
+++ b/crates/common/src/auth/access_token.rs
@@ -64,40 +64,6 @@ impl Server {
         let mut permissions = role_permissions.finalize();
         let mut tenant = None;
 
-        // SPDX-SnippetBegin
-        // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-        // SPDX-License-Identifier: LicenseRef-SEL
-
-        #[cfg(feature = "enterprise")]
-        if self.is_enterprise_edition()
-            && let Some(tenant_id) = principal.tenant
-        {
-            // Limit tenant permissions
-
-            use directory::QueryParams;
-            permissions.intersection(&self.get_role_permissions(tenant_id).await?.enabled);
-
-            // Obtain tenant quota
-            tenant = Some(TenantInfo {
-                id: tenant_id,
-                quota: self
-                    .store()
-                    .query(QueryParams::id(tenant_id).with_return_member_of(false))
-                    .await
-                    .caused_by(trc::location!())?
-                    .ok_or_else(|| {
-                        trc::SecurityEvent::Unauthorized
-                            .into_err()
-                            .details("Tenant not found")
-                            .id(tenant_id)
-                            .caused_by(trc::location!())
-                    })?
-                    .quota
-                    .unwrap_or_default(),
-            });
-        }
-
-        // SPDX-SnippetEnd
 
         // Build member of and e-mail addresses
         let primary_id = principal.id();
diff --git a/crates/common/src/config/mod.rs b/crates/common/src/config/mod.rs
index 7c73ed2d..43c032ac 100644
--- a/crates/common/src/config/mod.rs
+++ b/crates/common/src/config/mod.rs
@@ -73,26 +73,6 @@ impl Core {
         #[cfg(not(feature = "enterprise"))]
         let is_enterprise = false;
 
-        // SPDX-SnippetBegin
-        // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-        // SPDX-License-Identifier: LicenseRef-SEL
-        #[cfg(feature = "enterprise")]
-        let enterprise =
-            crate::enterprise::Enterprise::parse(config, &config_manager, &stores, &data).await;
-
-        #[cfg(feature = "enterprise")]
-        let is_enterprise = enterprise.is_some();
-
-        #[cfg(feature = "enterprise")]
-        if !is_enterprise {
-            if data.is_enterprise_store() {
-                config
-                    .new_build_error("storage.data", "SQL read replicas is an Enterprise feature");
-                data = Store::None;
-            }
-            stores.disable_enterprise_only();
-        }
-        // SPDX-SnippetEnd
 
         let mut blob = config
             .value_require("storage.blob")
@@ -189,12 +169,6 @@ impl Core {
         }
 
         Self {
-            // SPDX-SnippetBegin
-            // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-            // SPDX-License-Identifier: LicenseRef-SEL
-            #[cfg(feature = "enterprise")]
-            enterprise,
-            // SPDX-SnippetEnd
             sieve: Scripting::parse(config, &stores).await,
             network: Network::parse(config),
             smtp: SmtpConfig::parse(config).await,
diff --git a/crates/common/src/config/telemetry.rs b/crates/common/src/config/telemetry.rs
index 33f21390..b6a9591c 100644
--- a/crates/common/src/config/telemetry.rs
+++ b/crates/common/src/config/telemetry.rs
@@ -40,12 +40,6 @@ pub enum TelemetrySubscriberType {
     Webhook(WebhookTracer),
     #[cfg(unix)]
     JournalTracer(crate::telemetry::tracers::journald::Subscriber),
-    // SPDX-SnippetBegin
-    // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-    // SPDX-License-Identifier: LicenseRef-SEL
-    #[cfg(feature = "enterprise")]
-    StoreTracer(StoreTracer),
-    // SPDX-SnippetEnd
 }
 
 #[derive(Debug)]
@@ -92,15 +86,6 @@ pub struct WebhookTracer {
     pub headers: HeaderMap,
 }
 
-// SPDX-SnippetBegin
-// SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-// SPDX-License-Identifier: LicenseRef-SEL
-#[derive(Debug)]
-#[cfg(feature = "enterprise")]
-pub struct StoreTracer {
-    pub store: store::Store,
-}
-// SPDX-SnippetEnd
 
 #[derive(Debug)]
 pub enum RotationStrategy {
@@ -483,12 +468,6 @@ impl Tracers {
                 TelemetrySubscriberType::JournalTracer(_) => {
                     EventType::Telemetry(TelemetryEvent::JournalError).into()
                 }
-                // SPDX-SnippetBegin
-                // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-                // SPDX-License-Identifier: LicenseRef-SEL
-                #[cfg(feature = "enterprise")]
-                TelemetrySubscriberType::StoreTracer(_) => None,
-                // SPDX-SnippetEnd
             };
 
             // Parse disabled events
@@ -519,41 +498,6 @@ impl Tracers {
             }
         }
 
-        // SPDX-SnippetBegin
-        // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-        // SPDX-License-Identifier: LicenseRef-SEL
-
-        // Parse tracing history
-        #[cfg(feature = "enterprise")]
-        {
-            if config
-                .property_or_default("tracing.history.enable", "false")
-                .unwrap_or(false)
-                && let Some(store_id) = config.value_require("tracing.history.store")
-            {
-                if let Some(store) = stores.stores.get(store_id) {
-                    let mut tracer = TelemetrySubscriber {
-                        id: "history".to_string(),
-                        interests: Default::default(),
-                        lossy: false,
-                        typ: TelemetrySubscriberType::StoreTracer(StoreTracer {
-                            store: store.clone(),
-                        }),
-                    };
-
-                    for event_type in StoreTracer::default_events() {
-                        tracer.interests.set(event_type);
-                        global_interests.set(event_type);
-                    }
-
-                    tracers.push(tracer);
-                } else {
-                    let err = format!("Store {store_id} not found");
-                    config.new_build_error("tracing.history.store", err);
-                }
-            }
-        }
-        // SPDX-SnippetEnd
 
         // Parse webhooks
         for id in config.sub_keys("webhook", ".url") {
diff --git a/crates/common/src/core.rs b/crates/common/src/core.rs
index e03d1825..f2156295 100644
--- a/crates/common/src/core.rs
+++ b/crates/common/src/core.rs
@@ -407,25 +407,6 @@ impl Server {
             }
         }
 
-        // SPDX-SnippetBegin
-        // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-        // SPDX-License-Identifier: LicenseRef-SEL
-
-        #[cfg(feature = "enterprise")]
-        if self.core.is_enterprise_edition()
-            && let Some(tenant) = quotas.tenant.filter(|tenant| tenant.quota != 0)
-        {
-            let used_quota = self.get_used_quota(tenant.id).await? as u64;
-
-            if used_quota + item_size > tenant.quota {
-                return Err(trc::LimitEvent::TenantQuota
-                    .into_err()
-                    .ctx(trc::Key::Limit, tenant.quota)
-                    .ctx(trc::Key::Size, used_quota));
-            }
-        }
-
-        // SPDX-SnippetEnd
 
         Ok(())
     }
@@ -457,32 +438,6 @@ impl Server {
             {
                 quotas.quota = principal.quota();
 
-                // SPDX-SnippetBegin
-                // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-                // SPDX-License-Identifier: LicenseRef-SEL
-
-                #[cfg(feature = "enterprise")]
-                if self.core.is_enterprise_edition()
-                    && let Some(tenant_id) = principal.tenant()
-                {
-                    quotas.tenant = TenantInfo {
-                        id: tenant_id,
-                        quota: self
-                            .core
-                            .storage
-                            .directory
-                            .query(QueryParams::id(tenant_id).with_return_member_of(false))
-                            .await
-                            .add_context(|err| {
-                                err.caused_by(trc::location!()).account_id(tenant_id)
-                            })?
-                            .map(|tenant| tenant.quota())
-                            .unwrap_or_default(),
-                    }
-                    .into();
-                }
-
-                // SPDX-SnippetEnd
             }
 
             quotas
diff --git a/crates/common/src/enterprise/alerts.rs b/crates/common/src/enterprise/alerts.rs
deleted file mode 100644
index 022f92ff..00000000
--- a/crates/common/src/enterprise/alerts.rs
+++ /dev/null
@@ -1,162 +0,0 @@
-/*
- * SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
- *
- * SPDX-License-Identifier: LicenseRef-SEL
- *
- * This file is subject to the Stalwart Enterprise License Agreement (SEL) and
- * is NOT open source software.
- *
- */
-
-use mail_builder::{
-    MessageBuilder,
-    headers::{
-        HeaderType,
-        address::{Address, EmailAddress},
-    },
-};
-use trc::{Collector, MetricType, TOTAL_EVENT_COUNT, TelemetryEvent};
-
-use super::{AlertContent, AlertContentToken, AlertMethod};
-use crate::{
-    Server,
-    expr::{Variable, functions::ResolveVariable},
-};
-use std::fmt::Write;
-
-#[derive(Debug, PartialEq, Eq)]
-pub struct AlertMessage {
-    pub from: String,
-    pub to: Vec<String>,
-    pub body: Vec<u8>,
-}
-
-struct CollectorResolver;
-
-impl Server {
-    pub async fn process_alerts(&self) -> Option<Vec<AlertMessage>> {
-        let alerts = &self.core.enterprise.as_ref()?.metrics_alerts;
-        if alerts.is_empty() {
-            return None;
-        }
-        let mut messages = Vec::new();
-
-        for alert in alerts {
-            if !self
-                .eval_expr(&alert.condition, &CollectorResolver, &alert.id, 0)
-                .await
-                .unwrap_or(false)
-            {
-                continue;
-            }
-            for method in &alert.method {
-                match method {
-                    AlertMethod::Email {
-                        from_name,
-                        from_addr,
-                        to,
-                        subject,
-                        body,
-                    } => {
-                        messages.push(AlertMessage {
-                            from: from_addr.clone(),
-                            to: to.clone(),
-                            body: MessageBuilder::new()
-                                .from(Address::Address(EmailAddress {
-                                    name: from_name.as_ref().map(|s| s.into()),
-                                    email: from_addr.as_str().into(),
-                                }))
-                                .header(
-                                    "To",
-                                    HeaderType::Address(Address::List(
-                                        to.iter()
-                                            .map(|to| {
-                                                Address::Address(EmailAddress {
-                                                    name: None,
-                                                    email: to.as_str().into(),
-                                                })
-                                            })
-                                            .collect(),
-                                    )),
-                                )
-                                .header("Auto-Submitted", HeaderType::Text("auto-generated".into()))
-                                .subject(subject.build())
-                                .text_body(body.build())
-                                .write_to_vec()
-                                .unwrap_or_default(),
-                        });
-                    }
-                    AlertMethod::Event { message } => {
-                        trc::event!(
-                            Telemetry(TelemetryEvent::Alert),
-                            Id = alert.id.to_string(),
-                            Details = message.as_ref().map(|m| m.build())
-                        );
-
-                        #[cfg(feature = "test_mode")]
-                        Collector::update_event_counter(
-                            trc::EventType::Telemetry(TelemetryEvent::Alert),
-                            1,
-                        );
-                    }
-                }
-            }
-        }
-
-        (!messages.is_empty()).then_some(messages)
-    }
-}
-
-impl ResolveVariable for CollectorResolver {
-    fn resolve_variable(&self, variable: u32) -> Variable<'_> {
-        if (variable as usize) < TOTAL_EVENT_COUNT {
-            Variable::Integer(Collector::read_event_metric(variable as usize) as i64)
-        } else if let Some(metric_type) =
-            MetricType::from_code(variable as u64 - TOTAL_EVENT_COUNT as u64)
-        {
-            Variable::Float(Collector::read_metric(metric_type))
-        } else {
-            Variable::Integer(0)
-        }
-    }
-
-    fn resolve_global(&self, _: &str) -> Variable<'_> {
-        Variable::Integer(0)
-    }
-}
-
-impl AlertContent {
-    pub fn build(&self) -> String {
-        let mut buf = String::with_capacity(self.len());
-        for token in &self.0 {
-            token.write(&mut buf);
-        }
-        buf
-    }
-
-    #[allow(clippy::len_without_is_empty)]
-    pub fn len(&self) -> usize {
-        self.0.iter().map(|t| t.len()).sum()
-    }
-}
-
-impl AlertContentToken {
-    fn write(&self, buf: &mut String) {
-        match self {
-            AlertContentToken::Text(text) => buf.push_str(text),
-            AlertContentToken::Metric(metric_type) => {
-                let _ = write!(buf, "{}", Collector::read_metric(*metric_type));
-            }
-            AlertContentToken::Event(event_type) => {
-                let _ = write!(buf, "{}", Collector::read_event_metric(event_type.id()));
-            }
-        }
-    }
-
-    fn len(&self) -> usize {
-        match self {
-            AlertContentToken::Text(s) => s.len(),
-            AlertContentToken::Metric(_) | AlertContentToken::Event(_) => 10,
-        }
-    }
-}
diff --git a/crates/common/src/enterprise/config.rs b/crates/common/src/enterprise/config.rs
deleted file mode 100644
index 1cf7db93..00000000
--- a/crates/common/src/enterprise/config.rs
+++ /dev/null
@@ -1,488 +0,0 @@
-/*
- * SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
- *
- * SPDX-License-Identifier: LicenseRef-SEL
- *
- * This file is subject to the Stalwart Enterprise License Agreement (SEL) and
- * is NOT open source software.
- *
- */
-
-use std::{sync::Arc, time::Duration};
-
-use ahash::AHashMap;
-use directory::{Type, backend::internal::manage::ManageDirectory};
-use store::{Store, Stores};
-use trc::{EventType, MetricType, TOTAL_EVENT_COUNT};
-use utils::{
-    config::{
-        Config, ConfigKey,
-        cron::SimpleCron,
-        utils::{AsKey, ParseValue},
-    },
-    template::Template,
-};
-
-use crate::{
-    expr::{Expression, tokenizer::TokenMap},
-    manager::config::ConfigManager,
-};
-
-use super::{
-    AlertContent, AlertContentToken, AlertMethod, Enterprise, MetricAlert, MetricStore,
-    SpamFilterLlmConfig, TraceStore, Undelete, license::LicenseKey, llm::AiApiConfig,
-};
-
-impl Enterprise {
-    pub async fn parse(
-        config: &mut Config,
-        config_manager: &ConfigManager,
-        stores: &Stores,
-        data: &Store,
-    ) -> Option<Self> {
-        let server_hostname = config
-            .value("server.hostname")
-            .or_else(|| config.value("lookup.default.hostname"))?;
-        let mut update_license = None;
-
-        let license_result = match (
-            config.value("enterprise.license-key"),
-            config.value("enterprise.api-key"),
-        ) {
-            (Some(license_key), maybe_api_key) => {
-                match (LicenseKey::new(license_key, server_hostname), maybe_api_key) {
-                    (Ok(license), Some(api_key)) if license.is_near_expiration() => Ok(license
-                        .try_renew(api_key)
-                        .await
-                        .map(|result| {
-                            update_license = Some(result.encoded_key);
-                            result.key
-                        })
-                        .unwrap_or(license)),
-                    (Ok(license), None) => Ok(license),
-                    (Err(_), Some(api_key)) => LicenseKey::invalid(server_hostname)
-                        .try_renew(api_key)
-                        .await
-                        .map(|result| {
-                            update_license = Some(result.encoded_key);
-                            result.key
-                        }),
-                    (maybe_license, _) => maybe_license,
-                }
-            }
-            (None, Some(api_key)) => LicenseKey::invalid(server_hostname)
-                .try_renew(api_key)
-                .await
-                .map(|result| {
-                    update_license = Some(result.encoded_key);
-                    result.key
-                }),
-            (None, None) => {
-                return None;
-            }
-        };
-
-        // Report error
-        let license = match license_result {
-            Ok(license) => license,
-            Err(err) => {
-                config.new_build_warning("enterprise.license-key", err.to_string());
-                return None;
-            }
-        };
-
-        // Update the license if a new one was obtained
-        if let Some(license) = update_license {
-            config
-                .keys
-                .insert("enterprise.license-key".to_string(), license.clone());
-            if let Err(err) = config_manager
-                .set(
-                    [ConfigKey {
-                        key: "enterprise.license-key".to_string(),
-                        value: license.to_string(),
-                    }],
-                    true,
-                )
-                .await
-            {
-                trc::error!(
-                    err.caused_by(trc::location!())
-                        .details("Failed to update license key")
-                );
-            }
-        }
-
-        match data
-            .count_principals(None, Type::Individual.into(), None)
-            .await
-        {
-            Ok(total) if total > license.accounts as u64 => {
-                config.new_build_warning(
-                    "enterprise.license-key",
-                    format!(
-                        "License key is valid but only allows {} accounts, found {}.",
-                        license.accounts, total
-                    ),
-                );
-                return None;
-            }
-            Err(e) => {
-                if !matches!(data, Store::None) {
-                    config.new_build_error("enterprise.license-key", e.to_string());
-                }
-                return None;
-            }
-            _ => (),
-        }
-
-        let trace_store = if config
-            .property_or_default("tracing.history.enable", "false")
-            .unwrap_or(false)
-        {
-            if let Some(store) = config
-                .value("tracing.history.store")
-                .and_then(|name| stores.stores.get(name))
-                .cloned()
-            {
-                TraceStore {
-                    retention: config
-                        .property_or_default::<Option<Duration>>("tracing.history.retention", "30d")
-                        .unwrap_or(Some(Duration::from_secs(30 * 24 * 60 * 60))),
-                    store,
-                }
-                .into()
-            } else {
-                None
-            }
-        } else {
-            None
-        };
-        let metrics_store = if config
-            .property_or_default("metrics.history.enable", "false")
-            .unwrap_or(false)
-        {
-            if let Some(store) = config
-                .value("metrics.history.store")
-                .and_then(|name| stores.stores.get(name))
-                .cloned()
-            {
-                MetricStore {
-                    retention: config
-                        .property_or_default::<Option<Duration>>("metrics.history.retention", "90d")
-                        .unwrap_or(Some(Duration::from_secs(90 * 24 * 60 * 60))),
-                    store,
-                    interval: config
-                        .property_or_default::<SimpleCron>("metrics.history.interval", "0 * *")
-                        .unwrap_or_else(|| SimpleCron::parse_value("0 * *").unwrap()),
-                }
-                .into()
-            } else {
-                None
-            }
-        } else {
-            None
-        };
-
-        // Parse AI APIs
-        let mut ai_apis = AHashMap::new();
-        for id in config.sub_keys("enterprise.ai", ".url") {
-            if let Some(api) = AiApiConfig::parse(config, &id) {
-                ai_apis.insert(id, api.into());
-            }
-        }
-
-        // Build the enterprise configuration
-        let mut enterprise = Enterprise {
-            license,
-            undelete: config
-                .property_or_default::<Option<Duration>>("storage.undelete.retention", "false")
-                .unwrap_or_default()
-                .map(|retention| Undelete { retention }),
-            logo_url: config.value("enterprise.logo-url").map(|s| s.to_string()),
-            trace_store,
-            metrics_store,
-            metrics_alerts: parse_metric_alerts(config),
-            spam_filter_llm: SpamFilterLlmConfig::parse(config, &ai_apis),
-            ai_apis,
-            template_calendar_alarm: None,
-            template_scheduling_email: None,
-            template_scheduling_web: None,
-        };
-
-        // Parse templates
-        for (key, value) in [
-            (
-                "calendar.alarms.template",
-                &mut enterprise.template_calendar_alarm,
-            ),
-            (
-                "calendar.scheduling.template.email",
-                &mut enterprise.template_scheduling_email,
-            ),
-            (
-                "calendar.scheduling.template.web",
-                &mut enterprise.template_scheduling_web,
-            ),
-        ] {
-            if let Some(template) = config.value(key) {
-                match Template::parse(template) {
-                    Ok(template) => *value = Some(template),
-                    Err(err) => {
-                        config.new_build_error(key, format!("Invalid template: {err}"));
-                    }
-                }
-            }
-        }
-
-        Some(enterprise)
-    }
-}
-
-impl SpamFilterLlmConfig {
-    pub fn parse(config: &mut Config, models: &AHashMap<String, Arc<AiApiConfig>>) -> Option<Self> {
-        if !config
-            .property_or_default::<bool>("spam-filter.llm.enable", "false")
-            .unwrap_or_default()
-        {
-            return None;
-        }
-        let model = config.value_require_non_empty("spam-filter.llm.model")?;
-        let model = if let Some(model) = models.get(model) {
-            model.clone()
-        } else {
-            let message = format!("Model {model:?} not found in AI API configuration");
-            config.new_build_error("spam-filter.llm.model", message);
-            return None;
-        };
-
-        let llm = SpamFilterLlmConfig {
-            model,
-            temperature: config
-                .property_or_default("spam-filter.llm.temperature", "0.5")
-                .unwrap_or(0.5),
-            prompt: config
-                .value_require_non_empty("spam-filter.llm.prompt")?
-                .to_string(),
-            separator: config
-                .value_require_non_empty("spam-filter.llm.separator")
-                .unwrap_or_default()
-                .chars()
-                .next()
-                .unwrap_or(','),
-            index_category: config
-                .property("spam-filter.llm.index.category")
-                .unwrap_or_default(),
-            index_confidence: config.property("spam-filter.llm.index.confidence"),
-            index_explanation: config.property("spam-filter.llm.index.explanation"),
-            categories: config
-                .values("spam-filter.llm.categories")
-                .map(|(_, v)| v.trim().to_uppercase())
-                .collect(),
-            confidence: config
-                .values("spam-filter.llm.confidence")
-                .map(|(_, v)| v.trim().to_uppercase())
-                .collect(),
-        };
-
-        if llm.categories.is_empty() {
-            config.new_build_error("spam-filter.llm.categories", "No categories defined");
-            return None;
-        }
-        if llm.index_confidence.is_some() && llm.confidence.is_empty() {
-            config.new_build_error(
-                "spam-filter.llm.confidence",
-                "Confidence index is defined but no confidence values are provided",
-            );
-            return None;
-        }
-
-        llm.into()
-    }
-}
-
-pub fn parse_metric_alerts(config: &mut Config) -> Vec<MetricAlert> {
-    let mut alerts = Vec::new();
-
-    for metric_id in config.sub_keys("metrics.alerts", ".enable") {
-        if let Some(alert) = parse_metric_alert(config, metric_id) {
-            alerts.push(alert);
-        }
-    }
-
-    alerts
-}
-
-fn parse_metric_alert(config: &mut Config, id: String) -> Option<MetricAlert> {
-    if !config.property_or_default::<bool>(("metrics.alerts", id.as_str(), "enable"), "false")? {
-        return None;
-    }
-
-    let mut alert = MetricAlert {
-        condition: Expression::try_parse(
-            config,
-            ("metrics.alerts", id.as_str(), "condition"),
-            &TokenMap::default().with_variables_map(
-                EventType::variants()
-                    .into_iter()
-                    .map(|e| (sanitize_metric_name(e.name()), e.id() as u32))
-                    .chain(MetricType::variants().iter().map(|m| {
-                        (
-                            sanitize_metric_name(m.name()),
-                            m.code() as u32 + TOTAL_EVENT_COUNT as u32,
-                        )
-                    })),
-            ),
-        )?,
-        method: Vec::new(),
-        id,
-    };
-    let id_str = alert.id.as_str();
-
-    if config
-        .property_or_default::<bool>(("metrics.alerts", id_str, "notify.event.enable"), "false")
-        .unwrap_or_default()
-    {
-        alert.method.push(AlertMethod::Event {
-            message: parse_alert_content(
-                ("metrics.alerts", id_str, "notify.event.message"),
-                config,
-            ),
-        });
-    }
-
-    if config
-        .property_or_default::<bool>(("metrics.alerts", id_str, "notify.email.enable"), "false")
-        .unwrap_or_default()
-    {
-        let from_addr = config
-            .value_require(("metrics.alerts", id_str, "notify.email.from-addr"))?
-            .trim()
-            .to_string();
-        let from_name = config
-            .value(("metrics.alerts", id_str, "notify.email.from-name"))
-            .map(|s| s.to_string());
-        let to = config
-            .values(("metrics.alerts", id_str, "notify.email.to"))
-            .filter_map(|(_, s)| {
-                if s.contains('@') {
-                    s.trim().to_string().into()
-                } else {
-                    None
-                }
-            })
-            .collect::<Vec<_>>();
-        let subject =
-            parse_alert_content(("metrics.alerts", id_str, "notify.email.subject"), config)?;
-        let body = parse_alert_content(("metrics.alerts", id_str, "notify.email.body"), config)?;
-
-        if !from_addr.contains('@') {
-            config.new_build_error(
-                ("metrics.alerts", id_str, "notify.email.from-addr"),
-                "Invalid from email address",
-            );
-        }
-        if to.is_empty() {
-            config.new_build_error(
-                ("metrics.alerts", id_str, "notify.email.to"),
-                "Missing recipient address(es)",
-            );
-        }
-        if subject.0.is_empty() {
-            config.new_build_error(
-                ("metrics.alerts", id_str, "notify.email.subject"),
-                "Missing email subject",
-            );
-        }
-        if body.0.is_empty() {
-            config.new_build_error(
-                ("metrics.alerts", id_str, "notify.email.body"),
-                "Missing email body",
-            );
-        }
-
-        alert.method.push(AlertMethod::Email {
-            from_name,
-            from_addr,
-            to,
-            subject,
-            body,
-        });
-    }
-
-    if alert.method.is_empty() {
-        config.new_build_error(
-            ("metrics.alerts", id_str),
-            "No notification method enabled for alert",
-        );
-    }
-
-    alert.into()
-}
-
-fn parse_alert_content(key: impl AsKey, config: &mut Config) -> Option<AlertContent> {
-    let mut tokens = Vec::new();
-    let mut value = config.value(key)?.chars().peekable();
-    let mut buf = String::new();
-
-    while let Some(ch) = value.next() {
-        if ch == '%' && value.peek() == Some(&'{') {
-            value.next();
-
-            let mut var_name = String::new();
-            let mut found_curly = false;
-
-            for ch in value.by_ref() {
-                if ch == '}' {
-                    found_curly = true;
-                    break;
-                }
-                var_name.push(ch);
-            }
-
-            if found_curly && value.peek() == Some(&'%') {
-                value.next();
-                if let Some(event_type) = EventType::try_parse(&var_name)
-                    .map(AlertContentToken::Event)
-                    .or_else(|| MetricType::try_parse(&var_name).map(AlertContentToken::Metric))
-                {
-                    if !buf.is_empty() {
-                        tokens.push(AlertContentToken::Text(std::mem::take(&mut buf)));
-                    }
-                    tokens.push(event_type);
-                } else {
-                    buf.push('%');
-                    buf.push('{');
-                    buf.push_str(&var_name);
-                    buf.push('}');
-                    buf.push('%');
-                }
-            } else {
-                buf.push('%');
-                buf.push('{');
-                buf.push_str(&var_name);
-            }
-        } else {
-            buf.push(ch);
-        }
-    }
-
-    if !buf.is_empty() {
-        tokens.push(AlertContentToken::Text(buf));
-    }
-
-    AlertContent(tokens).into()
-}
-
-fn sanitize_metric_name(name: &str) -> String {
-    let mut result = String::with_capacity(name.len());
-    for ch in name.chars() {
-        if ch.is_ascii_alphanumeric() {
-            result.push(ch);
-        } else {
-            result.push('_');
-        }
-    }
-
-    result
-}
diff --git a/crates/common/src/enterprise/license.rs b/crates/common/src/enterprise/license.rs
deleted file mode 100644
index 79fb8ea2..00000000
--- a/crates/common/src/enterprise/license.rs
+++ /dev/null
@@ -1,353 +0,0 @@
-/*
- * SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
- *
- * SPDX-License-Identifier: LicenseRef-SEL
- *
- * This file is subject to the Stalwart Enterprise License Agreement (SEL) and
- * is NOT open source software.
- *
- */
-
-/*
- * WARNING: TAMPERING WITH THIS CODE IS STRICTLY PROHIBITED
- * Any attempt to modify, bypass, or disable the license validation mechanism
- * constitutes a severe violation of the Stalwart Enterprise License Agreement.
- * Such actions may result in immediate termination of your license, legal action,
- * and substantial financial penalties. Stalwart Labs LLC actively monitors for
- * unauthorized modifications and will pursue all available legal remedies against
- * violators to the fullest extent of the law, including but not limited to claims
- * for copyright infringement, breach of contract, and fraud.
- */
-
-use std::{
-    fmt::{Display, Formatter},
-    time::Duration,
-};
-
-use hyper::{HeaderMap, header::AUTHORIZATION};
-use ring::signature::{ED25519, UnparsedPublicKey};
-
-use base64::{Engine, engine::general_purpose::STANDARD};
-use store::write::now;
-use trc::ServerEvent;
-
-use crate::manager::fetch_resource;
-
-//const LICENSING_API: &str = "https://localhost:444/api/license/";
-const LICENSING_API: &str = "https://license.stalw.art/api/license/";
-const RENEW_THRESHOLD: u64 = 60 * 60 * 24 * 4; // 4 days
-
-pub struct LicenseValidator {
-    public_key: UnparsedPublicKey<Vec<u8>>,
-}
-
-#[derive(Debug, Clone)]
-pub struct LicenseKey {
-    pub valid_to: u64,
-    pub valid_from: u64,
-    pub domain: String,
-    pub accounts: u32,
-}
-
-#[derive(Debug)]
-pub enum LicenseError {
-    Expired,
-    InvalidDomain { domain: String },
-    DomainMismatch { issued_to: String, current: String },
-    Parse,
-    Validation,
-    Decode,
-    InvalidParameters,
-    RenewalFailed { reason: String },
-}
-
-pub struct RenewedLicense {
-    pub key: LicenseKey,
-    pub encoded_key: String,
-}
-
-const U64_LEN: usize = std::mem::size_of::<u64>();
-const U32_LEN: usize = std::mem::size_of::<u32>();
-
-impl LicenseValidator {
-    #[allow(clippy::new_without_default)]
-    pub fn new() -> Self {
-        LicenseValidator {
-            public_key: UnparsedPublicKey::new(
-                &ED25519,
-                vec![
-                    118, 10, 182, 35, 89, 111, 11, 60, 154, 47, 205, 127, 107, 229, 55, 104, 72,
-                    54, 141, 14, 97, 219, 2, 4, 119, 143, 156, 10, 152, 216, 32, 194,
-                ],
-            ),
-        }
-    }
-
-    pub fn try_parse(&self, key: impl AsRef<str>) -> Result<LicenseKey, LicenseError> {
-        let key = STANDARD
-            .decode(key.as_ref())
-            .map_err(|_| LicenseError::Decode)?;
-        let valid_from = u64::from_le_bytes(
-            key.get(..U64_LEN)
-                .ok_or(LicenseError::Parse)?
-                .try_into()
-                .unwrap(),
-        );
-        let valid_to = u64::from_le_bytes(
-            key.get(U64_LEN..(U64_LEN * 2))
-                .ok_or(LicenseError::Parse)?
-                .try_into()
-                .unwrap(),
-        );
-        let accounts = u32::from_le_bytes(
-            key.get((U64_LEN * 2)..(U64_LEN * 2) + U32_LEN)
-                .ok_or(LicenseError::Parse)?
-                .try_into()
-                .unwrap(),
-        );
-        let domain_len = u32::from_le_bytes(
-            key.get((U64_LEN * 2) + U32_LEN..(U64_LEN * 2) + (U32_LEN * 2))
-                .ok_or(LicenseError::Parse)?
-                .try_into()
-                .unwrap(),
-        ) as usize;
-        let domain = String::from_utf8(
-            key.get((U64_LEN * 2) + (U32_LEN * 2)..(U64_LEN * 2) + (U32_LEN * 2) + domain_len)
-                .ok_or(LicenseError::Parse)?
-                .to_vec(),
-        )
-        .map_err(|_| LicenseError::Parse)?;
-        let signature = key
-            .get((U64_LEN * 2) + (U32_LEN * 2) + domain_len..)
-            .ok_or(LicenseError::Parse)?;
-
-        if valid_from == 0
-            || valid_to == 0
-            || valid_from >= valid_to
-            || accounts == 0
-            || domain.is_empty()
-        {
-            return Err(LicenseError::InvalidParameters);
-        }
-
-        // Validate signature
-        self.public_key
-            .verify(
-                &key[..(U64_LEN * 2) + (U32_LEN * 2) + domain_len],
-                signature,
-            )
-            .map_err(|_| LicenseError::Validation)?;
-
-        let key = LicenseKey {
-            valid_from,
-            valid_to,
-            domain,
-            accounts,
-        };
-
-        if !key.is_expired() {
-            Ok(key)
-        } else {
-            Err(LicenseError::Expired)
-        }
-    }
-}
-
-impl LicenseKey {
-    pub fn new(
-        license_key: impl AsRef<str>,
-        hostname: impl AsRef<str>,
-    ) -> Result<Self, LicenseError> {
-        LicenseValidator::new()
-            .try_parse(license_key)
-            .and_then(|key| {
-                let local_domain = Self::base_domain(hostname)?;
-                let license_domain = Self::base_domain(&key.domain)?;
-                if local_domain == license_domain {
-                    Ok(key)
-                } else {
-                    Err(LicenseError::DomainMismatch {
-                        issued_to: license_domain,
-                        current: local_domain,
-                    })
-                }
-            })
-    }
-
-    pub fn invalid(domain: impl AsRef<str>) -> Self {
-        LicenseKey {
-            valid_from: 0,
-            valid_to: 0,
-            domain: Self::base_domain(domain).unwrap_or_default(),
-            accounts: 0,
-        }
-    }
-
-    pub async fn try_renew(&self, api_key: &str) -> Result<RenewedLicense, LicenseError> {
-        let mut headers = HeaderMap::new();
-        headers.insert(
-            AUTHORIZATION,
-            format!("Bearer {api_key}")
-                .parse()
-                .map_err(|_| LicenseError::Validation)?,
-        );
-
-        trc::event!(
-            Server(ServerEvent::Licensing),
-            Details = "Attempting to renew Enterprise license from license.stalw.art",
-        );
-
-        match fetch_resource(
-            &format!("{}{}", LICENSING_API, self.domain),
-            headers.into(),
-            Duration::from_secs(60),
-            1024,
-        )
-        .await
-        .and_then(|bytes| {
-            String::from_utf8(bytes)
-                .map_err(|_| String::from("Failed to UTF-8 decode server response"))
-        }) {
-            Ok(encoded_key) => match LicenseKey::new(&encoded_key, &self.domain) {
-                Ok(key) => Ok(RenewedLicense { key, encoded_key }),
-                Err(err) => {
-                    trc::event!(
-                        Server(ServerEvent::Licensing),
-                        Details = "Failed to decode license renewal",
-                        Reason = err.to_string(),
-                    );
-                    Err(err)
-                }
-            },
-            Err(err) => {
-                trc::event!(
-                    Server(ServerEvent::Licensing),
-                    Details = "Failed to renew Enterprise license",
-                    Reason = err.clone(),
-                );
-                Err(LicenseError::RenewalFailed { reason: err })
-            }
-        }
-    }
-
-    pub fn is_near_expiration(&self) -> bool {
-        let now = now();
-        self.valid_to.saturating_sub(now) <= RENEW_THRESHOLD
-    }
-
-    pub fn expires_in(&self) -> Duration {
-        Duration::from_secs(self.valid_to.saturating_sub(now()))
-    }
-
-    pub fn renew_in(&self) -> Duration {
-        Duration::from_secs(self.valid_to.saturating_sub(now() + RENEW_THRESHOLD))
-    }
-
-    pub fn is_expired(&self) -> bool {
-        let now = now();
-        now >= self.valid_to || now < self.valid_from
-    }
-
-    pub fn base_domain(domain: impl AsRef<str>) -> Result<String, LicenseError> {
-        let domain = domain.as_ref();
-        psl::domain_str(domain)
-            .map(|d| d.to_string())
-            .ok_or(LicenseError::InvalidDomain {
-                domain: domain.to_string(),
-            })
-    }
-}
-
-impl Display for LicenseError {
-    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
-        match self {
-            LicenseError::Expired => write!(f, "License is expired"),
-            LicenseError::Parse => write!(f, "Failed to parse license key"),
-            LicenseError::Validation => write!(f, "Failed to validate license key"),
-            LicenseError::Decode => write!(f, "Failed to decode license key"),
-            LicenseError::InvalidParameters => write!(f, "Invalid license key parameters"),
-            LicenseError::DomainMismatch { issued_to, current } => {
-                write!(
-                    f,
-                    "License issued to domain {issued_to:?} does not match {current:?}",
-                )
-            }
-            LicenseError::InvalidDomain { domain } => {
-                write!(f, "Invalid domain {domain:?}")
-            }
-            LicenseError::RenewalFailed { reason } => {
-                write!(f, "Failed to renew license: {reason}")
-            }
-        }
-    }
-}
-
-/*
-
-use rustls::sign::CertifiedKey;
-use webpki::TrustAnchor;
-use x509_parser::{certificate::X509Certificate, prelude::FromDer};
-
-
-fn validate_certificate(key: &CertifiedKey) -> Result<(), Box<dyn std::error::Error>> {
-    let cert_der = key.end_entity_cert()?.as_ref();
-
-    webpki::EndEntityCert::try_from(cert_der)?.verify_is_valid_tls_server_cert(
-        &[
-            &webpki::ECDSA_P256_SHA256,
-            &webpki::ECDSA_P256_SHA384,
-            &webpki::ECDSA_P384_SHA256,
-            &webpki::ECDSA_P384_SHA384,
-            &webpki::ED25519,
-            &webpki::RSA_PKCS1_2048_8192_SHA256,
-            &webpki::RSA_PKCS1_2048_8192_SHA384,
-            &webpki::RSA_PKCS1_2048_8192_SHA512,
-            &webpki::RSA_PKCS1_3072_8192_SHA384,
-            &webpki::RSA_PSS_2048_8192_SHA256_LEGACY_KEY,
-            &webpki::RSA_PSS_2048_8192_SHA384_LEGACY_KEY,
-            &webpki::RSA_PSS_2048_8192_SHA512_LEGACY_KEY,
-        ],
-        &webpki::TlsServerTrustAnchors(
-            webpki_roots::TLS_SERVER_ROOTS
-                .iter()
-                .map(|ta| TrustAnchor {
-                    subject: ta.subject.as_ref(),
-                    spki: ta.subject_public_key_info.as_ref(),
-                    name_constraints: ta.name_constraints.as_ref().map(|nc| nc.as_ref()),
-                })
-                .collect::<Vec<_>>()
-                .as_slice(),
-        ),
-        &key.cert
-            .iter()
-            .skip(1)
-            .map(|der| der.as_ref())
-            .collect::<Vec<_>>(),
-        webpki::Time::try_from(SystemTime::now())?,
-    )?;
-
-    // Additional checks
-    let x509 = X509Certificate::from_der(cert_der)?.1;
-
-    // Check if self-signed
-    if x509.issuer() == x509.subject() {
-        return Err("Certificate is self-signed".into());
-    }
-
-    // Check expiration
-    let not_before = x509.validity().not_before.timestamp();
-    let not_after = x509.validity().not_after.timestamp();
-    let now = SystemTime::UNIX_EPOCH
-        .elapsed()
-        .unwrap_or_default()
-        .as_secs() as i64;
-
-    if now < not_before || now > not_after {
-        Err("Certificate is expired or not yet valid".into())
-    } else {
-        Ok(())
-    }
-}
-
-
-*/
diff --git a/crates/common/src/enterprise/llm.rs b/crates/common/src/enterprise/llm.rs
deleted file mode 100644
index d7fdf70a..00000000
--- a/crates/common/src/enterprise/llm.rs
+++ /dev/null
@@ -1,234 +0,0 @@
-/*
- * SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
- *
- * SPDX-License-Identifier: LicenseRef-SEL
- *
- * This file is subject to the Stalwart Enterprise License Agreement (SEL) and
- * is NOT open source software.
- *
- */
-
-use std::time::Duration;
-
-use hyper::{HeaderMap, header::CONTENT_TYPE};
-use serde::{Deserialize, Serialize};
-use utils::config::Config;
-
-use crate::config::parse_http_headers;
-
-#[derive(Clone, Debug)]
-pub struct AiApiConfig {
-    pub id: String,
-    pub api_type: ApiType,
-    pub url: String,
-    pub model: String,
-    pub timeout: Duration,
-    pub headers: HeaderMap,
-    pub tls_allow_invalid_certs: bool,
-    pub default_temperature: f64,
-}
-
-#[derive(Clone, Copy, Debug)]
-pub enum ApiType {
-    ChatCompletion,
-    TextCompletion,
-}
-
-#[derive(Serialize, Deserialize, Debug)]
-pub struct ChatCompletionRequest {
-    pub model: String,
-    pub messages: Vec<Message>,
-    pub temperature: f64,
-}
-
-#[derive(Serialize, Deserialize, Debug)]
-pub struct Message {
-    pub role: String,
-    pub content: String,
-}
-
-#[derive(Serialize, Deserialize, Debug)]
-pub struct ChatCompletionResponse {
-    pub created: i64,
-    pub object: String,
-    pub id: String,
-    pub model: String,
-    pub choices: Vec<ChatCompletionChoice>,
-}
-
-#[derive(Serialize, Deserialize, Debug)]
-pub struct ChatCompletionChoice {
-    pub index: i32,
-    pub finish_reason: String,
-    pub message: Message,
-}
-
-#[derive(Serialize, Deserialize, Debug)]
-pub struct TextCompletionRequest {
-    pub model: String,
-    pub prompt: String,
-    pub temperature: f64,
-}
-
-#[derive(Deserialize, Debug)]
-pub struct TextCompletionResponse {
-    pub created: i64,
-    pub object: String,
-    pub id: String,
-    pub model: String,
-    pub choices: Vec<TextCompletionChoice>,
-}
-
-#[derive(Deserialize, Debug)]
-pub struct TextCompletionChoice {
-    pub index: i32,
-    pub finish_reason: String,
-    pub text: String,
-}
-
-impl AiApiConfig {
-    pub async fn send_request(
-        &self,
-        prompt: impl Into<String>,
-        temperature: Option<f64>,
-    ) -> trc::Result<String> {
-        self.post_api(prompt, temperature).await.map_err(|err| {
-            trc::Error::new(trc::EventType::Ai(trc::AiEvent::ApiError))
-                .id(self.id.clone())
-                .details("OpenAPI request failed")
-                .reason(err)
-        })
-    }
-
-    async fn post_api(
-        &self,
-        prompt: impl Into<String>,
-        temperature: Option<f64>,
-    ) -> Result<String, String> {
-        // Serialize body
-        let body = match self.api_type {
-            ApiType::ChatCompletion => serde_json::to_string(&ChatCompletionRequest {
-                model: self.model.to_string(),
-                messages: vec![Message {
-                    role: "user".to_string(),
-                    content: prompt.into(),
-                }],
-                temperature: temperature.unwrap_or(self.default_temperature),
-            })
-            .map_err(|err| format!("Failed to serialize request: {}", err))?,
-            ApiType::TextCompletion => serde_json::to_string(&TextCompletionRequest {
-                model: self.model.to_string(),
-                prompt: prompt.into(),
-                temperature: temperature.unwrap_or(self.default_temperature),
-            })
-            .map_err(|err| format!("Failed to serialize request: {}", err))?,
-        };
-
-        // Send request
-        let response = reqwest::Client::builder()
-            .timeout(self.timeout)
-            .danger_accept_invalid_certs(self.tls_allow_invalid_certs)
-            .build()
-            .map_err(|err| format!("Failed to create HTTP client: {}", err))?
-            .post(&self.url)
-            .headers(self.headers.clone())
-            .body(body)
-            .send()
-            .await
-            .map_err(|err| format!("API request to {} failed: {err}", self.url))?;
-
-        if response.status().is_success() {
-            let bytes = response.bytes().await.map_err(|err| {
-                format!("Failed to read response body from {}: {}", self.url, err)
-            })?;
-
-            match self.api_type {
-                ApiType::ChatCompletion => {
-                    let response = serde_json::from_slice::<ChatCompletionResponse>(&bytes)
-                        .map_err(|err| {
-                            format!(
-                                "Failed to chat completion parse response from {}: {}",
-                                self.url, err
-                            )
-                        })?;
-                    response
-                        .choices
-                        .into_iter()
-                        .next()
-                        .map(|choice| choice.message.content)
-                        .filter(|text| !text.is_empty())
-                        .ok_or_else(|| {
-                            format!(
-                                "Chat completion response from {} did not contain any choices: {}",
-                                self.url,
-                                std::str::from_utf8(&bytes).unwrap_or_default()
-                            )
-                        })
-                }
-                ApiType::TextCompletion => {
-                    let response = serde_json::from_slice::<TextCompletionResponse>(&bytes)
-                        .map_err(|err| {
-                            format!(
-                                "Failed to parse text completion response from {}: {}",
-                                self.url, err
-                            )
-                        })?;
-                    response
-                        .choices
-                        .into_iter()
-                        .next()
-                        .map(|choice| choice.text)
-                        .filter(|text| !text.is_empty())
-                        .ok_or_else(|| {
-                            format!(
-                                "Text completion response from {} did not contain any choices: {}",
-                                self.url,
-                                std::str::from_utf8(&bytes).unwrap_or_default()
-                            )
-                        })
-                }
-            }
-        } else {
-            Err(format!(
-                "OpenAPI request to {} failed with code {}: {}",
-                self.url,
-                response.status().as_u16(),
-                response.status().canonical_reason().unwrap_or("Unknown")
-            ))
-        }
-    }
-
-    pub fn parse(config: &mut Config, id: &str) -> Option<Self> {
-        let url = config.value(("enterprise.ai", id, "url"))?.to_string();
-        let api_type = match config.value(("enterprise.ai", id, "type"))? {
-            "chat" => ApiType::ChatCompletion,
-            "text" => ApiType::TextCompletion,
-            _ => {
-                config.new_build_error(("enterprise.ai", id, "type"), "Invalid API type");
-                return None;
-            }
-        };
-
-        let mut headers = parse_http_headers(config, ("enterprise.ai", id));
-        headers.insert(CONTENT_TYPE, "application/json".parse().unwrap());
-
-        Some(AiApiConfig {
-            id: id.to_string(),
-            api_type,
-            url,
-            headers,
-            model: config
-                .value_require(("enterprise.ai", id, "model"))?
-                .to_string(),
-            timeout: config
-                .property_or_default(("enterprise.ai", id, "timeout"), "2m")
-                .unwrap_or_else(|| Duration::from_secs(120)),
-            tls_allow_invalid_certs: config
-                .property_or_default(("enterprise.ai", id, "allow-invalid-certs"), "false")
-                .unwrap_or_default(),
-            default_temperature: config
-                .property_or_default(("enterprise.ai", id, "default-temperature"), "0.7")
-                .unwrap_or(0.7),
-        })
-    }
-}
diff --git a/crates/common/src/enterprise/mod.rs b/crates/common/src/enterprise/mod.rs
deleted file mode 100644
index 71487e51..00000000
--- a/crates/common/src/enterprise/mod.rs
+++ /dev/null
@@ -1,246 +0,0 @@
-/*
- * SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
- *
- * SPDX-License-Identifier: LicenseRef-SEL
- *
- * This file is subject to the Stalwart Enterprise License Agreement (SEL) and
- * is NOT open source software.
- *
- */
-
-pub mod alerts;
-pub mod config;
-pub mod license;
-pub mod llm;
-pub mod undelete;
-
-use ahash::{AHashMap, AHashSet};
-use directory::{QueryParams, Type, backend::internal::lookup::DirectoryStore};
-use license::LicenseKey;
-use llm::AiApiConfig;
-use mail_parser::DateTime;
-use std::{sync::Arc, time::Duration};
-use store::Store;
-use trc::{AddContext, EventType, MetricType};
-use utils::{HttpLimitResponse, config::cron::SimpleCron, template::Template};
-
-use crate::{
-    Core, Server, config::groupware::CalendarTemplateVariable, expr::Expression,
-    manager::webadmin::Resource,
-};
-
-#[derive(Clone)]
-pub struct Enterprise {
-    pub license: LicenseKey,
-    pub logo_url: Option<String>,
-    pub undelete: Option<Undelete>,
-    pub trace_store: Option<TraceStore>,
-    pub metrics_store: Option<MetricStore>,
-    pub metrics_alerts: Vec<MetricAlert>,
-    pub ai_apis: AHashMap<String, Arc<AiApiConfig>>,
-    pub spam_filter_llm: Option<SpamFilterLlmConfig>,
-    pub template_calendar_alarm: Option<Template<CalendarTemplateVariable>>,
-    pub template_scheduling_email: Option<Template<CalendarTemplateVariable>>,
-    pub template_scheduling_web: Option<Template<CalendarTemplateVariable>>,
-}
-
-#[derive(Debug, Clone)]
-pub struct SpamFilterLlmConfig {
-    pub model: Arc<AiApiConfig>,
-    pub temperature: f64,
-    pub prompt: String,
-    pub separator: char,
-    pub index_category: usize,
-    pub index_confidence: Option<usize>,
-    pub index_explanation: Option<usize>,
-    pub categories: AHashSet<String>,
-    pub confidence: AHashSet<String>,
-}
-
-#[derive(Clone)]
-pub struct Undelete {
-    pub retention: Duration,
-}
-
-#[derive(Clone)]
-pub struct TraceStore {
-    pub retention: Option<Duration>,
-    pub store: Store,
-}
-
-#[derive(Clone)]
-pub struct MetricStore {
-    pub retention: Option<Duration>,
-    pub store: Store,
-    pub interval: SimpleCron,
-}
-
-#[derive(Clone, Debug)]
-pub struct MetricAlert {
-    pub id: String,
-    pub condition: Expression,
-    pub method: Vec<AlertMethod>,
-}
-
-#[derive(Clone, Debug)]
-pub enum AlertMethod {
-    Email {
-        from_name: Option<String>,
-        from_addr: String,
-        to: Vec<String>,
-        subject: AlertContent,
-        body: AlertContent,
-    },
-    Event {
-        message: Option<AlertContent>,
-    },
-}
-
-#[derive(Clone, Debug)]
-pub struct AlertContent(pub Vec<AlertContentToken>);
-
-#[derive(Clone, Debug)]
-pub enum AlertContentToken {
-    Text(String),
-    Metric(MetricType),
-    Event(EventType),
-}
-
-impl Core {
-    pub fn is_enterprise_edition(&self) -> bool {
-        self.enterprise
-            .as_ref()
-            .is_some_and(|e| !e.license.is_expired())
-    }
-}
-
-impl Server {
-    // WARNING: TAMPERING WITH THIS FUNCTION IS STRICTLY PROHIBITED
-    // Any attempt to modify, bypass, or disable this license validation mechanism
-    // constitutes a severe violation of the Stalwart Enterprise License Agreement.
-    // Such actions may result in immediate termination of your license, legal action,
-    // and substantial financial penalties. Stalwart Labs LLC actively monitors for
-    // unauthorized modifications and will pursue all available legal remedies against
-    // violators to the fullest extent of the law, including but not limited to claims
-    // for copyright infringement, breach of contract, and fraud.
-
-    #[inline]
-    pub fn is_enterprise_edition(&self) -> bool {
-        self.core.is_enterprise_edition()
-    }
-
-    pub fn licensed_accounts(&self) -> u32 {
-        self.core
-            .enterprise
-            .as_ref()
-            .map_or(0, |e| e.license.accounts)
-    }
-
-    pub fn log_license_details(&self) {
-        if let Some(enterprise) = &self.core.enterprise {
-            trc::event!(
-                Server(trc::ServerEvent::Licensing),
-                Details = "Stalwart Enterprise Edition license key is valid",
-                Domain = enterprise.license.domain.clone(),
-                Total = enterprise.license.accounts,
-                ValidFrom =
-                    DateTime::from_timestamp(enterprise.license.valid_from as i64).to_rfc3339(),
-                ValidTo = DateTime::from_timestamp(enterprise.license.valid_to as i64).to_rfc3339(),
-            );
-        }
-    }
-
-    pub async fn logo_resource(&self, domain: &str) -> trc::Result<Option<Resource<Vec<u8>>>> {
-        const MAX_IMAGE_SIZE: usize = 1024 * 1024;
-
-        if self.is_enterprise_edition() {
-            let domain = psl::domain_str(domain).unwrap_or(domain);
-            let logo = { self.inner.data.logos.lock().get(domain).cloned() };
-
-            if let Some(logo) = logo {
-                Ok(logo)
-            } else {
-                // Try fetching the logo for the domain
-                let logo_url = if let Some(mut principal) = self
-                    .store()
-                    .query(QueryParams::name(domain).with_return_member_of(false))
-                    .await
-                    .caused_by(trc::location!())?
-                    .filter(|p| p.typ() == Type::Domain)
-                {
-                    if let Some(logo) = principal.picture_mut().filter(|l| l.starts_with("http")) {
-                        std::mem::take(logo).into()
-                    } else if let Some(tenant_id) = principal.tenant {
-                        if let Some(logo) = self
-                            .store()
-                            .query(QueryParams::id(tenant_id).with_return_member_of(false))
-                            .await
-                            .caused_by(trc::location!())?
-                            .and_then(|mut p| p.picture_mut().map(std::mem::take))
-                            .filter(|l| l.starts_with("http"))
-                        {
-                            logo.clone().into()
-                        } else {
-                            self.default_logo_url()
-                        }
-                    } else {
-                        self.default_logo_url()
-                    }
-                } else {
-                    self.default_logo_url()
-                };
-
-                let mut logo = None;
-                if let Some(logo_url) = logo_url {
-                    let response = reqwest::get(logo_url.as_str()).await.map_err(|err| {
-                        trc::ResourceEvent::DownloadExternal
-                            .into_err()
-                            .details("Failed to download logo")
-                            .reason(err)
-                    })?;
-
-                    let content_type = response
-                        .headers()
-                        .get(reqwest::header::CONTENT_TYPE)
-                        .and_then(|ct| ct.to_str().ok())
-                        .unwrap_or("image/svg+xml")
-                        .to_string();
-
-                    let contents = response
-                        .bytes_with_limit(MAX_IMAGE_SIZE)
-                        .await
-                        .map_err(|err| {
-                            trc::ResourceEvent::DownloadExternal
-                                .into_err()
-                                .details("Failed to download logo")
-                                .reason(err)
-                        })?
-                        .ok_or_else(|| {
-                            trc::ResourceEvent::DownloadExternal
-                                .into_err()
-                                .details("Download exceeded maximum size")
-                        })?;
-
-                    logo = Resource::new(content_type, contents).into();
-                }
-
-                self.inner
-                    .data
-                    .logos
-                    .lock()
-                    .insert(domain.to_string(), logo.clone());
-
-                Ok(logo)
-            }
-        } else {
-            Ok(None)
-        }
-    }
-
-    fn default_logo_url(&self) -> Option<String> {
-        self.core
-            .enterprise
-            .as_ref()
-            .and_then(|e| e.logo_url.as_ref().map(|l| l.into()))
-    }
-}
diff --git a/crates/common/src/enterprise/undelete.rs b/crates/common/src/enterprise/undelete.rs
deleted file mode 100644
index b3f97352..00000000
--- a/crates/common/src/enterprise/undelete.rs
+++ /dev/null
@@ -1,115 +0,0 @@
-/*
- * SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
- *
- * SPDX-License-Identifier: LicenseRef-SEL
- *
- * This file is subject to the Stalwart Enterprise License Agreement (SEL) and
- * is NOT open source software.
- *
- */
-
-use serde::{Deserialize, Serialize};
-use store::{
-    IterateParams, U32_LEN, U64_LEN, ValueKey,
-    write::{
-        BatchBuilder, BlobOp, ValueClass,
-        key::{DeserializeBigEndian, KeySerializer},
-        now,
-    },
-};
-use trc::AddContext;
-use utils::{BLOB_HASH_LEN, BlobHash};
-
-use crate::Core;
-
-#[derive(Debug, Serialize, Deserialize)]
-pub struct DeletedBlob<H, T, C> {
-    pub hash: H,
-    pub size: usize,
-    #[serde(rename = "deletedAt")]
-    pub deleted_at: T,
-    #[serde(rename = "expiresAt")]
-    pub expires_at: T,
-    pub collection: C,
-}
-
-impl Core {
-    pub fn hold_undelete(
-        &self,
-        batch: &mut BatchBuilder,
-        collection: u8,
-        blob_hash: &BlobHash,
-        blob_size: usize,
-    ) {
-        if let Some(undelete) = self.enterprise.as_ref().and_then(|e| e.undelete.as_ref()) {
-            let now = now();
-
-            batch.set(
-                BlobOp::Reserve {
-                    hash: blob_hash.clone(),
-                    until: now + undelete.retention.as_secs(),
-                },
-                KeySerializer::new(U64_LEN + U64_LEN)
-                    .write(blob_size as u32)
-                    .write(now)
-                    .write(collection)
-                    .finalize(),
-            );
-        }
-    }
-
-    pub async fn list_deleted(
-        &self,
-        account_id: u32,
-    ) -> trc::Result<Vec<DeletedBlob<BlobHash, u64, u8>>> {
-        let from_key = ValueKey {
-            account_id,
-            collection: 0,
-            document_id: 0,
-            class: ValueClass::Blob(BlobOp::Reserve {
-                hash: BlobHash::default(),
-                until: 0,
-            }),
-        };
-        let to_key = ValueKey {
-            account_id: account_id + 1,
-            collection: 0,
-            document_id: 0,
-            class: ValueClass::Blob(BlobOp::Reserve {
-                hash: BlobHash::default(),
-                until: 0,
-            }),
-        };
-
-        let now = now();
-        let mut results = Vec::new();
-
-        self.storage
-            .data
-            .iterate(
-                IterateParams::new(from_key, to_key).ascending(),
-                |key, value| {
-                    let expires_at = key.deserialize_be_u64(key.len() - U64_LEN)?;
-                    if value.len() == U32_LEN + U64_LEN + 1 && expires_at > now {
-                        results.push(DeletedBlob {
-                            hash: BlobHash::try_from_hash_slice(
-                                key.get(U32_LEN..U32_LEN + BLOB_HASH_LEN).ok_or_else(|| {
-                                    trc::Error::corrupted_key(key, value.into(), trc::location!())
-                                })?,
-                            )
-                            .unwrap(),
-                            size: value.deserialize_be_u32(0)? as usize,
-                            deleted_at: value.deserialize_be_u64(U32_LEN)?,
-                            expires_at,
-                            collection: *value.last().unwrap(),
-                        });
-                    }
-                    Ok(true)
-                },
-            )
-            .await
-            .caused_by(trc::location!())?;
-
-        Ok(results)
-    }
-}
diff --git a/crates/common/src/lib.rs b/crates/common/src/lib.rs
index 688068e3..d6ea2b3a 100644
--- a/crates/common/src/lib.rs
+++ b/crates/common/src/lib.rs
@@ -61,14 +61,6 @@ pub mod sharing;
 pub mod storage;
 pub mod telemetry;
 
-// SPDX-SnippetBegin
-// SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-// SPDX-License-Identifier: LicenseRef-SEL
-
-#[cfg(feature = "enterprise")]
-pub mod enterprise;
-
-// SPDX-SnippetEnd
 
 pub use psl;
 
@@ -347,12 +339,6 @@ pub struct Core {
     pub imap: ImapConfig,
     pub metrics: Metrics,
 
-    // SPDX-SnippetBegin
-    // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-    // SPDX-License-Identifier: LicenseRef-SEL
-    #[cfg(feature = "enterprise")]
-    pub enterprise: Option<enterprise::Enterprise>,
-    // SPDX-SnippetEnd
 }
 
 impl<T: CacheItemWeight> CacheItemWeight for CacheSwap<T> {
diff --git a/crates/common/src/manager/boot.rs b/crates/common/src/manager/boot.rs
index c26edd08..4759aa11 100644
--- a/crates/common/src/manager/boot.rs
+++ b/crates/common/src/manager/boot.rs
@@ -428,12 +428,6 @@ impl BootManager {
 
                 // Enable telemetry
 
-                // SPDX-SnippetBegin
-                // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-                // SPDX-License-Identifier: LicenseRef-SEL
-                #[cfg(feature = "enterprise")]
-                telemetry.enable(core.is_enterprise_edition());
-                // SPDX-SnippetEnd
 
                 #[cfg(not(feature = "enterprise"))]
                 telemetry.enable(false);
diff --git a/crates/common/src/manager/mod.rs b/crates/common/src/manager/mod.rs
index a2374cf4..6c73745b 100644
--- a/crates/common/src/manager/mod.rs
+++ b/crates/common/src/manager/mod.rs
@@ -22,13 +22,6 @@ const DEFAULT_SPAMFILTER_URL: &str =
     "https://github.com/stalwartlabs/spam-filter/releases/latest/download/spam-filter.toml";
 pub const WEBADMIN_KEY: &[u8] = "STALWART_WEBADMIN".as_bytes();
 
-// SPDX-SnippetBegin
-// SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-// SPDX-License-Identifier: LicenseRef-SEL
-#[cfg(feature = "enterprise")]
-const DEFAULT_WEBADMIN_URL: &str =
-    "https://github.com/stalwartlabs/webadmin/releases/latest/download/webadmin.zip";
-// SPDX-SnippetEnd
 
 #[cfg(not(feature = "enterprise"))]
 const DEFAULT_WEBADMIN_URL: &str =
diff --git a/crates/common/src/scripts/plugins/llm_prompt.rs b/crates/common/src/scripts/plugins/llm_prompt.rs
index fbd01252..86ac43ea 100644
--- a/crates/common/src/scripts/plugins/llm_prompt.rs
+++ b/crates/common/src/scripts/plugins/llm_prompt.rs
@@ -17,68 +17,6 @@ pub fn register(plugin_id: u32, fnc_map: &mut FunctionMap) {
 }
 
 pub async fn exec(ctx: PluginContext<'_>) -> trc::Result<Variable> {
-    // SPDX-SnippetBegin
-    // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-    // SPDX-License-Identifier: LicenseRef-SEL
-
-    #[cfg(feature = "enterprise")]
-    if let (Variable::String(name), Variable::String(prompt)) =
-        (&ctx.arguments[0], &ctx.arguments[1])
-    {
-        #[cfg(feature = "test_mode")]
-        if name.as_ref() == "echo-test" {
-            return Ok(prompt.to_string().into());
-        }
-        let temperature = ctx.arguments[2].to_number_checked().map(|n| match n {
-            Number::Integer(n) => (n as f64).clamp(0.0, 1.0),
-            Number::Float(n) => n.clamp(0.0, 1.0),
-        });
-
-        if let Some(ai_api) = ctx.server.core.enterprise.as_ref().and_then(|e| {
-            if ctx.access_token.is_none_or(|token| {
-                if token.has_permission(Permission::AiModelInteract) {
-                    true
-                } else {
-                    trc::event!(
-                        Security(SecurityEvent::Unauthorized),
-                        AccountId = token.primary_id(),
-                        Details = Permission::AiModelInteract.name(),
-                        SpanId = ctx.session_id,
-                    );
-                    false
-                }
-            }) {
-                if e.ai_apis.len() == 1 && name.is_empty() {
-                    e.ai_apis.values().next()
-                } else {
-                    e.ai_apis.get(name.as_ref())
-                }
-            } else {
-                None
-            }
-        }) {
-            let time = Instant::now();
-            match ai_api.send_request(prompt.as_ref(), temperature).await {
-                Ok(response) => {
-                    trc::event!(
-                        Ai(AiEvent::LlmResponse),
-                        Id = ai_api.id.clone(),
-                        Value = prompt.to_string(),
-                        Details = response.clone(),
-                        Elapsed = time.elapsed(),
-                        SpanId = ctx.session_id,
-                    );
-
-                    return Ok(response.into());
-                }
-                Err(err) => {
-                    trc::error!(err.span_id(ctx.session_id));
-                }
-            }
-        }
-    }
-
-    // SPDX-SnippetEnd
 
     Ok(false.into())
 }
diff --git a/crates/common/src/telemetry/metrics/mod.rs b/crates/common/src/telemetry/metrics/mod.rs
index 38289598..f2bb2deb 100644
--- a/crates/common/src/telemetry/metrics/mod.rs
+++ b/crates/common/src/telemetry/metrics/mod.rs
@@ -7,9 +7,3 @@
 pub mod otel;
 pub mod prometheus;
 
-// SPDX-SnippetBegin
-// SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-// SPDX-License-Identifier: LicenseRef-SEL
-#[cfg(feature = "enterprise")]
-pub mod store;
-// SPDX-SnippetEnd
diff --git a/crates/common/src/telemetry/metrics/prometheus.rs b/crates/common/src/telemetry/metrics/prometheus.rs
index cdd52436..8c0c5aa2 100644
--- a/crates/common/src/telemetry/metrics/prometheus.rs
+++ b/crates/common/src/telemetry/metrics/prometheus.rs
@@ -16,12 +16,6 @@ impl Server {
     pub async fn export_prometheus_metrics(&self) -> trc::Result<String> {
         let mut metrics = Vec::new();
 
-        // SPDX-SnippetBegin
-        // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-        // SPDX-License-Identifier: LicenseRef-SEL
-        #[cfg(feature = "enterprise")]
-        let is_enterprise = self.is_enterprise_edition();
-        // SPDX-SnippetEnd
 
         #[cfg(not(feature = "enterprise"))]
         let is_enterprise = false;
diff --git a/crates/common/src/telemetry/metrics/store.rs b/crates/common/src/telemetry/metrics/store.rs
deleted file mode 100644
index cc8c3e7f..00000000
--- a/crates/common/src/telemetry/metrics/store.rs
+++ /dev/null
@@ -1,303 +0,0 @@
-/*
- * SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
- *
- * SPDX-License-Identifier: LicenseRef-SEL
- *
- * This file is subject to the Stalwart Enterprise License Agreement (SEL) and
- * is NOT open source software.
- *
- */
-
-use std::{future::Future, sync::Arc, time::Duration};
-
-use ahash::AHashMap;
-use parking_lot::Mutex;
-use serde::{Deserialize, Serialize};
-use store::{
-    IterateParams, Store, U32_LEN, U64_LEN, ValueKey,
-    write::{
-        BatchBuilder, TelemetryClass, ValueClass,
-        key::{DeserializeBigEndian, KeySerializer},
-        now,
-    },
-};
-use trc::*;
-use utils::codec::leb128::Leb128Reader;
-
-use crate::Core;
-
-pub trait MetricsStore: Sync + Send {
-    fn write_metrics(
-        &self,
-        core: Arc<Core>,
-        timestamp: u64,
-        history: SharedMetricHistory,
-    ) -> impl Future<Output = trc::Result<()>> + Send;
-    fn query_metrics(
-        &self,
-        from_timestamp: u64,
-        to_timestamp: u64,
-    ) -> impl Future<Output = trc::Result<Vec<Metric<EventType, MetricType, u64>>>> + Send;
-    fn purge_metrics(&self, period: Duration) -> impl Future<Output = trc::Result<()>> + Send;
-}
-
-#[derive(Default)]
-pub struct MetricsHistory {
-    events: AHashMap<EventType, u32>,
-    histograms: AHashMap<MetricType, HistogramHistory>,
-}
-
-#[derive(Default)]
-struct HistogramHistory {
-    sum: u64,
-    count: u64,
-}
-
-#[derive(Debug, Serialize, Deserialize, PartialEq, Eq)]
-#[serde(tag = "type")]
-#[serde(rename_all = "camelCase")]
-pub enum Metric<CI, MI, T> {
-    Counter {
-        id: CI,
-        timestamp: T,
-        value: u64,
-    },
-    Gauge {
-        id: MI,
-        timestamp: T,
-        value: u64,
-    },
-    Histogram {
-        id: MI,
-        timestamp: T,
-        count: u64,
-        sum: u64,
-    },
-}
-
-pub type SharedMetricHistory = Arc<Mutex<MetricsHistory>>;
-
-const TYPE_COUNTER: u64 = 0x00;
-const TYPE_HISTOGRAM: u64 = 0x01;
-const TYPE_GAUGE: u64 = 0x02;
-
-impl MetricsStore for Store {
-    async fn write_metrics(
-        &self,
-        core: Arc<Core>,
-        timestamp: u64,
-        history_: SharedMetricHistory,
-    ) -> trc::Result<()> {
-        let mut batch = BatchBuilder::new();
-        {
-            let node_id = core.network.node_id;
-            let mut history = history_.lock();
-            for event in [
-                EventType::Smtp(SmtpEvent::ConnectionStart),
-                EventType::Imap(ImapEvent::ConnectionStart),
-                EventType::Pop3(Pop3Event::ConnectionStart),
-                EventType::ManageSieve(ManageSieveEvent::ConnectionStart),
-                EventType::Http(HttpEvent::ConnectionStart),
-                EventType::Delivery(DeliveryEvent::AttemptStart),
-                EventType::Queue(QueueEvent::QueueMessage),
-                EventType::Queue(QueueEvent::QueueMessageAuthenticated),
-                EventType::Queue(QueueEvent::QueueDsn),
-                EventType::Queue(QueueEvent::QueueReport),
-                EventType::MessageIngest(MessageIngestEvent::Ham),
-                EventType::MessageIngest(MessageIngestEvent::Spam),
-                EventType::Auth(AuthEvent::Failed),
-                EventType::Security(SecurityEvent::AuthenticationBan),
-                EventType::Security(SecurityEvent::ScanBan),
-                EventType::Security(SecurityEvent::AbuseBan),
-                EventType::Security(SecurityEvent::LoiterBan),
-                EventType::Security(SecurityEvent::IpBlocked),
-                EventType::IncomingReport(IncomingReportEvent::DmarcReport),
-                EventType::IncomingReport(IncomingReportEvent::DmarcReportWithWarnings),
-                EventType::IncomingReport(IncomingReportEvent::TlsReport),
-                EventType::IncomingReport(IncomingReportEvent::TlsReportWithWarnings),
-            ] {
-                let reading = Collector::read_event_metric(event.id());
-                if reading > 0 {
-                    let history = history.events.entry(event).or_insert(0);
-                    let diff = reading - *history;
-                    if diff > 0 {
-                        batch.set(
-                            ValueClass::Telemetry(TelemetryClass::Metric {
-                                timestamp,
-                                metric_id: (event.code() << 2) | TYPE_COUNTER,
-                                node_id,
-                            }),
-                            KeySerializer::new(U32_LEN).write_leb128(diff).finalize(),
-                        );
-                    }
-                    *history = reading;
-                }
-            }
-
-            for gauge in Collector::collect_gauges(true) {
-                let gauge_id = gauge.id();
-                if matches!(gauge_id, MetricType::QueueCount | MetricType::ServerMemory) {
-                    let value = gauge.get();
-                    if value > 0 {
-                        batch.set(
-                            ValueClass::Telemetry(TelemetryClass::Metric {
-                                timestamp,
-                                metric_id: (gauge_id.code() << 2) | TYPE_GAUGE,
-                                node_id,
-                            }),
-                            KeySerializer::new(U32_LEN).write_leb128(value).finalize(),
-                        );
-                    }
-                }
-            }
-
-            for histogram in Collector::collect_histograms(true) {
-                let histogram_id = histogram.id();
-                if matches!(
-                    histogram_id,
-                    MetricType::MessageIngestionTime
-                        | MetricType::MessageFtsIndexTime
-                        | MetricType::DeliveryTotalTime
-                        | MetricType::DeliveryTime
-                        | MetricType::DnsLookupTime
-                ) {
-                    let history = history.histograms.entry(histogram_id).or_default();
-                    let sum = histogram.sum();
-                    let count = histogram.count();
-                    let diff_sum = sum - history.sum;
-                    let diff_count = count - history.count;
-                    if diff_sum > 0 || diff_count > 0 {
-                        batch.set(
-                            ValueClass::Telemetry(TelemetryClass::Metric {
-                                timestamp,
-                                metric_id: (histogram_id.code() << 2) | TYPE_HISTOGRAM,
-                                node_id,
-                            }),
-                            KeySerializer::new(U32_LEN)
-                                .write_leb128(diff_count)
-                                .write_leb128(diff_sum)
-                                .finalize(),
-                        );
-                    }
-                    history.sum = sum;
-                    history.count = count;
-                }
-            }
-        }
-
-        if !batch.is_empty() {
-            self.write(batch.build_all())
-                .await
-                .caused_by(trc::location!())?;
-        }
-
-        Ok(())
-    }
-
-    async fn query_metrics(
-        &self,
-        from_timestamp: u64,
-        to_timestamp: u64,
-    ) -> trc::Result<Vec<Metric<EventType, MetricType, u64>>> {
-        let mut metrics = Vec::new();
-        self.iterate(
-            IterateParams::new(
-                ValueKey::from(ValueClass::Telemetry(TelemetryClass::Metric {
-                    timestamp: from_timestamp,
-                    metric_id: 0,
-                    node_id: 0,
-                })),
-                ValueKey::from(ValueClass::Telemetry(TelemetryClass::Metric {
-                    timestamp: to_timestamp,
-                    metric_id: 0,
-                    node_id: 0,
-                })),
-            ),
-            |key, value| {
-                let timestamp = key.deserialize_be_u64(0).caused_by(trc::location!())?;
-                let (metric_type, _) = key
-                    .get(U64_LEN..)
-                    .and_then(|bytes| bytes.read_leb128::<u64>())
-                    .ok_or_else(|| trc::Error::corrupted_key(key, None, trc::location!()))?;
-                match metric_type & 0x03 {
-                    TYPE_COUNTER => {
-                        let id = EventType::from_code(metric_type >> 2).ok_or_else(|| {
-                            trc::Error::corrupted_key(key, None, trc::location!())
-                        })?;
-                        let (value, _) = value.read_leb128::<u64>().ok_or_else(|| {
-                            trc::Error::corrupted_key(key, value.into(), trc::location!())
-                        })?;
-                        metrics.push(Metric::Counter {
-                            id,
-                            timestamp,
-                            value,
-                        });
-                    }
-                    TYPE_HISTOGRAM => {
-                        let id = MetricType::from_code(metric_type >> 2).ok_or_else(|| {
-                            trc::Error::corrupted_key(key, None, trc::location!())
-                        })?;
-                        let (count, bytes_read) = value.read_leb128::<u64>().ok_or_else(|| {
-                            trc::Error::corrupted_key(key, value.into(), trc::location!())
-                        })?;
-                        let (sum, _) = value
-                            .get(bytes_read..)
-                            .and_then(|bytes| bytes.read_leb128::<u64>())
-                            .ok_or_else(|| {
-                                trc::Error::corrupted_key(key, value.into(), trc::location!())
-                            })?;
-                        metrics.push(Metric::Histogram {
-                            id,
-                            timestamp,
-                            count,
-                            sum,
-                        });
-                    }
-                    TYPE_GAUGE => {
-                        let id = MetricType::from_code(metric_type >> 2).ok_or_else(|| {
-                            trc::Error::corrupted_key(key, None, trc::location!())
-                        })?;
-                        let (value, _) = value.read_leb128::<u64>().ok_or_else(|| {
-                            trc::Error::corrupted_key(key, value.into(), trc::location!())
-                        })?;
-                        metrics.push(Metric::Gauge {
-                            id,
-                            timestamp,
-                            value,
-                        });
-                    }
-                    _ => return Err(trc::Error::corrupted_key(key, None, trc::location!())),
-                }
-
-                Ok(true)
-            },
-        )
-        .await
-        .caused_by(trc::location!())?;
-
-        Ok(metrics)
-    }
-
-    async fn purge_metrics(&self, period: Duration) -> trc::Result<()> {
-        self.delete_range(
-            ValueKey::from(ValueClass::Telemetry(TelemetryClass::Metric {
-                timestamp: 0,
-                metric_id: 0,
-                node_id: 0,
-            })),
-            ValueKey::from(ValueClass::Telemetry(TelemetryClass::Metric {
-                timestamp: now() - period.as_secs(),
-                metric_id: 0,
-                node_id: 0,
-            })),
-        )
-        .await
-        .caused_by(trc::location!())
-    }
-}
-
-impl MetricsHistory {
-    pub fn init() -> SharedMetricHistory {
-        Arc::new(Mutex::new(Self::default()))
-    }
-}
diff --git a/crates/common/src/telemetry/mod.rs b/crates/common/src/telemetry/mod.rs
index 64c0348e..2a27208f 100644
--- a/crates/common/src/telemetry/mod.rs
+++ b/crates/common/src/telemetry/mod.rs
@@ -108,15 +108,6 @@ impl TelemetrySubscriberType {
             TelemetrySubscriberType::JournalTracer(subscriber) => {
                 tracers::journald::spawn_journald_tracer(builder, subscriber)
             }
-            // SPDX-SnippetBegin
-            // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-            // SPDX-License-Identifier: LicenseRef-SEL
-            #[cfg(feature = "enterprise")]
-            TelemetrySubscriberType::StoreTracer(subscriber) => {
-                if is_enterprise {
-                    tracers::store::spawn_store_tracer(builder, subscriber)
-                }
-            } // SPDX-SnippetEnd
         }
     }
 }
diff --git a/crates/common/src/telemetry/tracers/mod.rs b/crates/common/src/telemetry/tracers/mod.rs
index 02d20bfa..80443b42 100644
--- a/crates/common/src/telemetry/tracers/mod.rs
+++ b/crates/common/src/telemetry/tracers/mod.rs
@@ -10,9 +10,3 @@ pub mod log;
 pub mod otel;
 pub mod stdout;
 
-// SPDX-SnippetBegin
-// SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-// SPDX-License-Identifier: LicenseRef-SEL
-#[cfg(feature = "enterprise")]
-pub mod store;
-// SPDX-SnippetEnd
diff --git a/crates/common/src/telemetry/tracers/store.rs b/crates/common/src/telemetry/tracers/store.rs
deleted file mode 100644
index f87aaa4d..00000000
--- a/crates/common/src/telemetry/tracers/store.rs
+++ /dev/null
@@ -1,445 +0,0 @@
-/*
- * SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
- *
- * SPDX-License-Identifier: LicenseRef-SEL
- *
- * This file is subject to the Stalwart Enterprise License Agreement (SEL) and
- * is NOT open source software.
- *
- */
-
-use std::{future::Future, time::Duration};
-
-use ahash::{AHashMap, AHashSet};
-use store::{
-    Deserialize, IterateParams, Store, U64_LEN, ValueKey,
-    write::{BatchBuilder, TelemetryClass, ValueClass, key::DeserializeBigEndian},
-};
-use trc::{
-    AddContext, AuthEvent, Event, EventDetails, EventType, Key, MessageIngestEvent,
-    OutgoingReportEvent, QueueEvent, Value,
-    ipc::subscriber::SubscriberBuilder,
-    serializers::binary::{deserialize_events, serialize_events},
-};
-use utils::snowflake::SnowflakeIdGenerator;
-
-use crate::config::telemetry::StoreTracer;
-
-const MAX_EVENTS: usize = 2048;
-
-pub(crate) fn spawn_store_tracer(builder: SubscriberBuilder, settings: StoreTracer) {
-    let (_, mut rx) = builder.register();
-    tokio::spawn(async move {
-        let mut active_spans = AHashMap::new();
-        let store = settings.store;
-        let mut batch = BatchBuilder::new();
-
-        while let Some(events) = rx.recv().await {
-            for event in events {
-                if let Some(span) = &event.inner.span {
-                    let span_id = span.span_id().unwrap();
-                    if !event.inner.typ.is_span_end() {
-                        let events = active_spans.entry(span_id).or_insert_with(Vec::new);
-                        if events.len() < MAX_EVENTS {
-                            events.push(event);
-                        }
-                    } else if let Some(events) = active_spans.remove(&span_id) {
-                        let mut queue_ids = AHashSet::new();
-                        let mut values = AHashSet::new();
-
-                        for event in events.iter().chain([span, &event]) {
-                            for (key, value) in &event.keys {
-                                match (key, value) {
-                                    (Key::QueueId, Value::UInt(queue_id)) => {
-                                        queue_ids.insert(*queue_id);
-                                    }
-                                    (
-                                        Key::From | Key::To | Key::Domain | Key::Hostname,
-                                        Value::String(address),
-                                    ) => {
-                                        values.insert(address.clone());
-                                    }
-                                    (Key::To, Value::Array(value)) => {
-                                        for value in value {
-                                            if let Value::String(address) = value {
-                                                values.insert(address.clone());
-                                            }
-                                        }
-                                    }
-                                    (Key::RemoteIp, Value::Ipv4(ip)) => {
-                                        values.insert(ip.to_string().into());
-                                    }
-                                    (Key::RemoteIp, Value::Ipv6(ip)) => {
-                                        values.insert(ip.to_string().into());
-                                    }
-
-                                    _ => {}
-                                }
-                            }
-                        }
-
-                        if !queue_ids.is_empty() {
-                            // Serialize events
-                            batch.set(
-                                ValueClass::Telemetry(TelemetryClass::Span { span_id }),
-                                serialize_events(
-                                    [span.as_ref()]
-                                        .into_iter()
-                                        .chain(events.iter().map(|event| event.as_ref()))
-                                        .chain([event.as_ref()].into_iter()),
-                                    events.len() + 2,
-                                ),
-                            );
-
-                            // Build index
-                            batch.set(
-                                ValueClass::Telemetry(TelemetryClass::Index {
-                                    span_id,
-                                    value: (span.inner.typ.code() as u16).to_be_bytes().to_vec(),
-                                }),
-                                vec![],
-                            );
-                            for queue_id in queue_ids {
-                                batch.set(
-                                    ValueClass::Telemetry(TelemetryClass::Index {
-                                        span_id,
-                                        value: queue_id.to_be_bytes().to_vec(),
-                                    }),
-                                    vec![],
-                                );
-                            }
-                            for value in values {
-                                batch.set(
-                                    ValueClass::Telemetry(TelemetryClass::Index {
-                                        span_id,
-                                        value: value.as_bytes().to_vec(),
-                                    }),
-                                    vec![],
-                                );
-                            }
-                        }
-                    }
-                }
-            }
-
-            if !batch.is_empty() {
-                if let Err(err) = store.write(batch.build_all()).await {
-                    trc::error!(err.caused_by(trc::location!()));
-                }
-                batch = BatchBuilder::new();
-            }
-        }
-    });
-}
-
-pub enum TracingQuery {
-    EventType(EventType),
-    QueueId(u64),
-    Keywords(String),
-}
-
-pub trait TracingStore: Sync + Send {
-    fn get_span(
-        &self,
-        span_id: u64,
-    ) -> impl Future<Output = trc::Result<Vec<Event<EventDetails>>>> + Send;
-    fn get_raw_span(
-        &self,
-        span_id: u64,
-    ) -> impl Future<Output = trc::Result<Option<Vec<u8>>>> + Send;
-    fn query_spans(
-        &self,
-        params: &[TracingQuery],
-        from_span_id: u64,
-        to_span_id: u64,
-    ) -> impl Future<Output = trc::Result<Vec<u64>>> + Send;
-    fn purge_spans(&self, period: Duration) -> impl Future<Output = trc::Result<()>> + Send;
-}
-
-impl TracingStore for Store {
-    async fn get_span(&self, span_id: u64) -> trc::Result<Vec<Event<EventDetails>>> {
-        self.get_value::<Span>(ValueKey::from(ValueClass::Telemetry(
-            TelemetryClass::Span { span_id },
-        )))
-        .await
-        .caused_by(trc::location!())
-        .map(|span| span.map(|span| span.0).unwrap_or_default())
-    }
-
-    async fn get_raw_span(&self, span_id: u64) -> trc::Result<Option<Vec<u8>>> {
-        self.get_value::<RawSpan>(ValueKey::from(ValueClass::Telemetry(
-            TelemetryClass::Span { span_id },
-        )))
-        .await
-        .caused_by(trc::location!())
-        .map(|span| span.map(|span| span.0))
-    }
-
-    async fn query_spans(
-        &self,
-        params: &[TracingQuery],
-        from_span_id: u64,
-        to_span_id: u64,
-    ) -> trc::Result<Vec<u64>> {
-        let mut spans = SpanCollector::Empty;
-        let num_params = params.len();
-
-        for (param_num, param) in params.iter().enumerate() {
-            let (value, exact_len) = match param {
-                TracingQuery::EventType(event) => (
-                    (event.code() as u16).to_be_bytes().to_vec(),
-                    std::mem::size_of::<u16>() + U64_LEN,
-                ),
-                TracingQuery::QueueId(id) => (
-                    id.to_be_bytes().to_vec(),
-                    std::mem::size_of::<u64>() + U64_LEN,
-                ),
-                TracingQuery::Keywords(value) => {
-                    if let Some(value) = value.strip_prefix('"').and_then(|v| v.strip_suffix('"')) {
-                        (value.as_bytes().to_vec(), value.len() + U64_LEN)
-                    } else {
-                        (value.as_bytes().to_vec(), 0)
-                    }
-                }
-            };
-
-            let mut param_spans = SpanCollector::new(num_params);
-            self.iterate(
-                IterateParams::new(
-                    ValueKey::from(ValueClass::Telemetry(TelemetryClass::Index {
-                        span_id: 0,
-                        value: value.clone(),
-                    })),
-                    ValueKey::from(ValueClass::Telemetry(TelemetryClass::Index {
-                        span_id: u64::MAX,
-                        value,
-                    })),
-                )
-                .no_values(),
-                |key, _| {
-                    if exact_len == 0 || key.len() == exact_len {
-                        let span_id = key
-                            .deserialize_be_u64(key.len() - U64_LEN)
-                            .caused_by(trc::location!())?;
-
-                        if (from_span_id == 0 || span_id >= from_span_id)
-                            && (to_span_id == 0 || span_id <= to_span_id)
-                        {
-                            param_spans.insert(span_id);
-                        }
-                    }
-
-                    Ok(true)
-                },
-            )
-            .await
-            .caused_by(trc::location!())?;
-
-            if param_num == 0 {
-                spans = param_spans;
-            } else if spans.intersect(param_spans) {
-                return Ok(Vec::new());
-            }
-        }
-
-        Ok(spans.into_vec())
-    }
-
-    async fn purge_spans(&self, period: Duration) -> trc::Result<()> {
-        let until_span_id = SnowflakeIdGenerator::from_duration(period).ok_or_else(|| {
-            trc::StoreEvent::UnexpectedError
-                .caused_by(trc::location!())
-                .ctx(trc::Key::Reason, "Failed to generate reference span id.")
-        })?;
-
-        self.delete_range(
-            ValueKey::from(ValueClass::Telemetry(TelemetryClass::Span { span_id: 0 })),
-            ValueKey::from(ValueClass::Telemetry(TelemetryClass::Span {
-                span_id: until_span_id,
-            })),
-        )
-        .await
-        .caused_by(trc::location!())?;
-
-        let mut delete_keys: Vec<ValueClass> = Vec::new();
-        self.iterate(
-            IterateParams::new(
-                ValueKey::from(ValueClass::Telemetry(TelemetryClass::Index {
-                    span_id: 0,
-                    value: vec![],
-                })),
-                ValueKey::from(ValueClass::Telemetry(TelemetryClass::Index {
-                    span_id: u64::MAX,
-                    value: vec![u8::MAX; 16],
-                })),
-            )
-            .no_values(),
-            |key, _| {
-                let span_id = key
-                    .deserialize_be_u64(key.len() - U64_LEN)
-                    .caused_by(trc::location!())?;
-                if span_id < until_span_id {
-                    delete_keys.push(ValueClass::Telemetry(TelemetryClass::Index {
-                        span_id,
-                        value: key[0..key.len() - U64_LEN].to_vec(),
-                    }));
-                }
-
-                Ok(true)
-            },
-        )
-        .await
-        .caused_by(trc::location!())?;
-
-        if !delete_keys.is_empty() {
-            // Commit index
-            let mut batch = BatchBuilder::new();
-
-            for key in delete_keys {
-                if batch.is_large_batch() {
-                    self.write(batch.build_all()).await?;
-                    batch = BatchBuilder::new();
-                }
-                batch.clear(key);
-            }
-
-            if !batch.is_empty() {
-                self.write(batch.build_all()).await?;
-            }
-        }
-
-        Ok(())
-    }
-}
-
-enum SpanCollector {
-    Vec(Vec<u64>),
-    HashSet(AHashSet<u64>),
-    Empty,
-}
-
-impl SpanCollector {
-    fn new(num_params: usize) -> Self {
-        if num_params == 1 {
-            Self::Vec(Vec::new())
-        } else {
-            Self::HashSet(AHashSet::new())
-        }
-    }
-
-    fn insert(&mut self, span_id: u64) {
-        match self {
-            Self::Vec(vec) => vec.push(span_id),
-            Self::HashSet(set) => {
-                set.insert(span_id);
-            }
-            _ => unreachable!(),
-        }
-    }
-
-    fn into_vec(self) -> Vec<u64> {
-        match self {
-            Self::Vec(mut vec) => {
-                vec.sort_unstable_by(|a, b| b.cmp(a));
-                vec
-            }
-            Self::HashSet(set) => {
-                let mut vec: Vec<u64> = set.into_iter().collect();
-                vec.sort_unstable_by(|a, b| b.cmp(a));
-                vec
-            }
-            Self::Empty => Vec::new(),
-        }
-    }
-
-    fn intersect(&mut self, other_span: Self) -> bool {
-        match (self, other_span) {
-            (Self::HashSet(set), Self::HashSet(other_set)) => {
-                set.retain(|span_id| other_set.contains(span_id));
-                set.is_empty()
-            }
-            _ => unreachable!(),
-        }
-    }
-}
-
-impl StoreTracer {
-    pub fn default_events() -> impl IntoIterator<Item = EventType> {
-        EventType::variants().into_iter().filter(|event| {
-            !event.is_raw_io()
-                && matches!(
-                    event,
-                    EventType::MessageIngest(
-                        MessageIngestEvent::Ham
-                            | MessageIngestEvent::Spam
-                            | MessageIngestEvent::Duplicate
-                            | MessageIngestEvent::Error
-                    ) | EventType::Smtp(_)
-                        | EventType::Delivery(_)
-                        | EventType::MtaSts(_)
-                        | EventType::TlsRpt(_)
-                        | EventType::Dane(_)
-                        | EventType::Iprev(_)
-                        | EventType::Spf(_)
-                        | EventType::Dmarc(_)
-                        | EventType::Dkim(_)
-                        | EventType::MailAuth(_)
-                        | EventType::Queue(
-                            QueueEvent::QueueMessage
-                                | QueueEvent::QueueMessageAuthenticated
-                                | QueueEvent::QueueReport
-                                | QueueEvent::QueueDsn
-                                | QueueEvent::QueueAutogenerated
-                                | QueueEvent::Rescheduled
-                                | QueueEvent::RateLimitExceeded
-                                | QueueEvent::ConcurrencyLimitExceeded
-                                | QueueEvent::QuotaExceeded
-                        )
-                        | EventType::Limit(_)
-                        | EventType::Tls(_)
-                        | EventType::IncomingReport(_)
-                        | EventType::OutgoingReport(
-                            OutgoingReportEvent::SpfReport
-                                | OutgoingReportEvent::SpfRateLimited
-                                | OutgoingReportEvent::DkimReport
-                                | OutgoingReportEvent::DkimRateLimited
-                                | OutgoingReportEvent::DmarcReport
-                                | OutgoingReportEvent::DmarcRateLimited
-                                | OutgoingReportEvent::DmarcAggregateReport
-                                | OutgoingReportEvent::TlsAggregate
-                                | OutgoingReportEvent::HttpSubmission
-                                | OutgoingReportEvent::UnauthorizedReportingAddress
-                                | OutgoingReportEvent::ReportingAddressValidationError
-                                | OutgoingReportEvent::NotFound
-                                | OutgoingReportEvent::SubmissionError
-                                | OutgoingReportEvent::NoRecipientsFound
-                        )
-                        | EventType::Auth(
-                            AuthEvent::Success
-                                | AuthEvent::Failed
-                                | AuthEvent::TooManyAttempts
-                                | AuthEvent::Error
-                        )
-                        | EventType::Sieve(_)
-                        | EventType::Milter(_)
-                        | EventType::MtaHook(_)
-                        | EventType::Security(_)
-                )
-        })
-    }
-}
-
-struct RawSpan(Vec<u8>);
-struct Span(Vec<Event<EventDetails>>);
-
-impl Deserialize for Span {
-    fn deserialize(bytes: &[u8]) -> trc::Result<Self> {
-        deserialize_events(bytes).map(Self)
-    }
-}
-
-impl Deserialize for RawSpan {
-    fn deserialize(bytes: &[u8]) -> trc::Result<Self> {
-        Ok(Self(bytes.to_vec()))
-    }
-}
diff --git a/crates/directory/src/backend/internal/manage.rs b/crates/directory/src/backend/internal/manage.rs
index 7794e123..f1c72240 100644
--- a/crates/directory/src/backend/internal/manage.rs
+++ b/crates/directory/src/backend/internal/manage.rs
@@ -266,49 +266,6 @@ impl ManageDirectory for Store {
         }
         let mut valid_domains: AHashSet<String> = AHashSet::new();
 
-        // SPDX-SnippetBegin
-        // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-        // SPDX-License-Identifier: LicenseRef-SEL
-
-        // Validate tenant
-        #[cfg(feature = "enterprise")]
-        if let Some(tenant_id) = tenant_id {
-            let tenant = self
-                .query(crate::QueryParams::id(tenant_id).with_return_member_of(false))
-                .await?
-                .ok_or_else(|| {
-                    trc::ManageEvent::NotFound
-                        .into_err()
-                        .id(tenant_id)
-                        .details("Tenant not found")
-                        .caused_by(trc::location!())
-                })?;
-
-            // Enforce tenant quotas
-            if let Some(limit) = tenant
-                .principal_quota(&principal_set.typ())
-                .filter(|q| *q > 0)
-            {
-                // Obtain number of principals
-                let total = self
-                    .count_principals(None, principal_set.typ().into(), tenant_id.into())
-                    .await
-                    .caused_by(trc::location!())?;
-
-                if total >= limit {
-                    trc::bail!(
-                        trc::LimitEvent::TenantQuota
-                            .into_err()
-                            .details("Tenant principal quota exceeded")
-                            .ctx(trc::Key::Details, principal_set.typ().as_str())
-                            .ctx(trc::Key::Limit, limit)
-                            .ctx(trc::Key::Total, total)
-                    );
-                }
-            }
-        }
-
-        // SPDX-SnippetEnd
 
         // Make sure new name is not taken
         if self
@@ -322,58 +279,6 @@ impl ManageDirectory for Store {
 
         let mut principal_create = Principal::new(0, principal_set.typ());
 
-        // SPDX-SnippetBegin
-        // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-        // SPDX-License-Identifier: LicenseRef-SEL
-
-        // Obtain tenant id, only if no default tenant is provided
-        #[cfg(feature = "enterprise")]
-        if let (Some(tenant_name), None) =
-            (principal_set.take_str(PrincipalField::Tenant), tenant_id)
-        {
-            tenant_id = self
-                .get_principal_info(&tenant_name)
-                .await
-                .caused_by(trc::location!())?
-                .filter(|v| v.typ == Type::Tenant)
-                .ok_or_else(|| not_found(tenant_name.clone()))?
-                .id
-                .into();
-        }
-
-        // Tenants must provide principal names including a valid domain
-        #[cfg(feature = "enterprise")]
-        if let Some(tenant_id) = tenant_id {
-            if matches!(principal_set.typ, Type::Tenant) {
-                return Err(error(
-                    "Invalid field",
-                    "Tenants cannot contain a tenant field".into(),
-                ));
-            }
-
-            principal_create.tenant = tenant_id.into();
-
-            if !matches!(principal_create.typ, Type::Tenant | Type::Domain) {
-                if let Some(domain) = name.split('@').nth(1)
-                    && self
-                        .get_principal_info(domain)
-                        .await
-                        .caused_by(trc::location!())?
-                        .filter(|v| v.typ == Type::Domain && v.has_tenant_access(tenant_id.into()))
-                        .is_some()
-                {
-                    valid_domains.insert(domain.into());
-                }
-
-                if valid_domains.is_empty() {
-                    return Err(error(
-                        "Invalid principal name",
-                        "Principal name must include a valid domain assigned to the tenant".into(),
-                    ));
-                }
-            }
-        }
-        // SPDX-SnippetEnd
 
         // Set fields
         principal_create.name = name;
@@ -667,126 +572,6 @@ impl ManageDirectory for Store {
 
         let tenant = principal.tenant.as_ref().map(|t| t.to_native());
 
-        // SPDX-SnippetBegin
-        // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-        // SPDX-License-Identifier: LicenseRef-SEL
-
-        // Make sure tenant has no data
-        #[cfg(feature = "enterprise")]
-        match typ {
-            Type::Individual | Type::Group => {
-                // Update tenant quota
-                if let Some(tenant_id) = tenant {
-                    let quota = self
-                        .get_counter(DirectoryClass::UsedQuota(principal_id))
-                        .await
-                        .caused_by(trc::location!())?;
-                    if quota > 0 {
-                        batch.add(DirectoryClass::UsedQuota(tenant_id), -quota);
-                    }
-                }
-            }
-            Type::Tenant => {
-                let tenant_members = self
-                    .list_principals(
-                        None,
-                        principal_id.into(),
-                        &[
-                            Type::Individual,
-                            Type::Group,
-                            Type::Role,
-                            Type::List,
-                            Type::Resource,
-                            Type::Other,
-                            Type::Location,
-                            Type::Domain,
-                            Type::ApiKey,
-                        ],
-                        false,
-                        0,
-                        0,
-                    )
-                    .await
-                    .caused_by(trc::location!())?;
-
-                if tenant_members.total > 0 {
-                    let mut message =
-                        String::from("Tenant must have no members to be deleted: Found: ");
-
-                    for (num, principal) in tenant_members.items.iter().enumerate() {
-                        if num > 0 {
-                            message.push_str(", ");
-                        }
-                        message.push_str(principal.name());
-                    }
-
-                    if tenant_members.total > 5 {
-                        message.push_str(" and ");
-                        message.push_str(&(tenant_members.total - 5).to_string());
-                        message.push_str(" others");
-                    }
-
-                    return Err(error("Tenant has members", message.into()));
-                }
-            }
-            Type::Domain => {
-                if let Some(tenant_id) = tenant {
-                    let name = principal.name.as_str();
-                    let tenant_members = self
-                        .list_principals(
-                            None,
-                            tenant_id.into(),
-                            &[
-                                Type::Individual,
-                                Type::Group,
-                                Type::Role,
-                                Type::List,
-                                Type::Resource,
-                                Type::Other,
-                                Type::Location,
-                            ],
-                            false,
-                            0,
-                            0,
-                        )
-                        .await
-                        .caused_by(trc::location!())?;
-                    let domain_members = tenant_members
-                        .items
-                        .iter()
-                        .filter(|v| {
-                            v.name()
-                                .rsplit_once('@')
-                                .is_some_and(|(_, d)| d.eq_ignore_ascii_case(name))
-                        })
-                        .collect::<Vec<_>>();
-                    let total_domain_members = domain_members.len();
-
-                    if total_domain_members > 0 {
-                        let mut message =
-                            String::from("Domains must have no members to be deleted: Found: ");
-
-                        for (num, principal) in domain_members.iter().enumerate() {
-                            if num > 0 {
-                                message.push_str(", ");
-                            }
-                            message.push_str(principal.name());
-                        }
-
-                        if total_domain_members > 5 {
-                            message.push_str(" and ");
-                            message.push_str(&(total_domain_members - 5).to_string());
-                            message.push_str(" others");
-                        }
-
-                        return Err(error("Domain has members", message.into()));
-                    }
-                }
-            }
-
-            _ => {}
-        }
-        // SPDX-SnippetEnd
 
         // Unlink all principal's blobs
         self.blob_hash_unlink_account(principal_id)
@@ -949,27 +734,6 @@ impl ManageDirectory for Store {
 
         let mut used_quota: Option<i64> = None;
 
-        // SPDX-SnippetBegin
-        // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-        // SPDX-License-Identifier: LicenseRef-SEL
-
-        // Obtain used quota
-        #[cfg(feature = "enterprise")]
-        if tenant_id.is_none()
-            && changes
-                .iter()
-                .any(|c| matches!(c.field, PrincipalField::Tenant))
-        {
-            let quota = self
-                .get_counter(DirectoryClass::UsedQuota(principal_id))
-                .await
-                .caused_by(trc::location!())?;
-            if quota > 0 {
-                used_quota = Some(quota);
-            }
-        }
-
-        // SPDX-SnippetEnd
 
         // Allowed principal types for Member fields
         let allowed_member_types = match principal_type {
@@ -1050,73 +814,6 @@ impl ManageDirectory for Store {
                     }
                 }
 
-                // SPDX-SnippetBegin
-                // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-                // SPDX-License-Identifier: LicenseRef-SEL
-                #[cfg(feature = "enterprise")]
-                (
-                    PrincipalAction::Set,
-                    PrincipalField::Tenant,
-                    PrincipalValue::String(tenant_name),
-                ) if tenant_id.is_none() => {
-                    if !tenant_name.is_empty() {
-                        let tenant_info = self
-                            .get_principal_info(&tenant_name)
-                            .await
-                            .caused_by(trc::location!())?
-                            .ok_or_else(|| not_found(tenant_name.clone()))?;
-
-                        if tenant_info.typ != Type::Tenant {
-                            return Err(error(
-                                "Not a tenant",
-                                format!("Principal {tenant_name:?} is not a tenant").into(),
-                            ));
-                        }
-
-                        if principal.tenant() == Some(tenant_info.id) {
-                            continue;
-                        }
-
-                        // Update quota
-                        if let Some(used_quota) = used_quota {
-                            if let Some(old_tenant_id) = principal.tenant() {
-                                batch.add(DirectoryClass::UsedQuota(old_tenant_id), -used_quota);
-                            }
-                            batch.add(DirectoryClass::UsedQuota(tenant_info.id), used_quota);
-                        }
-
-                        // Tenant changed, update changed principals
-                        changed_principals.add_change(principal_id, principal_type, change.field);
-
-                        principal.tenant = tenant_info.id.into();
-                        pinfo_name =
-                            PrincipalInfo::new(principal_id, principal_type, tenant_info.id.into())
-                                .serialize();
-                    } else if let Some(tenant_id) = principal.tenant() {
-                        // Update quota
-                        if let Some(used_quota) = used_quota {
-                            batch.add(DirectoryClass::UsedQuota(tenant_id), -used_quota);
-                        }
-
-                        // Tenant changed, update changed principals
-                        changed_principals.add_change(principal_id, principal_type, change.field);
-
-                        principal.tenant = None;
-                        pinfo_name =
-                            PrincipalInfo::new(principal_id, principal_type, None).serialize();
-                    } else {
-                        continue;
-                    }
-
-                    batch.set(
-                        ValueClass::Directory(DirectoryClass::NameToId(
-                            principal.name().as_bytes().to_vec(),
-                        )),
-                        pinfo_name.clone(),
-                    );
-                }
-
-                // SPDX-SnippetEnd
                 (
                     PrincipalAction::Set,
                     PrincipalField::Secrets,
@@ -2322,23 +2019,6 @@ impl ManageDirectory for Store {
             }
         }
 
-        // SPDX-SnippetBegin
-        // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-        // SPDX-License-Identifier: LicenseRef-SEL
-
-        // Map tenant name
-        #[cfg(feature = "enterprise")]
-        if let Some(tenant_id) = principal.tenant
-            && (fields.is_empty() || fields.contains(&PrincipalField::Tenant))
-            && let Some(name) = self
-                .get_principal_name(tenant_id)
-                .await
-                .caused_by(trc::location!())?
-        {
-            result.set(PrincipalField::Tenant, name);
-        }
-
-        // SPDX-SnippetEnd
 
         // Map fields
         for (name, value) in [
diff --git a/crates/directory/src/backend/internal/mod.rs b/crates/directory/src/backend/internal/mod.rs
index f413df89..68c4bead 100644
--- a/crates/directory/src/backend/internal/mod.rs
+++ b/crates/directory/src/backend/internal/mod.rs
@@ -21,17 +21,6 @@ pub struct PrincipalInfo {
 }
 
 impl PrincipalInfo {
-    // SPDX-SnippetBegin
-    // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-    // SPDX-License-Identifier: LicenseRef-SEL
-    #[cfg(feature = "enterprise")]
-    pub fn has_tenant_access(&self, tenant_id: Option<u32>) -> bool {
-        tenant_id.is_none_or(|tenant_id| {
-            self.tenant.is_some_and(|t| tenant_id == t)
-                || (self.typ == Type::Tenant && self.id == tenant_id)
-        })
-    }
-    // SPDX-SnippetEnd
 
     #[cfg(not(feature = "enterprise"))]
     pub fn has_tenant_access(&self, _tenant_id: Option<u32>) -> bool {
diff --git a/crates/directory/src/core/config.rs b/crates/directory/src/core/config.rs
index 5203ccda..bb493f6b 100644
--- a/crates/directory/src/core/config.rs
+++ b/crates/directory/src/core/config.rs
@@ -91,17 +91,6 @@ impl Directories {
 
             // Build directory
             if let Some(store) = store {
-                // SPDX-SnippetBegin
-                // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-                // SPDX-License-Identifier: LicenseRef-SEL
-                #[cfg(feature = "enterprise")]
-                if store.is_enterprise_directory() && !is_enterprise {
-                    let message =
-                        format!("Directory {protocol:?} is an Enterprise Edition feature");
-                    config.new_parse_error(("directory", id, "type"), message);
-                    continue;
-                }
-                // SPDX-SnippetEnd
 
                 let directory = Arc::new(Directory {
                     store,
diff --git a/crates/directory/src/core/principal.rs b/crates/directory/src/core/principal.rs
index 6320e4ef..ba05dc91 100644
--- a/crates/directory/src/core/principal.rs
+++ b/crates/directory/src/core/principal.rs
@@ -71,15 +71,6 @@ impl Principal {
             })
     }
 
-    // SPDX-SnippetBegin
-    // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-    // SPDX-License-Identifier: LicenseRef-SEL
-
-    #[cfg(feature = "enterprise")]
-    pub fn tenant(&self) -> Option<u32> {
-        self.tenant
-    }
-    // SPDX-SnippetEnd
 
     #[cfg(not(feature = "enterprise"))]
     pub fn tenant(&self) -> Option<u32> {
@@ -396,14 +387,6 @@ impl PrincipalSet {
         self.get_int(PrincipalField::Quota).unwrap_or_default()
     }
 
-    // SPDX-SnippetBegin
-    // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-    // SPDX-License-Identifier: LicenseRef-SEL
-    #[cfg(feature = "enterprise")]
-    pub fn tenant(&self) -> Option<u32> {
-        self.get_int(PrincipalField::Tenant).map(|v| v as u32)
-    }
-    // SPDX-SnippetEnd
 
     #[cfg(not(feature = "enterprise"))]
     pub fn tenant(&self) -> Option<u32> {
@@ -1473,67 +1456,4 @@ impl Permission {
         false
     }
 
-    // SPDX-SnippetBegin
-    // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-    // SPDX-License-Identifier: LicenseRef-SEL
-
-    #[cfg(feature = "enterprise")]
-    pub const fn is_tenant_admin_permission(&self) -> bool {
-        matches!(
-            self,
-            Permission::MessageQueueList
-                | Permission::MessageQueueGet
-                | Permission::MessageQueueUpdate
-                | Permission::MessageQueueDelete
-                | Permission::OutgoingReportList
-                | Permission::OutgoingReportGet
-                | Permission::OutgoingReportDelete
-                | Permission::IncomingReportList
-                | Permission::IncomingReportGet
-                | Permission::IncomingReportDelete
-                | Permission::IndividualList
-                | Permission::IndividualGet
-                | Permission::IndividualUpdate
-                | Permission::IndividualDelete
-                | Permission::IndividualCreate
-                | Permission::GroupList
-                | Permission::GroupGet
-                | Permission::GroupUpdate
-                | Permission::GroupDelete
-                | Permission::GroupCreate
-                | Permission::DomainList
-                | Permission::DomainGet
-                | Permission::DomainCreate
-                | Permission::DomainUpdate
-                | Permission::DomainDelete
-                | Permission::MailingListList
-                | Permission::MailingListGet
-                | Permission::MailingListCreate
-                | Permission::MailingListUpdate
-                | Permission::MailingListDelete
-                | Permission::RoleList
-                | Permission::RoleGet
-                | Permission::RoleCreate
-                | Permission::RoleUpdate
-                | Permission::RoleDelete
-                | Permission::PrincipalList
-                | Permission::PrincipalGet
-                | Permission::PrincipalCreate
-                | Permission::PrincipalUpdate
-                | Permission::PrincipalDelete
-                | Permission::Undelete
-                | Permission::DkimSignatureCreate
-                | Permission::DkimSignatureGet
-                | Permission::JmapPrincipalGet
-                | Permission::JmapPrincipalQueryChanges
-                | Permission::JmapPrincipalQuery
-                | Permission::ApiKeyList
-                | Permission::ApiKeyGet
-                | Permission::ApiKeyCreate
-                | Permission::ApiKeyUpdate
-                | Permission::ApiKeyDelete
-        ) || self.is_user_permission()
-    }
-
-    // SPDX-SnippetEnd
 }
diff --git a/crates/email/src/message/delete.rs b/crates/email/src/message/delete.rs
index f2e94d8a..c7496598 100644
--- a/crates/email/src/message/delete.rs
+++ b/crates/email/src/message/delete.rs
@@ -330,20 +330,6 @@ impl EmailDeletion for Server {
                     .unarchive::<MessageMetadata>()
                     .caused_by(trc::location!())?;
 
-                // SPDX-SnippetBegin
-                // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-                // SPDX-License-Identifier: LicenseRef-SEL
-
-                // Hold blob for undeletion
-                #[cfg(feature = "enterprise")]
-                self.core.hold_undelete(
-                    &mut batch,
-                    Collection::Email.into(),
-                    &BlobHash::from(&metadata.blob_hash),
-                    u32::from(metadata.size) as usize,
-                );
-
-                // SPDX-SnippetEnd
 
                 // Delete message
                 metadata
diff --git a/crates/groupware/src/calendar/itip.rs b/crates/groupware/src/calendar/itip.rs
index 12134942..b4a3e544 100644
--- a/crates/groupware/src/calendar/itip.rs
+++ b/crates/groupware/src/calendar/itip.rs
@@ -546,17 +546,6 @@ enum Response {
 }
 
 fn render_response(server: &Server, response: Response, language: &str) -> String {
-    // SPDX-SnippetBegin
-    // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-    // SPDX-License-Identifier: LicenseRef-SEL
-    #[cfg(feature = "enterprise")]
-    let template = server
-        .core
-        .enterprise
-        .as_ref()
-        .and_then(|e| e.template_scheduling_web.as_ref())
-        .unwrap_or(&server.core.groupware.itip_template);
-    // SPDX-SnippetEnd
 
     #[cfg(not(feature = "enterprise"))]
     let template = &server.core.groupware.itip_template;
diff --git a/crates/http/src/auth/oauth/auth.rs b/crates/http/src/auth/oauth/auth.rs
index 5addd0fc..f1b54b67 100644
--- a/crates/http/src/auth/oauth/auth.rs
+++ b/crates/http/src/auth/oauth/auth.rs
@@ -131,12 +131,6 @@ impl OAuthApiHandler for Server {
                 #[cfg(not(feature = "enterprise"))]
                 let is_enterprise = false;
 
-                // SPDX-SnippetBegin
-                // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-                // SPDX-License-Identifier: LicenseRef-SEL
-                #[cfg(feature = "enterprise")]
-                let is_enterprise = self.core.is_enterprise_edition();
-                // SPDX-SnippetEnd
 
                 json!({
                     "data": {
diff --git a/crates/http/src/management/enterprise/mod.rs b/crates/http/src/management/enterprise/mod.rs
deleted file mode 100644
index 54b38bb5..00000000
--- a/crates/http/src/management/enterprise/mod.rs
+++ /dev/null
@@ -1,12 +0,0 @@
-/*
- * SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
- *
- * SPDX-License-Identifier: LicenseRef-SEL
- *
- * This file is subject to the Stalwart Enterprise License Agreement (SEL) and
- * is NOT open source software.
- *
- */
-
-pub mod telemetry;
-pub mod undelete;
diff --git a/crates/http/src/management/enterprise/telemetry.rs b/crates/http/src/management/enterprise/telemetry.rs
deleted file mode 100644
index 74ee2f20..00000000
--- a/crates/http/src/management/enterprise/telemetry.rs
+++ /dev/null
@@ -1,540 +0,0 @@
-/*
- * SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
- *
- * SPDX-License-Identifier: LicenseRef-SEL
- *
- * This file is subject to the Stalwart Enterprise License Agreement (SEL) and
- * is NOT open source software.
- *
- */
-
-use std::{
-    fmt::Write,
-    time::{Duration, Instant},
-};
-
-use common::{
-    Server,
-    auth::{AccessToken, oauth::GrantType},
-    telemetry::{
-        metrics::store::{Metric, MetricsStore},
-        tracers::store::{TracingQuery, TracingStore},
-    },
-};
-use directory::{Permission, backend::internal::manage};
-use http_body_util::{StreamBody, combinators::BoxBody};
-use http_proto::*;
-use hyper::{
-    Method, StatusCode,
-    body::{Bytes, Frame},
-};
-use mail_parser::DateTime;
-use serde_json::json;
-use std::future::Future;
-use store::ahash::{AHashMap, AHashSet};
-use trc::{
-    Collector, DeliveryEvent, EventType, Key, MetricType, QueueEvent, Value,
-    ipc::{bitset::Bitset, subscriber::SubscriberBuilder},
-    serializers::json::JsonEventSerializer,
-};
-use utils::{snowflake::SnowflakeIdGenerator, url_params::UrlParams};
-
-use crate::management::Timestamp;
-
-pub trait TelemetryApi: Sync + Send {
-    fn handle_telemetry_api_request(
-        &self,
-        req: &HttpRequest,
-        path: Vec<&str>,
-        access_token: &AccessToken,
-    ) -> impl Future<Output = trc::Result<HttpResponse>> + Send;
-}
-
-impl TelemetryApi for Server {
-    async fn handle_telemetry_api_request(
-        &self,
-        req: &HttpRequest,
-        path: Vec<&str>,
-        access_token: &AccessToken,
-    ) -> trc::Result<HttpResponse> {
-        let params = UrlParams::new(req.uri().query());
-        let account_id = access_token.primary_id();
-
-        match (
-            path.get(1).copied().unwrap_or_default(),
-            path.get(2).copied(),
-            req.method(),
-        ) {
-            ("traces", None, &Method::GET) => {
-                // Validate the access token
-                access_token.assert_has_permission(Permission::TracingList)?;
-
-                let page: usize = params.parse("page").unwrap_or(0);
-                let limit: usize = params.parse("limit").unwrap_or(0);
-                let mut tracing_query = Vec::new();
-                if let Some(typ) = params.parse("type") {
-                    tracing_query.push(TracingQuery::EventType(typ));
-                }
-                if let Some(queue_id) = params.parse("queue_id") {
-                    tracing_query.push(TracingQuery::QueueId(queue_id));
-                }
-                if let Some(query) = params.get("filter") {
-                    let mut buf = String::with_capacity(query.len());
-                    let mut in_quote = false;
-                    for ch in query.chars() {
-                        if ch.is_ascii_whitespace() {
-                            if in_quote {
-                                buf.push(' ');
-                            } else if !buf.is_empty() {
-                                tracing_query.push(TracingQuery::Keywords(buf));
-                                buf = String::new();
-                            }
-                        } else if ch == '"' {
-                            buf.push(ch);
-                            if in_quote {
-                                if !buf.is_empty() {
-                                    tracing_query.push(TracingQuery::Keywords(buf));
-                                    buf = String::new();
-                                }
-                                in_quote = false;
-                            } else {
-                                in_quote = true;
-                            }
-                        } else {
-                            buf.push(ch);
-                        }
-                    }
-                    if !buf.is_empty() {
-                        tracing_query.push(TracingQuery::Keywords(buf));
-                    }
-                }
-                let before = params
-                    .parse::<Timestamp>("before")
-                    .map(|t| t.into_inner())
-                    .and_then(SnowflakeIdGenerator::from_timestamp)
-                    .unwrap_or(0);
-                let after = params
-                    .parse::<Timestamp>("after")
-                    .map(|t| t.into_inner())
-                    .and_then(SnowflakeIdGenerator::from_timestamp)
-                    .unwrap_or(0);
-                let values = params.get("values").is_some();
-                let store = &self
-                    .core
-                    .enterprise
-                    .as_ref()
-                    .and_then(|e| e.trace_store.as_ref())
-                    .ok_or_else(|| manage::unsupported("No tracing store has been configured"))?
-                    .store;
-                let span_ids = store.query_spans(&tracing_query, after, before).await?;
-
-                let (total, span_ids) = if limit > 0 {
-                    let offset = page.saturating_sub(1) * limit;
-                    (
-                        span_ids.len(),
-                        span_ids.into_iter().skip(offset).take(limit).collect(),
-                    )
-                } else {
-                    (span_ids.len(), span_ids)
-                };
-
-                if values && !span_ids.is_empty() {
-                    let mut values = Vec::with_capacity(span_ids.len());
-
-                    for span_id in span_ids {
-                        for event in store.get_span(span_id).await? {
-                            if matches!(
-                                event.inner.typ,
-                                EventType::Delivery(DeliveryEvent::AttemptStart)
-                                    | EventType::Queue(
-                                        QueueEvent::QueueMessage
-                                            | QueueEvent::QueueMessageAuthenticated
-                                    )
-                            ) {
-                                values.push(event);
-                                break;
-                            }
-                        }
-                    }
-
-                    Ok(JsonResponse::new(json!({
-                            "data": {
-                                "items": JsonEventSerializer::new(values).with_spans(),
-                                "total": total,
-                            },
-                    }))
-                    .into_http_response())
-                } else {
-                    Ok(JsonResponse::new(json!({
-                            "data": {
-                                "items": span_ids,
-                                "total": total,
-                            },
-                    }))
-                    .into_http_response())
-                }
-            }
-            ("traces", Some("live"), &Method::GET) => {
-                // Validate the access token
-                access_token.assert_has_permission(Permission::TracingLive)?;
-
-                let mut key_filters = AHashMap::new();
-                let mut filter = None;
-
-                for (key, value) in params.into_inner() {
-                    if key == "filter" {
-                        filter = value.into_owned().into();
-                    } else if let Some(key) = Key::try_parse(key.to_ascii_lowercase().as_str()) {
-                        key_filters.insert(key, value.into_owned());
-                    }
-                }
-
-                let (_, mut rx) = SubscriberBuilder::new("live-tracer".to_string())
-                    .with_interests(Box::new(Bitset::all()))
-                    .with_lossy(false)
-                    .register();
-                let throttle = Duration::from_secs(1);
-                let ping_interval = Duration::from_secs(30);
-                let ping_payload = Bytes::from(format!(
-                    "event: ping\ndata: {{\"interval\": {}}}\n\n",
-                    ping_interval.as_millis()
-                ));
-                let mut last_ping = Instant::now();
-                let mut events = Vec::new();
-                let mut active_span_ids = AHashSet::new();
-
-                Ok(HttpResponse::new(StatusCode::OK)
-                .with_content_type("text/event-stream")
-                .with_cache_control("no-store")
-                .with_stream_body(BoxBody::new(StreamBody::new(
-                    async_stream::stream! {
-                        let mut last_message = Instant::now() - throttle;
-                        let mut timeout = ping_interval;
-
-                        loop {
-                            match tokio::time::timeout(timeout, rx.recv()).await {
-                                Ok(Some(event_batch)) => {
-                                    for event in event_batch {
-                                        if (filter.is_none() && key_filters.is_empty())
-                                            || event
-                                                .span_id()
-                                                .is_some_and(|span_id| active_span_ids.contains(&span_id))
-                                        {
-                                            events.push(event);
-                                        } else {
-                                            let mut matched_keys = AHashSet::new();
-                                            for (key, value) in event
-                                                .keys
-                                                .iter()
-                                                .chain(event.inner.span.as_ref().map_or(([]).iter(), |s| s.keys.iter()))
-                                            {
-                                                if let Some(needle) = key_filters.get(key).or(filter.as_ref()) {
-                                                    let matches = match value {
-                                                        Value::String(haystack) => haystack.contains(needle),
-                                                        Value::Timestamp(haystack) => {
-                                                            DateTime::from_timestamp(*haystack as i64)
-                                                                .to_rfc3339()
-                                                                .contains(needle)
-                                                        }
-                                                        Value::Bool(true) => needle == "true",
-                                                        Value::Bool(false) => needle == "false",
-                                                        Value::Ipv4(haystack) => haystack.to_string().contains(needle),
-                                                        Value::Ipv6(haystack) => haystack.to_string().contains(needle),
-                                                        Value::Event(_) |
-                                                        Value::Array(_) |
-                                                        Value::UInt(_) |
-                                                        Value::Int(_) |
-                                                        Value::Float(_) |
-                                                        Value::Duration(_) |
-                                                        Value::Bytes(_) |
-                                                        Value::None => false,
-                                                    };
-
-                                                    if matches {
-                                                        matched_keys.insert(*key);
-                                                        if filter.is_some() || matched_keys.len() == key_filters.len() {
-                                                            if let Some(span_id) = event.span_id() {
-                                                                active_span_ids.insert(span_id);
-                                                            }
-                                                            events.push(event);
-                                                            break;
-                                                        }
-                                                    }
-                                                }
-                                            }
-                                        }
-                                    }
-                                }
-                                Ok(None) => {
-                                    break;
-                                }
-                                Err(_) => (),
-                            }
-
-                            timeout = if !events.is_empty() {
-                                let elapsed = last_message.elapsed();
-                                if elapsed >= throttle {
-                                    last_message = Instant::now();
-                                    yield Ok(Frame::data(Bytes::from(format!(
-                                        "event: trace\ndata: {}\n\n",
-                                        serde_json::to_string(
-                                            &JsonEventSerializer::new(std::mem::take(&mut events))
-                                            .with_description()
-                                            .with_explanation()).unwrap_or_default()
-                                    ))));
-
-                                    ping_interval
-                                } else {
-                                    throttle - elapsed
-                                }
-                            } else {
-                                let elapsed = last_ping.elapsed();
-                                if elapsed >= ping_interval {
-                                    last_ping = Instant::now();
-                                    yield Ok(Frame::data(ping_payload.clone()));
-                                    ping_interval
-                                } else {
-                                    ping_interval - elapsed
-                                }
-                            };
-                        }
-                    },
-                ))))
-            }
-            ("trace", id, &Method::GET) => {
-                // Validate the access token
-                access_token.assert_has_permission(Permission::TracingGet)?;
-
-                let store = &self
-                    .core
-                    .enterprise
-                    .as_ref()
-                    .and_then(|e| e.trace_store.as_ref())
-                    .ok_or_else(|| manage::unsupported("No tracing store has been configured"))?
-                    .store;
-
-                let mut events = Vec::new();
-                for span_id in id
-                    .or_else(|| params.get("id"))
-                    .unwrap_or_default()
-                    .split(',')
-                {
-                    if let Ok(span_id) = span_id.parse::<u64>() {
-                        events.push(
-                            JsonEventSerializer::new(store.get_span(span_id).await?)
-                                .with_description()
-                                .with_explanation(),
-                        );
-                    } else {
-                        events.push(JsonEventSerializer::new(Vec::new()));
-                    }
-                }
-
-                if events.len() == 1 && id.is_some() {
-                    Ok(JsonResponse::new(json!({
-                            "data": events.into_iter().next().unwrap(),
-                    }))
-                    .into_http_response())
-                } else {
-                    Ok(JsonResponse::new(json!({
-                            "data": events,
-                    }))
-                    .into_http_response())
-                }
-            }
-            ("live", Some("tracing-token"), &Method::GET) => {
-                // Validate the access token
-                access_token.assert_has_permission(Permission::TracingLive)?;
-
-                // Issue a live telemetry token valid for 60 seconds
-                Ok(JsonResponse::new(json!({
-                    "data": self.encode_access_token(GrantType::LiveTracing, account_id,  "web", 60).await?,
-            }))
-            .into_http_response())
-            }
-            ("live", Some("metrics-token"), &Method::GET) => {
-                // Validate the access token
-                access_token.assert_has_permission(Permission::MetricsLive)?;
-
-                // Issue a live telemetry token valid for 60 seconds
-                Ok(JsonResponse::new(json!({
-                    "data": self.encode_access_token(GrantType::LiveMetrics, account_id, "web", 60).await?,
-            }))
-            .into_http_response())
-            }
-            ("metrics", None, &Method::GET) => {
-                // Validate the access token
-                access_token.assert_has_permission(Permission::MetricsList)?;
-
-                let before = params
-                    .parse::<Timestamp>("before")
-                    .map(|t| t.into_inner())
-                    .unwrap_or(u64::MAX);
-                let after = params
-                    .parse::<Timestamp>("after")
-                    .map(|t| t.into_inner())
-                    .unwrap_or(0);
-                let results = self
-                    .core
-                    .enterprise
-                    .as_ref()
-                    .and_then(|e| e.metrics_store.as_ref())
-                    .ok_or_else(|| {
-                        manage::error(
-                            "No metrics store has been defined",
-                            "You need to configure a metrics store in order to use this feature."
-                                .into(),
-                        )
-                    })?
-                    .store
-                    .query_metrics(after, before)
-                    .await?;
-                let mut metrics = Vec::with_capacity(results.len());
-
-                for metric in results {
-                    metrics.push(match metric {
-                        Metric::Counter {
-                            id,
-                            timestamp,
-                            value,
-                        } => Metric::Counter {
-                            id: id.name(),
-                            timestamp: DateTime::from_timestamp(timestamp as i64).to_rfc3339(),
-                            value,
-                        },
-                        Metric::Histogram {
-                            id,
-                            timestamp,
-                            count,
-                            sum,
-                        } => Metric::Histogram {
-                            id: id.name(),
-                            timestamp: DateTime::from_timestamp(timestamp as i64).to_rfc3339(),
-                            count,
-                            sum,
-                        },
-                        Metric::Gauge {
-                            id,
-                            timestamp,
-                            value,
-                        } => Metric::Gauge {
-                            id: id.name(),
-                            timestamp: DateTime::from_timestamp(timestamp as i64).to_rfc3339(),
-                            value,
-                        },
-                    });
-                }
-
-                Ok(JsonResponse::new(json!({
-                        "data": metrics,
-                }))
-                .into_http_response())
-            }
-            ("metrics", Some("live"), &Method::GET) => {
-                // Validate the access token
-                access_token.assert_has_permission(Permission::MetricsLive)?;
-
-                let interval = Duration::from_secs(
-                    params
-                        .parse::<u64>("interval")
-                        .filter(|interval| *interval >= 1)
-                        .unwrap_or(30),
-                );
-                let mut event_types = AHashSet::new();
-                let mut metric_types = AHashSet::new();
-                for metric_name in params.get("metrics").unwrap_or_default().split(',') {
-                    let metric_name = metric_name.trim();
-                    if !metric_name.is_empty() {
-                        if let Some(event_type) = EventType::try_parse(metric_name) {
-                            event_types.insert(event_type);
-                        } else if let Some(metric_type) = MetricType::try_parse(metric_name) {
-                            metric_types.insert(metric_type);
-                        }
-                    }
-                }
-
-                // Refresh expensive metrics
-                for metric_type in [
-                    MetricType::QueueCount,
-                    MetricType::UserCount,
-                    MetricType::DomainCount,
-                ] {
-                    if metric_types.contains(&metric_type) {
-                        let value = match metric_type {
-                            MetricType::QueueCount => self.total_queued_messages().await?,
-                            MetricType::UserCount => self.total_accounts().await?,
-                            MetricType::DomainCount => self.total_domains().await?,
-                            _ => unreachable!(),
-                        };
-                        Collector::update_gauge(metric_type, value);
-                    }
-                }
-
-                Ok(HttpResponse::new(StatusCode::OK)
-                .with_content_type("text/event-stream")
-                .with_cache_control("no-store")
-                .with_stream_body(BoxBody::new(StreamBody::new(
-                    async_stream::stream! {
-                        loop {
-                            let mut metrics = String::with_capacity(512);
-                            metrics.push_str("event: metrics\ndata: [");
-                            let mut is_first = true;
-
-                            for counter in Collector::collect_counters(true) {
-                                if event_types.is_empty() || event_types.contains(&counter.id()) {
-                                    if !is_first {
-                                        metrics.push(',');
-                                    } else {
-                                        is_first = false;
-                                    }
-                                    let _ = write!(
-                                        &mut metrics,
-                                        "{{\"id\":\"{}\",\"type\":\"counter\",\"value\":{}}}",
-                                        counter.id().name(),
-                                        counter.value()
-                                    );
-                                }
-                            }
-                            for gauge in Collector::collect_gauges(true) {
-                                if metric_types.is_empty() || metric_types.contains(&gauge.id()) {
-                                    if !is_first {
-                                        metrics.push(',');
-                                    } else {
-                                        is_first = false;
-                                    }
-                                    let _ = write!(
-                                        &mut metrics,
-                                        "{{\"id\":\"{}\",\"type\":\"gauge\",\"value\":{}}}",
-                                        gauge.id().name(),
-                                        gauge.get()
-                                    );
-                                }
-                            }
-                            for histogram in Collector::collect_histograms(true) {
-                                if metric_types.is_empty() || metric_types.contains(&histogram.id()) {
-                                    if !is_first {
-                                        metrics.push(',');
-                                    } else {
-                                        is_first = false;
-                                    }
-                                    let _ = write!(
-                                        &mut metrics,
-                                        "{{\"id\":\"{}\",\"type\":\"histogram\",\"count\":{},\"sum\":{}}}",
-                                        histogram.id().name(),
-                                        histogram.count(),
-                                        histogram.sum()
-                                    );
-                                }
-                            }
-                            metrics.push_str("]\n\n");
-
-                            yield Ok(Frame::data(Bytes::from(metrics)));
-                            tokio::time::sleep(interval).await;
-                        }
-                    },
-                ))))
-            }
-            _ => Err(trc::ResourceEvent::NotFound.into_err()),
-        }
-    }
-}
diff --git a/crates/http/src/management/enterprise/undelete.rs b/crates/http/src/management/enterprise/undelete.rs
deleted file mode 100644
index 2519a3c4..00000000
--- a/crates/http/src/management/enterprise/undelete.rs
+++ /dev/null
@@ -1,274 +0,0 @@
-/*
- * SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
- *
- * SPDX-License-Identifier: LicenseRef-SEL
- *
- * This file is subject to the Stalwart Enterprise License Agreement (SEL) and
- * is NOT open source software.
- *
- */
-
-use std::str::FromStr;
-
-use base64::{Engine, engine::general_purpose::URL_SAFE_NO_PAD};
-use common::{Server, enterprise::undelete::DeletedBlob};
-use directory::backend::internal::manage::ManageDirectory;
-use email::{
-    mailbox::INBOX_ID,
-    message::ingest::{EmailIngest, IngestEmail, IngestSource},
-};
-use hyper::Method;
-use jmap_proto::types::collection::Collection;
-use mail_parser::{DateTime, MessageParser};
-use serde_json::json;
-use std::future::Future;
-use store::write::{BatchBuilder, BlobOp, ValueClass};
-use trc::AddContext;
-use utils::{BlobHash, url_params::UrlParams};
-
-use http_proto::{request::decode_path_element, *};
-
-#[derive(serde::Deserialize, serde::Serialize)]
-pub struct UndeleteRequest<H, C, T> {
-    pub hash: H,
-    pub collection: C,
-    #[serde(rename = "restoreTime")]
-    pub time: T,
-    #[serde(rename = "cancelDeletion")]
-    #[serde(default)]
-    pub cancel_deletion: Option<T>,
-}
-
-#[derive(serde::Serialize, serde::Deserialize, PartialEq, Eq, Debug)]
-#[serde(tag = "type")]
-#[serde(rename_all = "camelCase")]
-pub enum UndeleteResponse {
-    Success,
-    NotFound,
-    Error { reason: String },
-}
-
-pub trait UndeleteApi: Sync + Send {
-    fn handle_undelete_api_request(
-        &self,
-        req: &HttpRequest,
-        path: Vec<&str>,
-        body: Option<Vec<u8>>,
-        session: &HttpSessionData,
-    ) -> impl Future<Output = trc::Result<HttpResponse>> + Send;
-}
-
-impl UndeleteApi for Server {
-    async fn handle_undelete_api_request(
-        &self,
-        req: &HttpRequest,
-        path: Vec<&str>,
-        body: Option<Vec<u8>>,
-        session: &HttpSessionData,
-    ) -> trc::Result<HttpResponse> {
-        match (path.get(2).copied(), req.method()) {
-            (Some(account_name), &Method::GET) => {
-                let account_name = decode_path_element(account_name);
-                let account_id = self
-                    .core
-                    .storage
-                    .data
-                    .get_principal_id(account_name.as_ref())
-                    .await?
-                    .ok_or_else(|| trc::ResourceEvent::NotFound.into_err())?;
-                let mut deleted = self.core.list_deleted(account_id).await?;
-
-                let params = UrlParams::new(req.uri().query());
-                let limit = params.parse::<usize>("limit").unwrap_or_default();
-                let mut offset = params
-                    .parse::<usize>("page")
-                    .unwrap_or_default()
-                    .saturating_sub(1)
-                    * limit;
-
-                // Sort ascending by deleted_at
-                let total = deleted.len();
-                deleted.sort_by(|a, b| a.deleted_at.cmp(&b.deleted_at));
-                let mut results = Vec::with_capacity(if limit > 0 { limit } else { total });
-
-                for blob in deleted {
-                    if offset == 0 {
-                        results.push(DeletedBlob {
-                            hash: URL_SAFE_NO_PAD.encode(blob.hash.as_slice()),
-                            size: blob.size,
-                            deleted_at: DateTime::from_timestamp(blob.deleted_at as i64)
-                                .to_rfc3339(),
-                            expires_at: DateTime::from_timestamp(blob.expires_at as i64)
-                                .to_rfc3339(),
-                            collection: Collection::from(blob.collection).to_string(),
-                        });
-                        if results.len() == limit {
-                            break;
-                        }
-                    } else {
-                        offset -= 1;
-                    }
-                }
-
-                Ok(JsonResponse::new(json!({
-                        "data":{
-                            "items": results,
-                            "total": total,
-                        },
-                }))
-                .into_http_response())
-            }
-            (Some(account_name), &Method::POST) => {
-                let account_name = decode_path_element(account_name);
-                let account_id = self
-                    .core
-                    .storage
-                    .data
-                    .get_principal_id(account_name.as_ref())
-                    .await?
-                    .ok_or_else(|| trc::ResourceEvent::NotFound.into_err())?;
-
-                let requests: Vec<UndeleteRequest<BlobHash, Collection, u64>> =
-                    match serde_json::from_slice::<
-                        Option<Vec<UndeleteRequest<String, String, String>>>,
-                    >(body.as_deref().unwrap_or_default())
-                    {
-                        Ok(Some(requests)) => requests
-                            .into_iter()
-                            .map(|request| {
-                                UndeleteRequest {
-                                    hash: BlobHash::try_from_hash_slice(
-                                        URL_SAFE_NO_PAD
-                                            .decode(request.hash.as_bytes())
-                                            .ok()?
-                                            .as_slice(),
-                                    )
-                                    .ok()?,
-                                    collection: Collection::from_str(request.collection.as_str())
-                                        .ok()?,
-                                    time: DateTime::parse_rfc3339(request.time.as_str())?
-                                        .to_timestamp()
-                                        as u64,
-                                    cancel_deletion: if let Some(cancel_deletion) =
-                                        request.cancel_deletion
-                                    {
-                                        (DateTime::parse_rfc3339(cancel_deletion.as_str())?
-                                            .to_timestamp()
-                                            as u64)
-                                            .into()
-                                    } else {
-                                        None
-                                    },
-                                }
-                                .into()
-                            })
-                            .collect::<Option<Vec<_>>>()
-                            .ok_or_else(|| trc::ResourceEvent::BadParameters.into_err())?,
-                        Ok(None) => {
-                            let deleted = self.core.list_deleted(account_id).await?;
-                            let mut results = Vec::with_capacity(deleted.len());
-                            for blob in deleted {
-                                results.push(UndeleteRequest {
-                                    hash: blob.hash,
-                                    collection: Collection::from(blob.collection),
-                                    time: blob.deleted_at,
-                                    cancel_deletion: blob.expires_at.into(),
-                                });
-                            }
-                            results
-                        }
-                        Err(_) => {
-                            return Err(trc::ResourceEvent::BadParameters.into_err());
-                        }
-                    };
-
-                let access_token = self
-                    .get_access_token(account_id)
-                    .await
-                    .caused_by(trc::location!())?;
-                let mut results = Vec::with_capacity(requests.len());
-                let mut batch = BatchBuilder::new();
-                batch.with_account_id(account_id);
-                for request in requests {
-                    match request.collection {
-                        Collection::Email => {
-                            match self
-                                .blob_store()
-                                .get_blob(request.hash.as_slice(), 0..usize::MAX)
-                                .await?
-                            {
-                                Some(bytes) => {
-                                    match self
-                                        .email_ingest(IngestEmail {
-                                            raw_message: &bytes,
-                                            message: MessageParser::new().parse(&bytes),
-                                            access_token: access_token.as_ref(),
-                                            mailbox_ids: vec![INBOX_ID],
-                                            keywords: vec![],
-                                            received_at: request.time.into(),
-                                            source: IngestSource::Restore,
-                                            spam_classify: false,
-                                            spam_train: false,
-                                            session_id: session.session_id,
-                                        })
-                                        .await
-                                    {
-                                        Ok(_) => {
-                                            results.push(UndeleteResponse::Success);
-                                            if let Some(cancel_deletion) = request.cancel_deletion {
-                                                batch.clear(ValueClass::Blob(BlobOp::Reserve {
-                                                    hash: request.hash,
-                                                    until: cancel_deletion,
-                                                }));
-                                            }
-                                        }
-                                        Err(mut err)
-                                            if err.matches(trc::EventType::MessageIngest(
-                                                trc::MessageIngestEvent::Error,
-                                            )) =>
-                                        {
-                                            results.push(UndeleteResponse::Error {
-                                                reason: err
-                                                    .take_value(trc::Key::Reason)
-                                                    .and_then(|v| v.into_string())
-                                                    .unwrap()
-                                                    .to_string(),
-                                            });
-                                        }
-                                        Err(err) => {
-                                            return Err(err.caused_by(trc::location!()));
-                                        }
-                                    }
-                                }
-                                None => {
-                                    results.push(UndeleteResponse::NotFound);
-                                }
-                            }
-                        }
-                        _ => {
-                            results.push(UndeleteResponse::Error {
-                                reason: "Unsupported collection".to_string(),
-                            });
-                        }
-                    }
-                }
-
-                // Commit batch
-                if !batch.is_empty() {
-                    self.core
-                        .storage
-                        .data
-                        .write(batch.build_all())
-                        .await
-                        .caused_by(trc::location!())?;
-                }
-
-                Ok(JsonResponse::new(json!({
-                    "data": results,
-                }))
-                .into_http_response())
-            }
-            _ => Err(trc::ResourceEvent::NotFound.into_err()),
-        }
-    }
-}
diff --git a/crates/http/src/management/mod.rs b/crates/http/src/management/mod.rs
index 24c194b5..173920cb 100644
--- a/crates/http/src/management/mod.rs
+++ b/crates/http/src/management/mod.rs
@@ -17,15 +17,6 @@ pub mod spam;
 pub mod stores;
 pub mod troubleshoot;
 
-// SPDX-SnippetBegin
-// SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-// SPDX-License-Identifier: LicenseRef-SEL
-#[cfg(feature = "enterprise")]
-pub mod enterprise;
-
-#[cfg(feature = "enterprise")]
-use enterprise::telemetry::TelemetryApi;
-// SPDX-SnippetEnd
 
 use crate::auth::oauth::auth::OAuthApiHandler;
 use common::{Server, auth::AccessToken};
@@ -171,28 +162,6 @@ impl ManagementApi for Server {
                 self.handle_troubleshoot_api_request(req, path, &access_token, body)
                     .await
             }
-            // SPDX-SnippetBegin
-            // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-            // SPDX-License-Identifier: LicenseRef-SEL
-            #[cfg(feature = "enterprise")]
-            "telemetry" => {
-                // WARNING: TAMPERING WITH THIS FUNCTION IS STRICTLY PROHIBITED
-                // Any attempt to modify, bypass, or disable this license validation mechanism
-                // constitutes a severe violation of the Stalwart Enterprise License Agreement.
-                // Such actions may result in immediate termination of your license, legal action,
-                // and substantial financial penalties. Stalwart Labs LLC actively monitors for
-                // unauthorized modifications and will pursue all available legal remedies against
-                // violators to the fullest extent of the law, including but not limited to claims
-                // for copyright infringement, breach of contract, and fraud.
-
-                if self.core.is_enterprise_edition() {
-                    self.handle_telemetry_api_request(req, path, &access_token)
-                        .await
-                } else {
-                    Err(manage::enterprise())
-                }
-            }
-            // SPDX-SnippetEnd
             _ => Err(trc::ResourceEvent::NotFound.into_err()),
         }
     }
diff --git a/crates/http/src/management/principal.rs b/crates/http/src/management/principal.rs
index e9b17330..0294045a 100644
--- a/crates/http/src/management/principal.rs
+++ b/crates/http/src/management/principal.rs
@@ -98,19 +98,6 @@ impl PrincipalManager for Server {
                     Type::Resource | Type::Location | Type::Other => Permission::PrincipalCreate,
                 })?;
 
-                // SPDX-SnippetBegin
-                // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-                // SPDX-License-Identifier: LicenseRef-SEL
-
-                #[cfg(feature = "enterprise")]
-                if (matches!(principal.typ(), Type::Tenant)
-                    || principal.has_field(PrincipalField::Tenant))
-                    && !self.core.is_enterprise_edition()
-                {
-                    return Err(manage::enterprise());
-                }
-
-                // SPDX-SnippetEnd
 
                 // Make sure the current directory supports updates
                 if matches!(principal.typ(), Type::Individual) {
@@ -253,28 +240,6 @@ impl PrincipalManager for Server {
 
                 let mut tenant = access_token.tenant.map(|t| t.id);
 
-                // SPDX-SnippetBegin
-                // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-                // SPDX-License-Identifier: LicenseRef-SEL
-                #[cfg(feature = "enterprise")]
-                if self.core.is_enterprise_edition() {
-                    if tenant.is_none() {
-                        // Limit search to current tenant
-                        if let Some(tenant_name) = params.get("tenant") {
-                            tenant = self
-                                .core
-                                .storage
-                                .data
-                                .get_principal_info(tenant_name)
-                                .await?
-                                .filter(|p| p.typ == Type::Tenant)
-                                .map(|p| p.id);
-                        }
-                    }
-                } else if types.contains(&Type::Tenant) {
-                    return Err(manage::enterprise());
-                }
-                // SPDX-SnippetEnd
 
                 let principals = self
                     .store()
@@ -344,28 +309,6 @@ impl PrincipalManager for Server {
 
                 let mut tenant = access_token.tenant.map(|t| t.id);
 
-                // SPDX-SnippetBegin
-                // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-                // SPDX-License-Identifier: LicenseRef-SEL
-                #[cfg(feature = "enterprise")]
-                if self.core.is_enterprise_edition() {
-                    if tenant.is_none() {
-                        // Limit search to current tenant
-                        if let Some(tenant_name) = params.get("tenant") {
-                            tenant = self
-                                .core
-                                .storage
-                                .data
-                                .get_principal_info(tenant_name)
-                                .await?
-                                .filter(|p| p.typ == Type::Tenant)
-                                .map(|p| p.id);
-                        }
-                    }
-                } else if typ == Type::Tenant {
-                    return Err(manage::enterprise());
-                }
-                // SPDX-SnippetEnd
 
                 let principals = self
                     .store()
@@ -445,16 +388,6 @@ impl PrincipalManager for Server {
                     .map(|p| (p.id, p.typ))
                     .ok_or_else(|| not_found(name.to_string()))?;
 
-                // SPDX-SnippetBegin
-                // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-                // SPDX-License-Identifier: LicenseRef-SEL
-
-                #[cfg(feature = "enterprise")]
-                if matches!(typ, Type::Tenant) && !self.core.is_enterprise_edition() {
-                    return Err(manage::enterprise());
-                }
-
-                // SPDX-SnippetEnd
 
                 match *method {
                     Method::GET => {
diff --git a/crates/http/src/management/queue.rs b/crates/http/src/management/queue.rs
index 3abeac15..12e24d20 100644
--- a/crates/http/src/management/queue.rs
+++ b/crates/http/src/management/queue.rs
@@ -138,33 +138,6 @@ impl QueueManagement for Server {
         let params = UrlParams::new(req.uri().query());
         let mut tenant_domains: Option<Vec<String>> = None;
 
-        // SPDX-SnippetBegin
-        // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-        // SPDX-License-Identifier: LicenseRef-SEL
-
-        // Limit to tenant domains
-        #[cfg(feature = "enterprise")]
-        if self.core.is_enterprise_edition()
-            && let Some(tenant) = access_token.tenant
-        {
-            tenant_domains = self
-                .core
-                .storage
-                .data
-                .list_principals(None, tenant.id.into(), &[Type::Domain], false, 0, 0)
-                .await
-                .map(|principals| {
-                    principals
-                        .items
-                        .into_iter()
-                        .map(|p| p.name)
-                        .collect::<Vec<_>>()
-                })
-                .caused_by(trc::location!())?
-                .into();
-        }
-
-        // SPDX-SnippetEnd
 
         match (
             path.get(1).copied().unwrap_or_default(),
diff --git a/crates/http/src/management/reload.rs b/crates/http/src/management/reload.rs
index 1763f32d..4b1a0d37 100644
--- a/crates/http/src/management/reload.rs
+++ b/crates/http/src/management/reload.rs
@@ -84,12 +84,6 @@ impl ManageReload for Server {
                     if let Some(tracers) = result.tracers {
                         // Update tracers
 
-                        // SPDX-SnippetBegin
-                        // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-                        // SPDX-License-Identifier: LicenseRef-SEL
-                        #[cfg(feature = "enterprise")]
-                        tracers.update(self.inner.shared_core.load().is_enterprise_edition());
-                        // SPDX-SnippetEnd
                         #[cfg(not(feature = "enterprise"))]
                         tracers.update(false);
                     }
diff --git a/crates/http/src/management/report.rs b/crates/http/src/management/report.rs
index cdaeeb2e..71c69106 100644
--- a/crates/http/src/management/report.rs
+++ b/crates/http/src/management/report.rs
@@ -47,33 +47,6 @@ impl ManageReports for Server {
         access_token: &AccessToken,
     ) -> trc::Result<HttpResponse> {
         let mut tenant_domains: Option<Vec<String>> = None;
-        // SPDX-SnippetBegin
-        // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-        // SPDX-License-Identifier: LicenseRef-SEL
-
-        // Limit to tenant domains
-        #[cfg(feature = "enterprise")]
-        if self.core.is_enterprise_edition()
-            && let Some(tenant) = access_token.tenant
-        {
-            tenant_domains = self
-                .core
-                .storage
-                .data
-                .list_principals(None, tenant.id.into(), &[Type::Domain], false, 0, 0)
-                .await
-                .map(|principals| {
-                    principals
-                        .items
-                        .into_iter()
-                        .map(|p| p.name)
-                        .collect::<Vec<_>>()
-                })
-                .caused_by(trc::location!())?
-                .into();
-        }
-
-        // SPDX-SnippetEnd
 
         match (
             path.get(1).copied().unwrap_or_default(),
diff --git a/crates/http/src/management/stores.rs b/crates/http/src/management/stores.rs
index 15b76478..9ce1f381 100644
--- a/crates/http/src/management/stores.rs
+++ b/crates/http/src/management/stores.rs
@@ -30,12 +30,6 @@ use store::{
 use trc::AddContext;
 use utils::url_params::UrlParams;
 
-// SPDX-SnippetBegin
-// SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-// SPDX-License-Identifier: LicenseRef-SEL
-#[cfg(feature = "enterprise")]
-use super::enterprise::undelete::UndeleteApi;
-// SPDX-SnippetEnd
 
 pub trait ManageStore: Sync + Send {
     fn handle_manage_store(
@@ -241,31 +235,6 @@ impl ManageStore for Server {
                 }))
                 .into_http_response())
             }
-            // SPDX-SnippetBegin
-            // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-            // SPDX-License-Identifier: LicenseRef-SEL
-            #[cfg(feature = "enterprise")]
-            (Some("undelete"), _, _, _) => {
-                // WARNING: TAMPERING WITH THIS FUNCTION IS STRICTLY PROHIBITED
-                // Any attempt to modify, bypass, or disable this license validation mechanism
-                // constitutes a severe violation of the Stalwart Enterprise License Agreement.
-                // Such actions may result in immediate termination of your license, legal action,
-                // and substantial financial penalties. Stalwart Labs LLC actively monitors for
-                // unauthorized modifications and will pursue all available legal remedies against
-                // violators to the fullest extent of the law, including but not limited to claims
-                // for copyright infringement, breach of contract, and fraud.
-
-                // Validate the access token
-                access_token.assert_has_permission(Permission::Undelete)?;
-
-                if self.core.is_enterprise_edition() {
-                    self.handle_undelete_api_request(req, path, body, session)
-                        .await
-                } else {
-                    Err(manage::enterprise())
-                }
-            }
-            // SPDX-SnippetEnd
             (Some("uids"), Some(account_id), None, &Method::DELETE) => {
                 let account_id = self
                     .core
diff --git a/crates/http/src/request.rs b/crates/http/src/request.rs
index 3ccd9a5c..c883e059 100644
--- a/crates/http/src/request.rs
+++ b/crates/http/src/request.rs
@@ -408,22 +408,6 @@ impl ParseHttp for Server {
                                 path.get(1).copied(),
                                 params.get("token"),
                             ) {
-                                // SPDX-SnippetBegin
-                                // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-                                // SPDX-License-Identifier: LicenseRef-SEL
-                                #[cfg(feature = "enterprise")]
-                                (Some("telemetry"), Some("traces"), Some(token))
-                                    if self.core.is_enterprise_edition() =>
-                                {
-                                    (GrantType::LiveTracing, token)
-                                }
-                                #[cfg(feature = "enterprise")]
-                                (Some("telemetry"), Some("metrics"), Some(token))
-                                    if self.core.is_enterprise_edition() =>
-                                {
-                                    (GrantType::LiveMetrics, token)
-                                }
-                                // SPDX-SnippetEnd
                                 (Some("troubleshoot"), _, Some(token)) => {
                                     (GrantType::Troubleshoot, token)
                                 }
@@ -433,22 +417,6 @@ impl ParseHttp for Server {
                                 self.validate_access_token(grant_type.into(), token).await?;
 
                             return match grant_type {
-                                // SPDX-SnippetBegin
-                                // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-                                // SPDX-License-Identifier: LicenseRef-SEL
-                                #[cfg(feature = "enterprise")]
-                                GrantType::LiveTracing | GrantType::LiveMetrics => {
-                                    use crate::management::enterprise::telemetry::TelemetryApi;
-                                    self.handle_telemetry_api_request(
-                                        &req,
-                                        path,
-                                        &AccessToken::from_id(token_info.account_id)
-                                            .with_permission(Permission::MetricsLive)
-                                            .with_permission(Permission::TracingLive),
-                                    )
-                                    .await
-                                }
-                                // SPDX-SnippetEnd
                                 GrantType::Troubleshoot => {
                                     self.handle_troubleshoot_api_request(
                                         &req,
@@ -580,37 +548,6 @@ impl ParseHttp for Server {
                 }
                 _ => (),
             },
-            // SPDX-SnippetBegin
-            // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-            // SPDX-License-Identifier: LicenseRef-SEL
-            #[cfg(feature = "enterprise")]
-            "logo.svg" if self.is_enterprise_edition() => {
-                match self
-                    .logo_resource(
-                        req.headers()
-                            .get(header::HOST)
-                            .and_then(|h| h.to_str().ok())
-                            .map(|h| h.rsplit_once(':').map_or(h, |(h, _)| h))
-                            .unwrap_or_default(),
-                    )
-                    .await
-                {
-                    Ok(Some(resource)) => {
-                        return Ok(resource.into_http_response());
-                    }
-                    Ok(None) => (),
-                    Err(err) => {
-                        trc::error!(err.span_id(session.session_id));
-                    }
-                }
-
-                let resource = self.inner.data.webadmin.get("logo.svg").await?;
-
-                if !resource.is_empty() {
-                    return Ok(resource.into_http_response());
-                }
-            }
-            // SPDX-SnippetEnd
             "form" => {
                 if let Some(form) = &self.core.network.contact_form {
                     match *req.method() {
diff --git a/crates/main/src/main.rs b/crates/main/src/main.rs
index 7b8ec878..9be0947b 100644
--- a/crates/main/src/main.rs
+++ b/crates/main/src/main.rs
@@ -50,13 +50,6 @@ async fn main() -> std::io::Result<()> {
     init.config.log_errors();
     init.config.log_warnings();
 
-    // SPDX-SnippetBegin
-    // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-    // SPDX-License-Identifier: LicenseRef-SEL
-    // Log licensing information
-    #[cfg(feature = "enterprise")]
-    init.inner.build_server().log_license_details();
-    // SPDX-SnippetEnd
 
     // Spawn servers
     let (shutdown_tx, shutdown_rx) = init.servers.spawn(|server, acceptor, shutdown_rx| {
diff --git a/crates/services/src/housekeeper/mod.rs b/crates/services/src/housekeeper/mod.rs
index fec0a1ac..993643ec 100644
--- a/crates/services/src/housekeeper/mod.rs
+++ b/crates/services/src/housekeeper/mod.rs
@@ -22,15 +22,6 @@ use store::{PurgeStore, write::now};
 use tokio::sync::mpsc;
 use trc::{Collector, MetricType, PurgeEvent};
 
-// SPDX-SnippetBegin
-// SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-// SPDX-License-Identifier: LicenseRef-SEL
-#[cfg(feature = "enterprise")]
-use common::telemetry::{
-    metrics::store::{MetricsStore, SharedMetricHistory},
-    tracers::store::TracingStore,
-};
-// SPDX-SnippetEnd
 
 #[derive(PartialEq, Eq)]
 struct Action {
@@ -45,16 +36,6 @@ enum ActionClass {
     Acme(String),
     OtelMetrics,
     CalculateMetrics,
-    // SPDX-SnippetBegin
-    // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-    // SPDX-License-Identifier: LicenseRef-SEL
-    #[cfg(feature = "enterprise")]
-    InternalMetrics,
-    #[cfg(feature = "enterprise")]
-    AlertMetrics,
-    #[cfg(feature = "enterprise")]
-    RenewLicense,
-    // SPDX-SnippetEnd
 }
 
 #[derive(Default)]
@@ -62,12 +43,6 @@ struct Queue {
     heap: BinaryHeap<Action>,
 }
 
-// SPDX-SnippetBegin
-// SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-// SPDX-License-Identifier: LicenseRef-SEL
-#[cfg(feature = "enterprise")]
-const METRIC_ALERTS_INTERVAL: Duration = Duration::from_secs(5 * 60);
-// SPDX-SnippetEnd
 
 pub fn spawn_housekeeper(inner: Arc<Inner>, mut rx: mpsc::Receiver<HousekeeperEvent>) {
     tokio::spawn(async move {
@@ -127,43 +102,8 @@ pub fn spawn_housekeeper(inner: Arc<Inner>, mut rx: mpsc::Receiver<HousekeeperEv
                 }
             }
 
-            // SPDX-SnippetBegin
-            // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-            // SPDX-License-Identifier: LicenseRef-SEL
-
-            // Enterprise Edition license management
-            #[cfg(feature = "enterprise")]
-            if let Some(enterprise) = &server.core.enterprise {
-                queue.schedule(
-                    Instant::now() + enterprise.license.renew_in(),
-                    ActionClass::RenewLicense,
-                );
-
-                if let Some(metrics_store) = enterprise.metrics_store.as_ref() {
-                    queue.schedule(
-                        Instant::now() + metrics_store.interval.time_to_next(),
-                        ActionClass::InternalMetrics,
-                    );
-                }
-
-                if !enterprise.metrics_alerts.is_empty() {
-                    queue.schedule(
-                        Instant::now() + METRIC_ALERTS_INTERVAL,
-                        ActionClass::AlertMetrics,
-                    );
-                }
-            }
-
-            // SPDX-SnippetEnd
         }
 
-        // SPDX-SnippetBegin
-        // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-        // SPDX-License-Identifier: LicenseRef-SEL
-        // Metrics history
-        #[cfg(feature = "enterprise")]
-        let metrics_history = SharedMetricHistory::default();
-        // SPDX-SnippetEnd
 
         let mut next_metric_update = Instant::now();
 
@@ -187,34 +127,6 @@ pub fn spawn_housekeeper(inner: Arc<Inner>, mut rx: mpsc::Receiver<HousekeeperEv
                                 _ => {}
                             }
 
-                            // SPDX-SnippetBegin
-                            // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-                            // SPDX-License-Identifier: LicenseRef-SEL
-                            #[cfg(feature = "enterprise")]
-                            if let Some(enterprise) = &server.core.enterprise {
-                                if !queue.has_action(&ActionClass::RenewLicense) {
-                                    queue.schedule(
-                                        Instant::now() + enterprise.license.renew_in(),
-                                        ActionClass::RenewLicense,
-                                    );
-                                }
-
-                                if let Some(metrics_store) = enterprise.metrics_store.as_ref()
-                                    && !queue.has_action(&ActionClass::InternalMetrics)
-                                {
-                                    queue.schedule(
-                                        Instant::now() + metrics_store.interval.time_to_next(),
-                                        ActionClass::InternalMetrics,
-                                    );
-                                }
-
-                                if !enterprise.metrics_alerts.is_empty()
-                                    && !queue.has_action(&ActionClass::AlertMetrics)
-                                {
-                                    queue.schedule(Instant::now(), ActionClass::AlertMetrics);
-                                }
-                            }
-                            // SPDX-SnippetEnd
 
                             // Reload queue settings
                             server
@@ -399,12 +311,6 @@ pub fn spawn_housekeeper(inner: Arc<Inner>, mut rx: mpsc::Receiver<HousekeeperEv
 
                                     let otel = otel.clone();
 
-                                    // SPDX-SnippetBegin
-                                    // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-                                    // SPDX-License-Identifier: LicenseRef-SEL
-                                    #[cfg(feature = "enterprise")]
-                                    let is_enterprise = server.is_enterprise_edition();
-                                    // SPDX-SnippetEnd
 
                                     #[cfg(not(feature = "enterprise"))]
                                     let is_enterprise = false;
@@ -437,27 +343,6 @@ pub fn spawn_housekeeper(inner: Arc<Inner>, mut rx: mpsc::Receiver<HousekeeperEv
                                 let server = server.clone();
                                 tokio::spawn(async move {
                                     if server.core.network.roles.calculate_metrics {
-                                        // SPDX-SnippetBegin
-                                        // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-                                        // SPDX-License-Identifier: LicenseRef-SEL
-                                        #[cfg(feature = "enterprise")]
-                                        if server.is_enterprise_edition() {
-                                            // Obtain queue size
-                                            match server.total_queued_messages().await {
-                                                Ok(total) => {
-                                                    Collector::update_gauge(
-                                                        MetricType::QueueCount,
-                                                        total,
-                                                    );
-                                                }
-                                                Err(err) => {
-                                                    trc::error!(
-                                                        err.details("Failed to obtain queue size")
-                                                    );
-                                                }
-                                            }
-                                        }
-                                        // SPDX-SnippetEnd
 
                                         if update_other_metrics {
                                             match server.total_accounts().await {
@@ -518,112 +403,6 @@ pub fn spawn_housekeeper(inner: Arc<Inner>, mut rx: mpsc::Receiver<HousekeeperEv
                                 });
                             }
 
-                            // SPDX-SnippetBegin
-                            // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-                            // SPDX-License-Identifier: LicenseRef-SEL
-                            #[cfg(feature = "enterprise")]
-                            ActionClass::InternalMetrics => {
-                                if let Some(metrics_store) = &server
-                                    .core
-                                    .enterprise
-                                    .as_ref()
-                                    .and_then(|e| e.metrics_store.as_ref())
-                                {
-                                    trc::event!(
-                                        Housekeeper(trc::HousekeeperEvent::Run),
-                                        Type = "metrics_internal"
-                                    );
-
-                                    queue.schedule(
-                                        Instant::now() + metrics_store.interval.time_to_next(),
-                                        ActionClass::InternalMetrics,
-                                    );
-
-                                    let metrics_store = metrics_store.store.clone();
-                                    let metrics_history = metrics_history.clone();
-                                    let core = server.core.clone();
-                                    tokio::spawn(async move {
-                                        if let Err(err) = metrics_store
-                                            .write_metrics(core, now(), metrics_history)
-                                            .await
-                                        {
-                                            trc::error!(err.details("Failed to write metrics"));
-                                        }
-                                    });
-                                }
-                            }
-
-                            #[cfg(feature = "enterprise")]
-                            ActionClass::AlertMetrics => {
-                                trc::event!(
-                                    Housekeeper(trc::HousekeeperEvent::Run),
-                                    Type = "metrics_alert"
-                                );
-
-                                let server = server.clone();
-
-                                tokio::spawn(async move {
-                                    if let Some(messages) = server.process_alerts().await {
-                                        for message in messages {
-                                            server
-                                                .send_autogenerated(
-                                                    message.from,
-                                                    message.to.into_iter(),
-                                                    message.body,
-                                                    None,
-                                                    0,
-                                                )
-                                                .await;
-                                        }
-                                    }
-                                });
-                            }
-
-                            #[cfg(feature = "enterprise")]
-                            ActionClass::RenewLicense => {
-                                trc::event!(
-                                    Housekeeper(trc::HousekeeperEvent::Run),
-                                    Type = "renew_license"
-                                );
-
-                                match server.reload().await {
-                                    Ok(result) => {
-                                        if let Some(new_core) = result.new_core {
-                                            if let Some(enterprise) = &new_core.enterprise {
-                                                let renew_in =
-                                                    if enterprise.license.is_near_expiration() {
-                                                        // Something went wrong during renewal, try again in 1 day or 1 hour,
-                                                        // depending on the time left on the license
-                                                        if enterprise.license.expires_in()
-                                                            < Duration::from_secs(86400)
-                                                        {
-                                                            Duration::from_secs(3600)
-                                                        } else {
-                                                            Duration::from_secs(86400)
-                                                        }
-                                                    } else {
-                                                        enterprise.license.renew_in()
-                                                    };
-
-                                                queue.schedule(
-                                                    Instant::now() + renew_in,
-                                                    ActionClass::RenewLicense,
-                                                );
-                                            }
-
-                                            // Update core
-                                            server.inner.shared_core.store(new_core.into());
-
-                                            server
-                                                .cluster_broadcast(BroadcastEvent::ReloadSettings)
-                                                .await;
-                                        }
-                                    }
-                                    Err(err) => {
-                                        trc::error!(err.details("Failed to reload configuration."));
-                                    }
-                                }
-                            } // SPDX-SnippetEnd
                         }
                     }
                 }
@@ -692,46 +471,11 @@ impl Purge for Server {
 
         match purge {
             PurgeType::Data(store) => {
-                // SPDX-SnippetBegin
-                // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-                // SPDX-License-Identifier: LicenseRef-SEL
-                #[cfg(feature = "enterprise")]
-                let trace_retention = self
-                    .core
-                    .enterprise
-                    .as_ref()
-                    .and_then(|e| e.trace_store.as_ref())
-                    .and_then(|t| t.retention);
-                #[cfg(feature = "enterprise")]
-                let metrics_retention = self
-                    .core
-                    .enterprise
-                    .as_ref()
-                    .and_then(|e| e.metrics_store.as_ref())
-                    .and_then(|m| m.retention);
-                // SPDX-SnippetEnd
 
                 if let Err(err) = store.purge_store().await {
                     trc::error!(err.details("Failed to purge data store"));
                 }
 
-                // SPDX-SnippetBegin
-                // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-                // SPDX-License-Identifier: LicenseRef-SEL
-                #[cfg(feature = "enterprise")]
-                if let Some(trace_retention) = trace_retention
-                    && let Err(err) = store.purge_spans(trace_retention).await
-                {
-                    trc::error!(err.details("Failed to purge tracing spans"));
-                }
-
-                #[cfg(feature = "enterprise")]
-                if let Some(metrics_retention) = metrics_retention
-                    && let Err(err) = store.purge_metrics(metrics_retention).await
-                {
-                    trc::error!(err.details("Failed to purge metrics"));
-                }
-                // SPDX-SnippetEnd
             }
             PurgeType::Blobs { store, blob_store } => {
                 if let Err(err) = store.purge_blobs(blob_store).await {
diff --git a/crates/services/src/task_manager/alarm.rs b/crates/services/src/task_manager/alarm.rs
index d9327dd8..effe202e 100644
--- a/crates/services/src/task_manager/alarm.rs
+++ b/crates/services/src/task_manager/alarm.rs
@@ -431,17 +431,6 @@ async fn build_template(
         access_token.emails.first().unwrap().to_string()
     };
 
-    // SPDX-SnippetBegin
-    // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-    // SPDX-License-Identifier: LicenseRef-SEL
-    #[cfg(feature = "enterprise")]
-    let template = server
-        .core
-        .enterprise
-        .as_ref()
-        .and_then(|e| e.template_calendar_alarm.as_ref())
-        .unwrap_or(&server.core.groupware.alarms_template);
-    // SPDX-SnippetEnd
 
     #[cfg(not(feature = "enterprise"))]
     let template = &server.core.groupware.alarms_template;
diff --git a/crates/services/src/task_manager/imip.rs b/crates/services/src/task_manager/imip.rs
index 98a6642d..85f96b12 100644
--- a/crates/services/src/task_manager/imip.rs
+++ b/crates/services/src/task_manager/imip.rs
@@ -310,17 +310,6 @@ pub async fn build_itip_template(
     summary: &ArchivedItipSummary,
     logo_cid: &str,
 ) -> Details {
-    // SPDX-SnippetBegin
-    // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-    // SPDX-License-Identifier: LicenseRef-SEL
-    #[cfg(feature = "enterprise")]
-    let template = server
-        .core
-        .enterprise
-        .as_ref()
-        .and_then(|e| e.template_scheduling_email.as_ref())
-        .unwrap_or(&server.core.groupware.itip_template);
-    // SPDX-SnippetEnd
     #[cfg(not(feature = "enterprise"))]
     let template = &server.core.groupware.itip_template;
     let locale = i18n::locale_or_default(access_token.locale.as_deref().unwrap_or("en"));
diff --git a/crates/spam-filter/src/analysis/llm.rs b/crates/spam-filter/src/analysis/llm.rs
deleted file mode 100644
index fc3f40fd..00000000
--- a/crates/spam-filter/src/analysis/llm.rs
+++ /dev/null
@@ -1,115 +0,0 @@
-/*
- * SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
- *
- * SPDX-License-Identifier: LicenseRef-SEL
- */
-
-use std::{future::Future, time::Instant};
-
-use common::Server;
-use trc::AiEvent;
-
-use crate::SpamFilterContext;
-
-pub trait SpamFilterAnalyzeLlm: Sync + Send {
-    fn spam_filter_analyze_llm(
-        &self,
-        ctx: &mut SpamFilterContext<'_>,
-    ) -> impl Future<Output = ()> + Send;
-}
-
-impl SpamFilterAnalyzeLlm for Server {
-    async fn spam_filter_analyze_llm(&self, ctx: &mut SpamFilterContext<'_>) {
-        if let Some(config) = self
-            .core
-            .enterprise
-            .as_ref()
-            .and_then(|c| c.spam_filter_llm.as_ref())
-        {
-            let time = Instant::now();
-            let body = if let Some(body) = ctx.text_body() {
-                body
-            } else {
-                return;
-            };
-            let prompt = format!(
-                "{}\n\nSubject: {}\n\n{}",
-                config.prompt, ctx.output.subject, body
-            );
-
-            match config
-                .model
-                .send_request(prompt, config.temperature.into())
-                .await
-            {
-                Ok(response) => {
-                    trc::event!(
-                        Ai(AiEvent::LlmResponse),
-                        Id = config.model.id.clone(),
-                        Details = response.clone(),
-                        Elapsed = time.elapsed(),
-                        SpanId = ctx.input.span_id,
-                    );
-
-                    let mut category = None;
-                    let mut confidence = None;
-                    let mut explanation = None;
-
-                    for (idx, value) in response.split(config.separator).enumerate() {
-                        let value = value.trim();
-                        if !value.is_empty() {
-                            if idx == config.index_category {
-                                let value = value.to_uppercase();
-                                if config.categories.contains(value.as_str()) {
-                                    category = Some(value);
-                                }
-                            } else if config.index_confidence.is_some_and(|i| i == idx) {
-                                let value = value.to_uppercase();
-                                if config.confidence.contains(value.as_str()) {
-                                    confidence = Some(value);
-                                }
-                            } else if config.index_explanation.is_some_and(|i| i == idx) {
-                                let explanation = explanation.get_or_insert_with(|| {
-                                    String::with_capacity(std::cmp::min(value.len(), 255))
-                                });
-
-                                for value in value.chars() {
-                                    if !value.is_whitespace() {
-                                        explanation.push(value);
-                                    } else {
-                                        explanation.push(' ');
-                                    }
-                                    if explanation.len() == 255 {
-                                        break;
-                                    }
-                                }
-                            }
-                        }
-                    }
-
-                    let category = match (category, confidence) {
-                        (Some(category), Some(confidence)) => {
-                            ctx.result.add_tag(format!("LLM_{category}_{confidence}"));
-                            category
-                        }
-                        (Some(category), None) => {
-                            ctx.result.add_tag(format!("LLM_{category}"));
-                            category
-                        }
-                        _ => return,
-                    };
-
-                    if let (Some(header), Some(explanation)) =
-                        (&self.core.spam.headers.llm, explanation)
-                    {
-                        ctx.result.header =
-                            format!("{header}: {category} ({explanation})\r\n",).into();
-                    }
-                }
-                Err(err) => {
-                    trc::error!(err.span_id(ctx.input.span_id));
-                }
-            }
-        }
-    }
-}
diff --git a/crates/spam-filter/src/analysis/mod.rs b/crates/spam-filter/src/analysis/mod.rs
index abde7882..8763ca67 100644
--- a/crates/spam-filter/src/analysis/mod.rs
+++ b/crates/spam-filter/src/analysis/mod.rs
@@ -40,12 +40,6 @@ pub mod subject;
 pub mod trusted_reply;
 pub mod url;
 
-// SPDX-SnippetBegin
-// SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-// SPDX-License-Identifier: LicenseRef-SEL
-#[cfg(feature = "enterprise")]
-pub mod llm;
-// SPDX-SnippetEnd
 
 impl SpamFilterInput<'_> {
     pub fn header_as_address(&self, header: &Header<'_>) -> Option<Cow<'_, str>> {
diff --git a/crates/spam-filter/src/analysis/score.rs b/crates/spam-filter/src/analysis/score.rs
index b14e6841..3978ed13 100644
--- a/crates/spam-filter/src/analysis/score.rs
+++ b/crates/spam-filter/src/analysis/score.rs
@@ -22,12 +22,6 @@ use crate::{
 use common::{Server, config::spamfilter::SpamFilterAction};
 use std::{fmt::Write, future::Future, vec};
 
-// SPDX-SnippetBegin
-// SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-// SPDX-License-Identifier: LicenseRef-SEL
-#[cfg(feature = "enterprise")]
-use crate::analysis::llm::SpamFilterAnalyzeLlm;
-// SPDX-SnippetEnd
 
 pub trait SpamFilterAnalyzeScore: Sync + Send {
     fn spam_filter_score(
@@ -193,15 +187,6 @@ impl SpamFilterAnalyzeScore for Server {
         // HTML content analysis
         self.spam_filter_analyze_html(ctx).await;
 
-        // SPDX-SnippetBegin
-        // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-        // SPDX-License-Identifier: LicenseRef-SEL
-
-        // LLM classification
-        #[cfg(feature = "enterprise")]
-        self.spam_filter_analyze_llm(ctx).await;
-
-        // SPDX-SnippetEnd
 
         // Trusted reply analysis
         self.spam_filter_analyze_reply_in(ctx).await;
diff --git a/crates/store/src/backend/composite/mod.rs b/crates/store/src/backend/composite/mod.rs
deleted file mode 100644
index 25bb2109..00000000
--- a/crates/store/src/backend/composite/mod.rs
+++ /dev/null
@@ -1,14 +0,0 @@
-/*
- * SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
- *
- * SPDX-License-Identifier: LicenseRef-SEL
- *
- * This file is subject to the Stalwart Enterprise License Agreement (SEL) and
- * is NOT open source software.
- *
- */
-
-#[cfg(any(feature = "postgres", feature = "mysql"))]
-pub mod read_replica;
-pub mod sharded_blob;
-pub mod sharded_lookup;
diff --git a/crates/store/src/backend/composite/read_replica.rs b/crates/store/src/backend/composite/read_replica.rs
deleted file mode 100644
index e1f59694..00000000
--- a/crates/store/src/backend/composite/read_replica.rs
+++ /dev/null
@@ -1,293 +0,0 @@
-/*
- * SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
- *
- * SPDX-License-Identifier: LicenseRef-SEL
- *
- * This file is subject to the Stalwart Enterprise License Agreement (SEL) and
- * is NOT open source software.
- *
- */
-
-use std::{
-    future::Future,
-    ops::Range,
-    sync::atomic::{AtomicUsize, Ordering},
-};
-
-use roaring::RoaringBitmap;
-use utils::config::{Config, utils::AsKey};
-
-use crate::{
-    BitmapKey, Deserialize, IterateParams, Key, Store, Stores, ValueKey,
-    write::{AssignedIds, Batch, BitmapClass, ValueClass},
-};
-
-pub struct SQLReadReplica {
-    primary: Store,
-    replicas: Vec<Store>,
-    last_used_replica: AtomicUsize,
-}
-
-impl SQLReadReplica {
-    pub async fn open(
-        config: &mut Config,
-        prefix: impl AsKey,
-        stores: &Stores,
-        create_tables: bool,
-    ) -> Option<Self> {
-        let prefix = prefix.as_key();
-        let primary_id = config.value_require((&prefix, "primary"))?.to_string();
-        let replica_ids = config
-            .values((&prefix, "replicas"))
-            .map(|(_, v)| v.to_string())
-            .collect::<Vec<_>>();
-
-        let primary = if let Some(store) = stores.stores.get(&primary_id) {
-            if store.is_pg_or_mysql() {
-                store.clone()
-            } else {
-                config.new_build_error(
-                    (&prefix, "primary"),
-                    "Primary store must be a PostgreSQL or MySQL store",
-                );
-                return None;
-            }
-        } else {
-            config.new_build_error(
-                (&prefix, "primary"),
-                format!("Primary store {primary_id} not found"),
-            );
-            return None;
-        };
-        let mut replicas = Vec::with_capacity(replica_ids.len());
-        for replica_id in replica_ids {
-            if let Some(store) = stores.stores.get(&replica_id) {
-                if store.is_pg_or_mysql() {
-                    replicas.push(store.clone());
-                } else {
-                    config.new_build_error(
-                        (&prefix, "replicas"),
-                        "Replica store must be a PostgreSQL or MySQL store",
-                    );
-                    return None;
-                }
-            } else {
-                config.new_build_error(
-                    (&prefix, "replicas"),
-                    format!("Replica store {replica_id} not found"),
-                );
-                return None;
-            }
-        }
-        if !replicas.is_empty() {
-            if create_tables {
-                let result = match &primary {
-                    #[cfg(feature = "postgres")]
-                    Store::PostgreSQL(store) => store.create_tables().await,
-                    #[cfg(feature = "mysql")]
-                    Store::MySQL(store) => store.create_tables().await,
-                    _ => panic!("Invalid store type"),
-                };
-
-                if let Err(err) = result {
-                    config.new_build_error(
-                        (&prefix, "primary"),
-                        format!("Failed to create tables: {err}"),
-                    );
-                }
-            }
-
-            Some(Self {
-                primary,
-                replicas,
-                last_used_replica: AtomicUsize::new(0),
-            })
-        } else {
-            config.new_build_error((&prefix, "replicas"), "No replica stores specified");
-            None
-        }
-    }
-
-    async fn run_op<'x, F, T, R>(&'x self, f: F) -> trc::Result<T>
-    where
-        F: Fn(&'x Store) -> R,
-        R: Future<Output = trc::Result<T>>,
-        T: 'static,
-    {
-        let mut last_error = None;
-        for store in [
-            &self.replicas
-                [self.last_used_replica.fetch_add(1, Ordering::Relaxed) % self.replicas.len()],
-            &self.primary,
-        ] {
-            match f(store).await {
-                Ok(result) => return Ok(result),
-                Err(err) => {
-                    if err.is_assertion_failure() {
-                        return Err(err);
-                    } else {
-                        last_error = Some(err);
-                    }
-                }
-            }
-        }
-
-        Err(last_error.unwrap())
-    }
-
-    pub async fn get_blob(&self, key: &[u8], range: Range<usize>) -> trc::Result<Option<Vec<u8>>> {
-        self.run_op(move |store| {
-            let range = range.clone();
-
-            async move {
-                match store {
-                    #[cfg(feature = "postgres")]
-                    Store::PostgreSQL(store) => store.get_blob(key, range).await,
-                    #[cfg(feature = "mysql")]
-                    Store::MySQL(store) => store.get_blob(key, range).await,
-                    _ => panic!("Invalid store type"),
-                }
-            }
-        })
-        .await
-    }
-
-    pub async fn put_blob(&self, key: &[u8], data: &[u8]) -> trc::Result<()> {
-        match &self.primary {
-            #[cfg(feature = "postgres")]
-            Store::PostgreSQL(store) => store.put_blob(key, data).await,
-            #[cfg(feature = "mysql")]
-            Store::MySQL(store) => store.put_blob(key, data).await,
-            _ => panic!("Invalid store type"),
-        }
-    }
-
-    pub async fn delete_blob(&self, key: &[u8]) -> trc::Result<bool> {
-        match &self.primary {
-            #[cfg(feature = "postgres")]
-            Store::PostgreSQL(store) => store.delete_blob(key).await,
-            #[cfg(feature = "mysql")]
-            Store::MySQL(store) => store.delete_blob(key).await,
-            _ => panic!("Invalid store type"),
-        }
-    }
-
-    pub async fn get_value<U>(&self, key: impl Key) -> trc::Result<Option<U>>
-    where
-        U: Deserialize + 'static,
-    {
-        self.run_op(move |store| {
-            let key = key.clone();
-
-            async move {
-                match store {
-                    #[cfg(feature = "postgres")]
-                    Store::PostgreSQL(store) => store.get_value(key).await,
-                    #[cfg(feature = "mysql")]
-                    Store::MySQL(store) => store.get_value(key).await,
-                    _ => panic!("Invalid store type"),
-                }
-            }
-        })
-        .await
-    }
-
-    pub async fn get_bitmap(
-        &self,
-        key: BitmapKey<BitmapClass>,
-    ) -> trc::Result<Option<RoaringBitmap>> {
-        self.run_op(move |store| {
-            let key = key.clone();
-
-            async move {
-                match store {
-                    #[cfg(feature = "postgres")]
-                    Store::PostgreSQL(store) => store.get_bitmap(key).await,
-                    #[cfg(feature = "mysql")]
-                    Store::MySQL(store) => store.get_bitmap(key).await,
-                    _ => panic!("Invalid store type"),
-                }
-            }
-        })
-        .await
-    }
-
-    pub async fn iterate<T: Key>(
-        &self,
-        params: IterateParams<T>,
-        mut cb: impl for<'x> FnMut(&'x [u8], &'x [u8]) -> trc::Result<bool> + Sync + Send,
-    ) -> trc::Result<()> {
-        let mut last_error = None;
-        for store in [
-            &self.replicas
-                [self.last_used_replica.fetch_add(1, Ordering::Relaxed) % self.replicas.len()],
-            &self.primary,
-        ] {
-            match match store {
-                #[cfg(feature = "postgres")]
-                Store::PostgreSQL(store) => store.iterate(params.clone(), &mut cb).await,
-                #[cfg(feature = "mysql")]
-                Store::MySQL(store) => store.iterate(params.clone(), &mut cb).await,
-                _ => panic!("Invalid store type"),
-            } {
-                Ok(result) => return Ok(result),
-                Err(err) => {
-                    last_error = Some(err);
-                }
-            }
-        }
-
-        Err(last_error.unwrap())
-    }
-
-    pub async fn get_counter(
-        &self,
-        key: impl Into<ValueKey<ValueClass>> + Sync + Send,
-    ) -> trc::Result<i64> {
-        let key = key.into();
-        self.run_op(move |store| {
-            let key = key.clone();
-
-            async move {
-                match store {
-                    #[cfg(feature = "postgres")]
-                    Store::PostgreSQL(store) => store.get_counter(key).await,
-                    #[cfg(feature = "mysql")]
-                    Store::MySQL(store) => store.get_counter(key).await,
-                    _ => panic!("Invalid store type"),
-                }
-            }
-        })
-        .await
-    }
-
-    pub async fn write(&self, batch: Batch<'_>) -> trc::Result<AssignedIds> {
-        match &self.primary {
-            #[cfg(feature = "postgres")]
-            Store::PostgreSQL(store) => store.write(batch).await,
-            #[cfg(feature = "mysql")]
-            Store::MySQL(store) => store.write(batch).await,
-            _ => panic!("Invalid store type"),
-        }
-    }
-
-    pub async fn delete_range(&self, from: impl Key, to: impl Key) -> trc::Result<()> {
-        match &self.primary {
-            #[cfg(feature = "postgres")]
-            Store::PostgreSQL(store) => store.delete_range(from, to).await,
-            #[cfg(feature = "mysql")]
-            Store::MySQL(store) => store.delete_range(from, to).await,
-            _ => panic!("Invalid store type"),
-        }
-    }
-
-    pub async fn purge_store(&self) -> trc::Result<()> {
-        match &self.primary {
-            #[cfg(feature = "postgres")]
-            Store::PostgreSQL(store) => store.purge_store().await,
-            #[cfg(feature = "mysql")]
-            Store::MySQL(store) => store.purge_store().await,
-            _ => panic!("Invalid store type"),
-        }
-    }
-}
diff --git a/crates/store/src/backend/composite/sharded_blob.rs b/crates/store/src/backend/composite/sharded_blob.rs
deleted file mode 100644
index 99f20114..00000000
--- a/crates/store/src/backend/composite/sharded_blob.rs
+++ /dev/null
@@ -1,167 +0,0 @@
-/*
- * SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
- *
- * SPDX-License-Identifier: LicenseRef-SEL
- *
- * This file is subject to the Stalwart Enterprise License Agreement (SEL) and
- * is NOT open source software.
- *
- */
-
-use std::ops::Range;
-
-use utils::config::{Config, utils::AsKey};
-
-use crate::{BlobBackend, Store, Stores};
-
-pub struct ShardedBlob {
-    pub stores: Vec<BlobBackend>,
-}
-
-impl ShardedBlob {
-    pub fn open(config: &mut Config, prefix: impl AsKey, stores: &Stores) -> Option<Self> {
-        let prefix = prefix.as_key();
-        let store_ids = config
-            .values((&prefix, "stores"))
-            .map(|(_, v)| v.to_string())
-            .collect::<Vec<_>>();
-
-        let mut blob_stores = Vec::with_capacity(store_ids.len());
-        for store_id in store_ids {
-            if let Some(store) = stores.blob_stores.get(&store_id) {
-                blob_stores.push(store.backend.clone());
-            } else {
-                config.new_build_error(
-                    (&prefix, "stores"),
-                    format!("Blob store {store_id} not found"),
-                );
-                return None;
-            }
-        }
-        if !blob_stores.is_empty() {
-            Some(Self {
-                stores: blob_stores,
-            })
-        } else {
-            config.new_build_error((&prefix, "stores"), "No blob stores specified");
-            None
-        }
-    }
-
-    #[inline(always)]
-    fn get_store(&self, key: &[u8]) -> &BlobBackend {
-        &self.stores[xxhash_rust::xxh3::xxh3_64(key) as usize % self.stores.len()]
-    }
-
-    pub async fn get_blob(
-        &self,
-        key: &[u8],
-        read_range: Range<usize>,
-    ) -> trc::Result<Option<Vec<u8>>> {
-        Box::pin(async move {
-            match self.get_store(key) {
-                BlobBackend::Store(store) => match store {
-                    #[cfg(feature = "sqlite")]
-                    Store::SQLite(store) => store.get_blob(key, read_range).await,
-                    #[cfg(feature = "foundation")]
-                    Store::FoundationDb(store) => store.get_blob(key, read_range).await,
-                    #[cfg(feature = "postgres")]
-                    Store::PostgreSQL(store) => store.get_blob(key, read_range).await,
-                    #[cfg(feature = "mysql")]
-                    Store::MySQL(store) => store.get_blob(key, read_range).await,
-                    #[cfg(feature = "rocks")]
-                    Store::RocksDb(store) => store.get_blob(key, read_range).await,
-                    // SPDX-SnippetBegin
-                    // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-                    // SPDX-License-Identifier: LicenseRef-SEL
-                    #[cfg(all(
-                        feature = "enterprise",
-                        any(feature = "postgres", feature = "mysql")
-                    ))]
-                    Store::SQLReadReplica(store) => store.get_blob(key, read_range).await,
-                    // SPDX-SnippetEnd
-                    Store::None => Err(trc::StoreEvent::NotConfigured.into()),
-                },
-                BlobBackend::Fs(store) => store.get_blob(key, read_range).await,
-                #[cfg(feature = "s3")]
-                BlobBackend::S3(store) => store.get_blob(key, read_range).await,
-                #[cfg(feature = "azure")]
-                BlobBackend::Azure(store) => store.get_blob(key, read_range).await,
-                BlobBackend::Sharded(_) => unimplemented!(),
-            }
-        })
-        .await
-    }
-
-    pub async fn put_blob(&self, key: &[u8], data: &[u8]) -> trc::Result<()> {
-        Box::pin(async move {
-            match self.get_store(key) {
-                BlobBackend::Store(store) => match store {
-                    #[cfg(feature = "sqlite")]
-                    Store::SQLite(store) => store.put_blob(key, data).await,
-                    #[cfg(feature = "foundation")]
-                    Store::FoundationDb(store) => store.put_blob(key, data).await,
-                    #[cfg(feature = "postgres")]
-                    Store::PostgreSQL(store) => store.put_blob(key, data).await,
-                    #[cfg(feature = "mysql")]
-                    Store::MySQL(store) => store.put_blob(key, data).await,
-                    #[cfg(feature = "rocks")]
-                    Store::RocksDb(store) => store.put_blob(key, data).await,
-                    // SPDX-SnippetBegin
-                    // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-                    // SPDX-License-Identifier: LicenseRef-SEL
-                    #[cfg(all(
-                        feature = "enterprise",
-                        any(feature = "postgres", feature = "mysql")
-                    ))]
-                    // SPDX-SnippetEnd
-                    Store::SQLReadReplica(store) => store.put_blob(key, data).await,
-                    Store::None => Err(trc::StoreEvent::NotConfigured.into()),
-                },
-                BlobBackend::Fs(store) => store.put_blob(key, data).await,
-                #[cfg(feature = "s3")]
-                BlobBackend::S3(store) => store.put_blob(key, data).await,
-                #[cfg(feature = "azure")]
-                BlobBackend::Azure(store) => store.put_blob(key, data).await,
-                BlobBackend::Sharded(_) => unimplemented!(),
-            }
-        })
-        .await
-    }
-
-    pub async fn delete_blob(&self, key: &[u8]) -> trc::Result<bool> {
-        Box::pin(async move {
-            match self.get_store(key) {
-                BlobBackend::Store(store) => match store {
-                    #[cfg(feature = "sqlite")]
-                    Store::SQLite(store) => store.delete_blob(key).await,
-                    #[cfg(feature = "foundation")]
-                    Store::FoundationDb(store) => store.delete_blob(key).await,
-                    #[cfg(feature = "postgres")]
-                    Store::PostgreSQL(store) => store.delete_blob(key).await,
-                    #[cfg(feature = "mysql")]
-                    Store::MySQL(store) => store.delete_blob(key).await,
-                    #[cfg(feature = "rocks")]
-                    Store::RocksDb(store) => store.delete_blob(key).await,
-                    // SPDX-SnippetBegin
-                    // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-                    // SPDX-License-Identifier: LicenseRef-SEL
-                    #[cfg(all(
-                        feature = "enterprise",
-                        any(feature = "postgres", feature = "mysql")
-                    ))]
-                    Store::SQLReadReplica(store) => store.delete_blob(key).await,
-                    // SPDX-SnippetEnd
-                    Store::None => Err(trc::StoreEvent::NotConfigured.into()),
-                },
-                BlobBackend::Fs(store) => store.delete_blob(key).await,
-                #[cfg(feature = "s3")]
-                BlobBackend::S3(store) => store.delete_blob(key).await,
-                #[cfg(feature = "azure")]
-                BlobBackend::Azure(store) => store.delete_blob(key).await,
-                BlobBackend::Sharded(_) => unimplemented!(),
-            }
-        })
-        .await
-    }
-}
diff --git a/crates/store/src/backend/composite/sharded_lookup.rs b/crates/store/src/backend/composite/sharded_lookup.rs
deleted file mode 100644
index 6e95c694..00000000
--- a/crates/store/src/backend/composite/sharded_lookup.rs
+++ /dev/null
@@ -1,177 +0,0 @@
-/*
- * SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
- *
- * SPDX-License-Identifier: LicenseRef-SEL
- *
- * This file is subject to the Stalwart Enterprise License Agreement (SEL) and
- * is NOT open source software.
- *
- */
-
-use utils::config::{Config, utils::AsKey};
-
-use crate::{
-    Deserialize, InMemoryStore, Stores, Value,
-    dispatch::lookup::{KeyValue, LookupKey},
-};
-
-#[derive(Debug)]
-pub struct ShardedInMemory {
-    pub stores: Vec<InMemoryStore>,
-}
-
-impl ShardedInMemory {
-    pub fn open(config: &mut Config, prefix: impl AsKey, stores: &Stores) -> Option<Self> {
-        let prefix = prefix.as_key();
-        let store_ids = config
-            .values((&prefix, "stores"))
-            .map(|(_, v)| v.to_string())
-            .collect::<Vec<_>>();
-
-        let mut in_memory_stores = Vec::with_capacity(store_ids.len());
-        for store_id in store_ids {
-            if let Some(store) = stores
-                .in_memory_stores
-                .get(&store_id)
-                .filter(|store| store.is_redis())
-            {
-                in_memory_stores.push(store.clone());
-            } else {
-                config.new_build_error(
-                    (&prefix, "stores"),
-                    format!("In-memory store {store_id} not found"),
-                );
-                return None;
-            }
-        }
-        if !in_memory_stores.is_empty() {
-            Some(Self {
-                stores: in_memory_stores,
-            })
-        } else {
-            config.new_build_error((&prefix, "stores"), "No in-memory stores specified");
-            None
-        }
-    }
-
-    #[inline(always)]
-    fn get_store(&self, key: &[u8]) -> &InMemoryStore {
-        &self.stores[xxhash_rust::xxh3::xxh3_64(key) as usize % self.stores.len()]
-    }
-
-    pub async fn key_set(&self, kv: KeyValue<Vec<u8>>) -> trc::Result<()> {
-        Box::pin(async move {
-            match self.get_store(&kv.key) {
-                #[cfg(feature = "redis")]
-                InMemoryStore::Redis(store) => store.key_set(&kv.key, &kv.value, kv.expires).await,
-                InMemoryStore::Static(_) => Err(trc::StoreEvent::NotSupported.into_err()),
-                _ => Err(trc::StoreEvent::NotSupported.into_err()),
-            }
-        })
-        .await
-    }
-
-    pub async fn counter_incr(&self, kv: KeyValue<i64>) -> trc::Result<i64> {
-        Box::pin(async move {
-            match self.get_store(&kv.key) {
-                #[cfg(feature = "redis")]
-                InMemoryStore::Redis(store) => store.key_incr(&kv.key, kv.value, kv.expires).await,
-                InMemoryStore::Static(_) => Err(trc::StoreEvent::NotSupported.into_err()),
-                _ => Err(trc::StoreEvent::NotSupported.into_err()),
-            }
-        })
-        .await
-    }
-
-    pub async fn key_delete(&self, key: impl Into<LookupKey<'_>>) -> trc::Result<()> {
-        let key_ = key.into();
-        let key = key_.as_bytes();
-        Box::pin(async move {
-            match self.get_store(key) {
-                #[cfg(feature = "redis")]
-                InMemoryStore::Redis(store) => store.key_delete(key).await,
-                InMemoryStore::Static(_) => Err(trc::StoreEvent::NotSupported.into_err()),
-                _ => Err(trc::StoreEvent::NotSupported.into_err()),
-            }
-        })
-        .await
-    }
-
-    pub async fn counter_delete(&self, key: impl Into<LookupKey<'_>>) -> trc::Result<()> {
-        let key_ = key.into();
-        let key = key_.as_bytes();
-        Box::pin(async move {
-            match self.get_store(key) {
-                #[cfg(feature = "redis")]
-                InMemoryStore::Redis(store) => store.key_delete(key).await,
-                InMemoryStore::Static(_) => Err(trc::StoreEvent::NotSupported.into_err()),
-                _ => Err(trc::StoreEvent::NotSupported.into_err()),
-            }
-        })
-        .await
-    }
-
-    #[allow(unused_variables)]
-    pub async fn key_delete_prefix(&self, prefix: &[u8]) -> trc::Result<()> {
-        Box::pin(async move {
-            #[cfg(feature = "redis")]
-            for store in &self.stores {
-                match store {
-                    InMemoryStore::Redis(store) => store.key_delete_prefix(prefix).await?,
-                    InMemoryStore::Static(_) => {
-                        return Err(trc::StoreEvent::NotSupported.into_err());
-                    }
-                    _ => return Err(trc::StoreEvent::NotSupported.into_err()),
-                }
-            }
-
-            Ok(())
-        })
-        .await
-    }
-
-    pub async fn key_get<T: Deserialize + From<Value<'static>> + std::fmt::Debug + 'static>(
-        &self,
-        key: impl Into<LookupKey<'_>>,
-    ) -> trc::Result<Option<T>> {
-        let key_ = key.into();
-        let key = key_.as_bytes();
-        Box::pin(async move {
-            match self.get_store(key) {
-                #[cfg(feature = "redis")]
-                InMemoryStore::Redis(store) => store.key_get(key).await,
-                InMemoryStore::Static(_) => Err(trc::StoreEvent::NotSupported.into_err()),
-                _ => Err(trc::StoreEvent::NotSupported.into_err()),
-            }
-        })
-        .await
-    }
-
-    pub async fn counter_get(&self, key: impl Into<LookupKey<'_>>) -> trc::Result<i64> {
-        let key_ = key.into();
-        let key = key_.as_bytes();
-        Box::pin(async move {
-            match self.get_store(key) {
-                #[cfg(feature = "redis")]
-                InMemoryStore::Redis(store) => store.counter_get(key).await,
-                InMemoryStore::Static(_) => Err(trc::StoreEvent::NotSupported.into_err()),
-                _ => Err(trc::StoreEvent::NotSupported.into_err()),
-            }
-        })
-        .await
-    }
-
-    pub async fn key_exists(&self, key: impl Into<LookupKey<'_>>) -> trc::Result<bool> {
-        let key_ = key.into();
-        let key = key_.as_bytes();
-        Box::pin(async move {
-            match self.get_store(key) {
-                #[cfg(feature = "redis")]
-                InMemoryStore::Redis(store) => store.key_exists(key).await,
-                InMemoryStore::Static(_) => Err(trc::StoreEvent::NotSupported.into_err()),
-                _ => Err(trc::StoreEvent::NotSupported.into_err()),
-            }
-        })
-        .await
-    }
-}
diff --git a/crates/store/src/backend/mod.rs b/crates/store/src/backend/mod.rs
index bac97ce4..3bb5dbb3 100644
--- a/crates/store/src/backend/mod.rs
+++ b/crates/store/src/backend/mod.rs
@@ -32,12 +32,6 @@ pub mod sqlite;
 #[cfg(feature = "zenoh")]
 pub mod zenoh;
 
-// SPDX-SnippetBegin
-// SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-// SPDX-License-Identifier: LicenseRef-SEL
-#[cfg(feature = "enterprise")]
-pub mod composite;
-// SPDX-SnippetEnd
 
 pub const MAX_TOKEN_LENGTH: usize = (u8::MAX >> 1) as usize;
 pub const MAX_TOKEN_MASK: usize = MAX_TOKEN_LENGTH - 1;
diff --git a/crates/store/src/config.rs b/crates/store/src/config.rs
index 30957e2e..e99c6599 100644
--- a/crates/store/src/config.rs
+++ b/crates/store/src/config.rs
@@ -10,17 +10,6 @@ use crate::{
 };
 use utils::config::{Config, cron::SimpleCron, utils::ParseValue};
 
-// SPDX-SnippetBegin
-// SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-// SPDX-License-Identifier: LicenseRef-SEL
-#[cfg(feature = "enterprise")]
-enum CompositeStore {
-    #[cfg(any(feature = "postgres", feature = "mysql"))]
-    SQLReadReplica(String),
-    ShardedBlob(String),
-    ShardedInMemory(String),
-}
-// SPDX-SnippetEnd
 
 impl Stores {
     pub async fn parse_all(config: &mut Config, is_reload: bool) -> Self {
@@ -38,12 +27,6 @@ impl Stores {
     pub async fn parse_stores(&mut self, config: &mut Config) {
         let is_reload = !self.stores.is_empty();
 
-        // SPDX-SnippetBegin
-        // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-        // SPDX-License-Identifier: LicenseRef-SEL
-        #[cfg(feature = "enterprise")]
-        let mut composite_stores = Vec::new();
-        // SPDX-SnippetEnd
 
         for store_id in config.sub_keys("store", ".type") {
             let id = store_id.as_str();
@@ -248,23 +231,6 @@ impl Stores {
                             .insert(store_id, crate::PubSubStore::Kafka(db));
                     }
                 }
-                // SPDX-SnippetBegin
-                // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-                // SPDX-License-Identifier: LicenseRef-SEL
-                #[cfg(feature = "enterprise")]
-                "sql-read-replica" => {
-                    #[cfg(any(feature = "postgres", feature = "mysql"))]
-                    composite_stores.push(CompositeStore::SQLReadReplica(store_id));
-                }
-                #[cfg(feature = "enterprise")]
-                "distributed-blob" | "sharded-blob" => {
-                    composite_stores.push(CompositeStore::ShardedBlob(store_id));
-                }
-                #[cfg(feature = "enterprise")]
-                "sharded-in-memory" => {
-                    composite_stores.push(CompositeStore::ShardedInMemory(store_id));
-                }
-                // SPDX-SnippetEnd
                 #[cfg(feature = "azure")]
                 "azure" => {
                     if let Some(db) = crate::backend::azure::AzureStore::open(config, prefix)
@@ -284,72 +250,6 @@ impl Stores {
             }
         }
 
-        // SPDX-SnippetBegin
-        // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-        // SPDX-License-Identifier: LicenseRef-SEL
-        #[cfg(feature = "enterprise")]
-        for composite_store in composite_stores {
-            match composite_store {
-                #[cfg(any(feature = "postgres", feature = "mysql"))]
-                CompositeStore::SQLReadReplica(id) => {
-                    let prefix = ("store", id.as_str());
-                    if let Some(db) = crate::backend::composite::read_replica::SQLReadReplica::open(
-                        config,
-                        prefix,
-                        self,
-                        config.is_active_store(&id),
-                    )
-                    .await
-                    {
-                        let db = Store::SQLReadReplica(db.into());
-                        self.stores.insert(id.to_string(), db.clone());
-                        self.fts_stores.insert(id.to_string(), db.clone().into());
-                        self.blob_stores.insert(
-                            id.to_string(),
-                            BlobStore::from(db.clone()).with_compression(
-                                config
-                                    .property_or_default::<CompressionAlgo>(
-                                        ("store", id.as_str(), "compression"),
-                                        "none",
-                                    )
-                                    .unwrap_or(CompressionAlgo::None),
-                            ),
-                        );
-                        self.in_memory_stores.insert(id, db.into());
-                    }
-                }
-                CompositeStore::ShardedBlob(id) => {
-                    let prefix = ("store", id.as_str());
-                    if let Some(db) = crate::backend::composite::sharded_blob::ShardedBlob::open(
-                        config, prefix, self,
-                    ) {
-                        let store = BlobStore {
-                            backend: crate::BlobBackend::Sharded(db.into()),
-                            compression: config
-                                .property_or_default::<CompressionAlgo>(
-                                    ("store", id.as_str(), "compression"),
-                                    "none",
-                                )
-                                .unwrap_or(CompressionAlgo::None),
-                        };
-                        self.blob_stores.insert(id, store);
-                    }
-                }
-                CompositeStore::ShardedInMemory(id) => {
-                    let prefix = ("store", id.as_str());
-                    if let Some(db) =
-                        crate::backend::composite::sharded_lookup::ShardedInMemory::open(
-                            config, prefix, self,
-                        )
-                    {
-                        self.in_memory_stores
-                            .insert(id, InMemoryStore::Sharded(db.into()));
-                    }
-                }
-            }
-        }
-
-        // SPDX-SnippetEnd
     }
 
     pub async fn parse_in_memory(&mut self, config: &mut Config, is_reload: bool) {
diff --git a/crates/store/src/dispatch/blob.rs b/crates/store/src/dispatch/blob.rs
index 858f5e27..d2b3c448 100644
--- a/crates/store/src/dispatch/blob.rs
+++ b/crates/store/src/dispatch/blob.rs
@@ -30,12 +30,6 @@ impl BlobStore {
                 Store::MySQL(store) => store.get_blob(key, read_range).await,
                 #[cfg(feature = "rocks")]
                 Store::RocksDb(store) => store.get_blob(key, read_range).await,
-                // SPDX-SnippetBegin
-                // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-                // SPDX-License-Identifier: LicenseRef-SEL
-                #[cfg(all(feature = "enterprise", any(feature = "postgres", feature = "mysql")))]
-                Store::SQLReadReplica(store) => store.get_blob(key, read_range).await,
-                // SPDX-SnippetEnd
                 Store::None => Err(trc::StoreEvent::NotConfigured.into()),
             },
             BlobBackend::Fs(store) => store.get_blob(key, read_range).await,
@@ -43,12 +37,6 @@ impl BlobStore {
             BlobBackend::S3(store) => store.get_blob(key, read_range).await,
             #[cfg(feature = "azure")]
             BlobBackend::Azure(store) => store.get_blob(key, read_range).await,
-            // SPDX-SnippetBegin
-            // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-            // SPDX-License-Identifier: LicenseRef-SEL
-            #[cfg(feature = "enterprise")]
-            BlobBackend::Sharded(store) => store.get_blob(key, read_range).await,
-            // SPDX-SnippetEnd
         };
 
         trc::event!(
@@ -120,12 +108,6 @@ impl BlobStore {
                 Store::MySQL(store) => store.put_blob(key, data.as_ref()).await,
                 #[cfg(feature = "rocks")]
                 Store::RocksDb(store) => store.put_blob(key, data.as_ref()).await,
-                // SPDX-SnippetBegin
-                // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-                // SPDX-License-Identifier: LicenseRef-SEL
-                #[cfg(all(feature = "enterprise", any(feature = "postgres", feature = "mysql")))]
-                Store::SQLReadReplica(store) => store.put_blob(key, data.as_ref()).await,
-                // SPDX-SnippetEnd
                 Store::None => Err(trc::StoreEvent::NotConfigured.into()),
             },
             BlobBackend::Fs(store) => store.put_blob(key, data.as_ref()).await,
@@ -133,12 +115,6 @@ impl BlobStore {
             BlobBackend::S3(store) => store.put_blob(key, data.as_ref()).await,
             #[cfg(feature = "azure")]
             BlobBackend::Azure(store) => store.put_blob(key, data.as_ref()).await,
-            // SPDX-SnippetBegin
-            // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-            // SPDX-License-Identifier: LicenseRef-SEL
-            #[cfg(feature = "enterprise")]
-            BlobBackend::Sharded(store) => store.put_blob(key, data.as_ref()).await,
-            // SPDX-SnippetEnd
         }
         .caused_by(trc::location!());
 
@@ -166,12 +142,6 @@ impl BlobStore {
                 Store::MySQL(store) => store.delete_blob(key).await,
                 #[cfg(feature = "rocks")]
                 Store::RocksDb(store) => store.delete_blob(key).await,
-                // SPDX-SnippetBegin
-                // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-                // SPDX-License-Identifier: LicenseRef-SEL
-                #[cfg(all(feature = "enterprise", any(feature = "postgres", feature = "mysql")))]
-                Store::SQLReadReplica(store) => store.delete_blob(key).await,
-                // SPDX-SnippetEnd
                 Store::None => Err(trc::StoreEvent::NotConfigured.into()),
             },
             BlobBackend::Fs(store) => store.delete_blob(key).await,
@@ -179,12 +149,6 @@ impl BlobStore {
             BlobBackend::S3(store) => store.delete_blob(key).await,
             #[cfg(feature = "azure")]
             BlobBackend::Azure(store) => store.delete_blob(key).await,
-            // SPDX-SnippetBegin
-            // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-            // SPDX-License-Identifier: LicenseRef-SEL
-            #[cfg(feature = "enterprise")]
-            BlobBackend::Sharded(store) => store.delete_blob(key).await,
-            // SPDX-SnippetEnd
         }
         .caused_by(trc::location!());
 
diff --git a/crates/store/src/dispatch/lookup.rs b/crates/store/src/dispatch/lookup.rs
index fc4d6c2f..e51e03ec 100644
--- a/crates/store/src/dispatch/lookup.rs
+++ b/crates/store/src/dispatch/lookup.rs
@@ -49,12 +49,6 @@ impl InMemoryStore {
             }
             #[cfg(feature = "redis")]
             InMemoryStore::Redis(store) => store.key_set(&kv.key, &kv.value, kv.expires).await,
-            // SPDX-SnippetBegin
-            // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-            // SPDX-License-Identifier: LicenseRef-SEL
-            #[cfg(feature = "enterprise")]
-            InMemoryStore::Sharded(store) => store.key_set(kv).await,
-            // SPDX-SnippetEnd
             InMemoryStore::Static(_) | InMemoryStore::Http(_) => {
                 Err(trc::StoreEvent::NotSupported.into_err())
             }
@@ -101,12 +95,6 @@ impl InMemoryStore {
             }
             #[cfg(feature = "redis")]
             InMemoryStore::Redis(store) => store.key_incr(&kv.key, kv.value, kv.expires).await,
-            // SPDX-SnippetBegin
-            // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-            // SPDX-License-Identifier: LicenseRef-SEL
-            #[cfg(feature = "enterprise")]
-            InMemoryStore::Sharded(store) => store.counter_incr(kv).await,
-            // SPDX-SnippetEnd
             InMemoryStore::Static(_) | InMemoryStore::Http(_) => {
                 Err(trc::StoreEvent::NotSupported.into_err())
             }
@@ -126,12 +114,6 @@ impl InMemoryStore {
             }
             #[cfg(feature = "redis")]
             InMemoryStore::Redis(store) => store.key_delete(key.into().as_bytes()).await,
-            // SPDX-SnippetBegin
-            // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-            // SPDX-License-Identifier: LicenseRef-SEL
-            #[cfg(feature = "enterprise")]
-            InMemoryStore::Sharded(store) => store.key_delete(key).await,
-            // SPDX-SnippetEnd
             InMemoryStore::Static(_) | InMemoryStore::Http(_) => {
                 Err(trc::StoreEvent::NotSupported.into_err())
             }
@@ -151,12 +133,6 @@ impl InMemoryStore {
             }
             #[cfg(feature = "redis")]
             InMemoryStore::Redis(store) => store.key_delete(key.into().as_bytes()).await,
-            // SPDX-SnippetBegin
-            // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-            // SPDX-License-Identifier: LicenseRef-SEL
-            #[cfg(feature = "enterprise")]
-            InMemoryStore::Sharded(store) => store.counter_delete(key).await,
-            // SPDX-SnippetEnd
             InMemoryStore::Static(_) | InMemoryStore::Http(_) => {
                 Err(trc::StoreEvent::NotSupported.into_err())
             }
@@ -196,12 +172,6 @@ impl InMemoryStore {
             }
             #[cfg(feature = "redis")]
             InMemoryStore::Redis(store) => store.key_delete_prefix(prefix).await,
-            // SPDX-SnippetBegin
-            // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-            // SPDX-License-Identifier: LicenseRef-SEL
-            #[cfg(feature = "enterprise")]
-            InMemoryStore::Sharded(store) => store.key_delete_prefix(prefix).await,
-            // SPDX-SnippetEnd
             InMemoryStore::Static(_) | InMemoryStore::Http(_) => {
                 Err(trc::StoreEvent::NotSupported.into_err())
             }
@@ -222,12 +192,6 @@ impl InMemoryStore {
                 .map(|value| value.and_then(|v| v.into())),
             #[cfg(feature = "redis")]
             InMemoryStore::Redis(store) => store.key_get(key.into().as_bytes()).await,
-            // SPDX-SnippetBegin
-            // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-            // SPDX-License-Identifier: LicenseRef-SEL
-            #[cfg(feature = "enterprise")]
-            InMemoryStore::Sharded(store) => store.key_get(key).await,
-            // SPDX-SnippetEnd
             InMemoryStore::Static(store) => Ok(store
                 .get(key.into().as_str())
                 .map(|value| T::from(value.clone()))),
@@ -249,12 +213,6 @@ impl InMemoryStore {
             }
             #[cfg(feature = "redis")]
             InMemoryStore::Redis(store) => store.counter_get(key.into().as_bytes()).await,
-            // SPDX-SnippetBegin
-            // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-            // SPDX-License-Identifier: LicenseRef-SEL
-            #[cfg(feature = "enterprise")]
-            InMemoryStore::Sharded(store) => store.counter_get(key).await,
-            // SPDX-SnippetEnd
             InMemoryStore::Static(_) | InMemoryStore::Http(_) => {
                 Err(trc::StoreEvent::NotSupported.into_err())
             }
@@ -272,12 +230,6 @@ impl InMemoryStore {
                 .map(|value| matches!(value, Some(LookupValue::Value(())))),
             #[cfg(feature = "redis")]
             InMemoryStore::Redis(store) => store.key_exists(key.into().as_bytes()).await,
-            // SPDX-SnippetBegin
-            // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-            // SPDX-License-Identifier: LicenseRef-SEL
-            #[cfg(feature = "enterprise")]
-            InMemoryStore::Sharded(store) => store.key_exists(key).await,
-            // SPDX-SnippetEnd
             InMemoryStore::Static(store) => Ok(store.get(key.into().as_str()).is_some()),
             InMemoryStore::Http(store) => Ok(store.contains(key.into().as_str())),
         }
@@ -377,15 +329,6 @@ impl InMemoryStore {
                 .key_incr(&KeyValue::<()>::build_key(prefix, key), 1, duration.into())
                 .await
                 .map(|count| count == 1),
-            // SPDX-SnippetBegin
-            // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-            // SPDX-License-Identifier: LicenseRef-SEL
-            #[cfg(feature = "enterprise")]
-            InMemoryStore::Sharded(store) => store
-                .counter_incr(KeyValue::with_prefix(prefix, key, 1).expires(duration))
-                .await
-                .map(|count| count == 1),
-            // SPDX-SnippetEnd
             InMemoryStore::Static(_) | InMemoryStore::Http(_) => {
                 Err(trc::StoreEvent::NotSupported.into_err())
             }
@@ -479,12 +422,6 @@ impl InMemoryStore {
             }
             #[cfg(feature = "redis")]
             InMemoryStore::Redis(_) => {}
-            // SPDX-SnippetBegin
-            // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-            // SPDX-License-Identifier: LicenseRef-SEL
-            #[cfg(feature = "enterprise")]
-            InMemoryStore::Sharded(_) => {}
-            // SPDX-SnippetEnd
             InMemoryStore::Static(_) | InMemoryStore::Http(_) => {}
         }
 
diff --git a/crates/store/src/dispatch/mod.rs b/crates/store/src/dispatch/mod.rs
index 77d1cde6..bb5e0faf 100644
--- a/crates/store/src/dispatch/mod.rs
+++ b/crates/store/src/dispatch/mod.rs
@@ -27,12 +27,6 @@ impl Store {
             Self::MySQL(_) => "mysql",
             #[cfg(feature = "rocks")]
             Self::RocksDb(_) => "rocksdb",
-            // SPDX-SnippetBegin
-            // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-            // SPDX-License-Identifier: LicenseRef-SEL
-            #[cfg(all(feature = "enterprise", any(feature = "postgres", feature = "mysql")))]
-            Self::SQLReadReplica(_) => "read_replica",
-            // SPDX-SnippetEnd
             Self::None => "none",
         }
     }
diff --git a/crates/store/src/dispatch/store.rs b/crates/store/src/dispatch/store.rs
index 8b398048..841e3675 100644
--- a/crates/store/src/dispatch/store.rs
+++ b/crates/store/src/dispatch/store.rs
@@ -53,12 +53,6 @@ impl Store {
             Self::MySQL(store) => store.get_value(key).await,
             #[cfg(feature = "rocks")]
             Self::RocksDb(store) => store.get_value(key).await,
-            // SPDX-SnippetBegin
-            // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-            // SPDX-License-Identifier: LicenseRef-SEL
-            #[cfg(all(feature = "enterprise", any(feature = "postgres", feature = "mysql")))]
-            Self::SQLReadReplica(store) => store.get_value(key).await,
-            // SPDX-SnippetEnd
             Self::None => Err(trc::StoreEvent::NotConfigured.into()),
         }
         .caused_by(trc::location!())
@@ -79,12 +73,6 @@ impl Store {
             Self::MySQL(store) => store.get_bitmap(key).await,
             #[cfg(feature = "rocks")]
             Self::RocksDb(store) => store.get_bitmap(key).await,
-            // SPDX-SnippetBegin
-            // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-            // SPDX-License-Identifier: LicenseRef-SEL
-            #[cfg(all(feature = "enterprise", any(feature = "postgres", feature = "mysql")))]
-            Self::SQLReadReplica(store) => store.get_bitmap(key).await,
-            // SPDX-SnippetEnd
             Self::None => Err(trc::StoreEvent::NotConfigured.into()),
         }
         .caused_by(trc::location!())
@@ -129,12 +117,6 @@ impl Store {
             Self::MySQL(store) => store.iterate(params, cb).await,
             #[cfg(feature = "rocks")]
             Self::RocksDb(store) => store.iterate(params, cb).await,
-            // SPDX-SnippetBegin
-            // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-            // SPDX-License-Identifier: LicenseRef-SEL
-            #[cfg(all(feature = "enterprise", any(feature = "postgres", feature = "mysql")))]
-            Self::SQLReadReplica(store) => store.iterate(params, cb).await,
-            // SPDX-SnippetEnd
             Self::None => Err(trc::StoreEvent::NotConfigured.into()),
         }
         .caused_by(trc::location!());
@@ -162,12 +144,6 @@ impl Store {
             Self::MySQL(store) => store.get_counter(key).await,
             #[cfg(feature = "rocks")]
             Self::RocksDb(store) => store.get_counter(key).await,
-            // SPDX-SnippetBegin
-            // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-            // SPDX-License-Identifier: LicenseRef-SEL
-            #[cfg(all(feature = "enterprise", any(feature = "postgres", feature = "mysql")))]
-            Self::SQLReadReplica(store) => store.get_counter(key).await,
-            // SPDX-SnippetEnd
             Self::None => Err(trc::StoreEvent::NotConfigured.into()),
         }
         .caused_by(trc::location!())
@@ -215,12 +191,6 @@ impl Store {
             Self::MySQL(store) => store.write(batch).await,
             #[cfg(feature = "rocks")]
             Self::RocksDb(store) => store.write(batch).await,
-            // SPDX-SnippetBegin
-            // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-            // SPDX-License-Identifier: LicenseRef-SEL
-            #[cfg(all(feature = "enterprise", any(feature = "postgres", feature = "mysql")))]
-            Self::SQLReadReplica(store) => store.write(batch).await,
-            // SPDX-SnippetEnd
             Self::None => Err(trc::StoreEvent::NotConfigured.into()),
         };
 
@@ -295,12 +265,6 @@ impl Store {
             Self::MySQL(store) => store.purge_store().await,
             #[cfg(feature = "rocks")]
             Self::RocksDb(store) => store.purge_store().await,
-            // SPDX-SnippetBegin
-            // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-            // SPDX-License-Identifier: LicenseRef-SEL
-            #[cfg(all(feature = "enterprise", any(feature = "postgres", feature = "mysql")))]
-            Self::SQLReadReplica(store) => store.purge_store().await,
-            // SPDX-SnippetEnd
             Self::None => Err(trc::StoreEvent::NotConfigured.into()),
         }
         .caused_by(trc::location!())
@@ -318,12 +282,6 @@ impl Store {
             Self::MySQL(store) => store.delete_range(from, to).await,
             #[cfg(feature = "rocks")]
             Self::RocksDb(store) => store.delete_range(from, to).await,
-            // SPDX-SnippetBegin
-            // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-            // SPDX-License-Identifier: LicenseRef-SEL
-            #[cfg(all(feature = "enterprise", any(feature = "postgres", feature = "mysql")))]
-            Self::SQLReadReplica(store) => store.delete_range(from, to).await,
-            // SPDX-SnippetEnd
             Self::None => Err(trc::StoreEvent::NotConfigured.into()),
         }
         .caused_by(trc::location!())
@@ -478,12 +436,6 @@ impl Store {
             Self::MySQL(store) => store.get_blob(key, range).await,
             #[cfg(feature = "rocks")]
             Self::RocksDb(store) => store.get_blob(key, range).await,
-            // SPDX-SnippetBegin
-            // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-            // SPDX-License-Identifier: LicenseRef-SEL
-            #[cfg(all(feature = "enterprise", any(feature = "postgres", feature = "mysql")))]
-            Self::SQLReadReplica(store) => store.get_blob(key, range).await,
-            // SPDX-SnippetEnd
             Self::None => Err(trc::StoreEvent::NotConfigured.into()),
         }
         .caused_by(trc::location!())
@@ -501,12 +453,6 @@ impl Store {
             Self::MySQL(store) => store.put_blob(key, data).await,
             #[cfg(feature = "rocks")]
             Self::RocksDb(store) => store.put_blob(key, data).await,
-            // SPDX-SnippetBegin
-            // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-            // SPDX-License-Identifier: LicenseRef-SEL
-            #[cfg(all(feature = "enterprise", any(feature = "postgres", feature = "mysql")))]
-            Self::SQLReadReplica(store) => store.put_blob(key, data).await,
-            // SPDX-SnippetEnd
             Self::None => Err(trc::StoreEvent::NotConfigured.into()),
         }
         .caused_by(trc::location!())
@@ -524,12 +470,6 @@ impl Store {
             Self::MySQL(store) => store.delete_blob(key).await,
             #[cfg(feature = "rocks")]
             Self::RocksDb(store) => store.delete_blob(key).await,
-            // SPDX-SnippetBegin
-            // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-            // SPDX-License-Identifier: LicenseRef-SEL
-            #[cfg(all(feature = "enterprise", any(feature = "postgres", feature = "mysql")))]
-            Self::SQLReadReplica(store) => store.delete_blob(key).await,
-            // SPDX-SnippetEnd
             Self::None => Err(trc::StoreEvent::NotConfigured.into()),
         }
         .caused_by(trc::location!())
diff --git a/crates/store/src/lib.rs b/crates/store/src/lib.rs
index 1c0e74b5..fe52782c 100644
--- a/crates/store/src/lib.rs
+++ b/crates/store/src/lib.rs
@@ -173,12 +173,6 @@ pub enum Store {
     MySQL(Arc<backend::mysql::MysqlStore>),
     #[cfg(feature = "rocks")]
     RocksDb(Arc<backend::rocksdb::RocksDbStore>),
-    // SPDX-SnippetBegin
-    // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-    // SPDX-License-Identifier: LicenseRef-SEL
-    #[cfg(all(feature = "enterprise", any(feature = "postgres", feature = "mysql")))]
-    SQLReadReplica(Arc<backend::composite::read_replica::SQLReadReplica>),
-    // SPDX-SnippetEnd
     #[default]
     None,
 }
@@ -203,12 +197,6 @@ pub enum BlobBackend {
     S3(Arc<backend::s3::S3Store>),
     #[cfg(feature = "azure")]
     Azure(Arc<backend::azure::AzureStore>),
-    // SPDX-SnippetBegin
-    // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-    // SPDX-License-Identifier: LicenseRef-SEL
-    #[cfg(feature = "enterprise")]
-    Sharded(Arc<backend::composite::sharded_blob::ShardedBlob>),
-    // SPDX-SnippetEnd
 }
 
 #[derive(Clone)]
@@ -225,12 +213,6 @@ pub enum InMemoryStore {
     Redis(Arc<backend::redis::RedisStore>),
     Http(Arc<HttpStore>),
     Static(Arc<StaticMemoryStore>),
-    // SPDX-SnippetBegin
-    // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-    // SPDX-License-Identifier: LicenseRef-SEL
-    #[cfg(feature = "enterprise")]
-    Sharded(Arc<backend::composite::sharded_lookup::ShardedInMemory>),
-    // SPDX-SnippetEnd
 }
 
 #[derive(Clone, Default)]
@@ -718,12 +700,6 @@ impl Store {
             Store::PostgreSQL(_) => true,
             #[cfg(feature = "mysql")]
             Store::MySQL(_) => true,
-            // SPDX-SnippetBegin
-            // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-            // SPDX-License-Identifier: LicenseRef-SEL
-            #[cfg(all(feature = "enterprise", any(feature = "postgres", feature = "mysql")))]
-            Store::SQLReadReplica(_) => true,
-            // SPDX-SnippetEnd
             _ => false,
         }
     }
@@ -738,18 +714,6 @@ impl Store {
         }
     }
 
-    // SPDX-SnippetBegin
-    // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-    // SPDX-License-Identifier: LicenseRef-SEL
-    #[cfg(feature = "enterprise")]
-    pub fn is_enterprise_store(&self) -> bool {
-        match self {
-            #[cfg(any(feature = "postgres", feature = "mysql"))]
-            Store::SQLReadReplica(_) => true,
-            _ => false,
-        }
-    }
-    // SPDX-SnippetEnd
 
     #[cfg(not(feature = "enterprise"))]
     pub fn is_enterprise_store(&self) -> bool {
@@ -771,12 +735,6 @@ impl std::fmt::Debug for Store {
             #[cfg(feature = "rocks")]
             Self::RocksDb(_) => f.debug_tuple("RocksDb").finish(),
 
-            // SPDX-SnippetBegin
-            // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-            // SPDX-License-Identifier: LicenseRef-SEL
-            #[cfg(all(feature = "enterprise", any(feature = "postgres", feature = "mysql")))]
-            Self::SQLReadReplica(_) => f.debug_tuple("SQLReadReplica").finish(),
-            // SPDX-SnippetEnd
             Self::None => f.debug_tuple("None").finish(),
         }
     }
@@ -806,17 +764,5 @@ impl From<Value<'static>> for () {
 
 impl Stores {
     pub fn disable_enterprise_only(&mut self) {
-        // SPDX-SnippetBegin
-        // SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-        // SPDX-License-Identifier: LicenseRef-SEL
-        #[cfg(feature = "enterprise")]
-        {
-            #[cfg(any(feature = "postgres", feature = "mysql"))]
-            self.stores
-                .retain(|_, store| !matches!(store, Store::SQLReadReplica(_)));
-            self.blob_stores
-                .retain(|_, store| !matches!(store.backend, BlobBackend::Sharded(_)));
-        }
-        // SPDX-SnippetEnd
     }
 }
diff --git a/crates/trc/src/serializers/binary.rs b/crates/trc/src/serializers/binary.rs
deleted file mode 100644
index c0795bbe..00000000
--- a/crates/trc/src/serializers/binary.rs
+++ /dev/null
@@ -1,1675 +0,0 @@
-/*
- * SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
- *
- * SPDX-License-Identifier: LicenseRef-SEL
- *
- * This file is subject to the Stalwart Enterprise License Agreement (SEL) and
- * is NOT open source software.
- *
- */
-
-use crate::*;
-use compact_str::format_compact;
-use std::net::{Ipv4Addr, Ipv6Addr};
-
-const VERSION: u8 = 1;
-
-pub fn serialize_events<'x>(
-    events: impl IntoIterator<Item = &'x Event<EventDetails>>,
-    num_events: usize,
-) -> Vec<u8> {
-    let mut buf = Vec::with_capacity(num_events * 64);
-    buf.push(VERSION);
-    leb128_write(&mut buf, num_events as u64);
-    for event in events {
-        event.serialize(&mut buf);
-    }
-    buf
-}
-
-pub fn deserialize_events(bytes: &[u8]) -> crate::Result<Vec<Event<EventDetails>>> {
-    let mut iter = bytes.iter();
-    if *iter.next().ok_or_else(|| {
-        StoreEvent::DataCorruption
-            .caused_by(crate::location!())
-            .details("EOF while reading version")
-    })? != VERSION
-    {
-        crate::bail!(
-            StoreEvent::DataCorruption
-                .caused_by(crate::location!())
-                .details("Invalid version")
-        );
-    }
-    let len = leb128_read(&mut iter).ok_or_else(|| {
-        StoreEvent::DataCorruption
-            .caused_by(crate::location!())
-            .details("EOF while size")
-    })? as usize;
-    let mut events = Vec::with_capacity(len);
-    for n in 0..len {
-        events.push(Event::deserialize(&mut iter).ok_or_else(|| {
-            StoreEvent::DataCorruption
-                .caused_by(crate::location!())
-                .details(format_compact!("Failed to deserialize event {n}"))
-        })?);
-    }
-    Ok(events)
-}
-
-pub fn deserialize_single_event(bytes: &[u8]) -> crate::Result<Event<EventDetails>> {
-    let mut iter = bytes.iter();
-    if *iter.next().ok_or_else(|| {
-        StoreEvent::DataCorruption
-            .caused_by(crate::location!())
-            .details("EOF while reading version")
-    })? != VERSION
-    {
-        crate::bail!(
-            StoreEvent::DataCorruption
-                .caused_by(crate::location!())
-                .details("Invalid version")
-        );
-    }
-    let _ = leb128_read(&mut iter).ok_or_else(|| {
-        StoreEvent::DataCorruption
-            .caused_by(crate::location!())
-            .details("EOF while size")
-    })?;
-    Event::deserialize(&mut iter).ok_or_else(|| {
-        StoreEvent::DataCorruption
-            .caused_by(crate::location!())
-            .details("Failed to deserialize event")
-    })
-}
-
-impl Event<EventDetails> {
-    pub fn serialize(&self, buf: &mut Vec<u8>) {
-        leb128_write(buf, self.inner.typ.code());
-        buf.extend_from_slice(self.inner.timestamp.to_le_bytes().as_ref());
-        leb128_write(buf, self.keys.len() as u64);
-        for (k, v) in &self.keys {
-            leb128_write(buf, k.code());
-            v.serialize(buf);
-        }
-    }
-    pub fn deserialize<'x>(iter: &mut impl Iterator<Item = &'x u8>) -> Option<Self> {
-        let typ = EventType::from_code(leb128_read(iter)?)?;
-        let timestamp = u64::from_le_bytes([
-            *iter.next()?,
-            *iter.next()?,
-            *iter.next()?,
-            *iter.next()?,
-            *iter.next()?,
-            *iter.next()?,
-            *iter.next()?,
-            *iter.next()?,
-        ]);
-        let keys_len = leb128_read(iter)?;
-        let mut keys = Vec::with_capacity(keys_len as usize);
-        for _ in 0..keys_len {
-            let key = Key::from_code(leb128_read(iter)?)?;
-            let value = Value::deserialize(iter)?;
-            keys.push((key, value));
-        }
-        Some(Event {
-            inner: EventDetails {
-                typ,
-                timestamp,
-                level: Level::Info,
-                span: None,
-            },
-            keys,
-        })
-    }
-}
-
-impl Value {
-    fn serialize(&self, buf: &mut Vec<u8>) {
-        match self {
-            Value::String(v) => {
-                buf.push(0u8);
-                leb128_write(buf, v.len() as u64);
-                buf.extend(v.as_bytes());
-            }
-            Value::UInt(v) => {
-                buf.push(1u8);
-                leb128_write(buf, *v);
-            }
-            Value::Int(v) => {
-                buf.push(2u8);
-                buf.extend(&v.to_le_bytes());
-            }
-            Value::Float(v) => {
-                buf.push(3u8);
-                buf.extend(&v.to_le_bytes());
-            }
-            Value::Timestamp(v) => {
-                buf.push(4u8);
-                buf.extend(&v.to_le_bytes());
-            }
-            Value::Duration(v) => {
-                buf.push(5u8);
-                leb128_write(buf, *v);
-            }
-            Value::Bytes(v) => {
-                buf.push(6u8);
-                leb128_write(buf, v.len() as u64);
-                buf.extend(v);
-            }
-            Value::Bool(true) => {
-                buf.push(7u8);
-            }
-            Value::Bool(false) => {
-                buf.push(8u8);
-            }
-            Value::Ipv4(v) => {
-                buf.push(9u8);
-                buf.extend(&v.octets());
-            }
-            Value::Ipv6(v) => {
-                buf.push(10u8);
-                buf.extend(&v.octets());
-            }
-            Value::Event(v) => {
-                buf.push(11u8);
-                leb128_write(buf, v.0.inner.code());
-                leb128_write(buf, v.0.keys.len() as u64);
-                for (k, v) in &v.0.keys {
-                    leb128_write(buf, k.code());
-                    v.serialize(buf);
-                }
-            }
-            Value::Array(v) => {
-                buf.push(12u8);
-                leb128_write(buf, v.len() as u64);
-                for value in v {
-                    value.serialize(buf);
-                }
-            }
-            Value::None => {
-                buf.push(13u8);
-            }
-        }
-    }
-
-    fn deserialize<'x>(iter: &mut impl Iterator<Item = &'x u8>) -> Option<Self> {
-        match iter.next()? {
-            0 => {
-                let mut buf = vec![0u8; leb128_read(iter)? as usize];
-                for byte in buf.iter_mut() {
-                    *byte = *iter.next()?;
-                }
-                Some(Value::String(CompactString::from_utf8(buf).ok()?))
-            }
-            1 => Some(Value::UInt(leb128_read(iter)?)),
-            2 => {
-                let mut buf = [0u8; std::mem::size_of::<i64>()];
-                for byte in buf.iter_mut() {
-                    *byte = *iter.next()?;
-                }
-                Some(Value::Int(i64::from_le_bytes(buf)))
-            }
-            3 => {
-                let mut buf = [0u8; std::mem::size_of::<f64>()];
-                for byte in buf.iter_mut() {
-                    *byte = *iter.next()?;
-                }
-                Some(Value::Float(f64::from_le_bytes(buf)))
-            }
-            4 => {
-                let mut buf = [0u8; std::mem::size_of::<u64>()];
-                for byte in buf.iter_mut() {
-                    *byte = *iter.next()?;
-                }
-                Some(Value::Timestamp(u64::from_le_bytes(buf)))
-            }
-            5 => Some(Value::Duration(leb128_read(iter)?)),
-            6 => {
-                let mut buf = vec![0u8; leb128_read(iter)? as usize];
-                for byte in buf.iter_mut() {
-                    *byte = *iter.next()?;
-                }
-                Some(Value::Bytes(buf))
-            }
-            7 => Some(Value::Bool(true)),
-            8 => Some(Value::Bool(false)),
-            9 => {
-                let mut buf = [0u8; 4];
-                for byte in buf.iter_mut() {
-                    *byte = *iter.next()?;
-                }
-                Some(Value::Ipv4(Ipv4Addr::from(buf)))
-            }
-            10 => {
-                let mut buf = [0u8; 16];
-                for byte in buf.iter_mut() {
-                    *byte = *iter.next()?;
-                }
-                Some(Value::Ipv6(Ipv6Addr::from(buf)))
-            }
-            11 => {
-                let code = EventType::from_code(leb128_read(iter)?)?;
-                let keys_len = leb128_read(iter)?;
-                let mut keys = Vec::with_capacity(keys_len as usize);
-                for _ in 0..keys_len {
-                    let key = Key::from_code(leb128_read(iter)?)?;
-                    let value = Value::deserialize(iter)?;
-                    keys.push((key, value));
-                }
-                Some(Value::Event(Error(
-                    Event::with_keys(code, keys).into_boxed(),
-                )))
-            }
-            12 => {
-                let len = leb128_read(iter)?;
-                let mut values = Vec::with_capacity(len as usize);
-                for _ in 0..len {
-                    values.push(Value::deserialize(iter)?);
-                }
-                Some(Value::Array(values))
-            }
-            13 => Some(Value::None),
-            _ => None,
-        }
-    }
-}
-
-fn leb128_write(buf: &mut Vec<u8>, mut value: u64) {
-    loop {
-        if value < 0x80 {
-            buf.push(value as u8);
-            break;
-        } else {
-            buf.push(((value & 0x7f) | 0x80) as u8);
-            value >>= 7;
-        }
-    }
-}
-
-fn leb128_read<'x>(iter: &mut impl Iterator<Item = &'x u8>) -> Option<u64> {
-    let mut result = 0;
-
-    for shift in [0, 7, 14, 21, 28, 35, 42, 49, 56, 63] {
-        let byte = iter.next()?;
-
-        if (byte & 0x80) == 0 {
-            result |= (*byte as u64) << shift;
-            return Some(result);
-        } else {
-            result |= ((byte & 0x7F) as u64) << shift;
-        }
-    }
-
-    None
-}
-
-impl EventType {
-    pub fn code(&self) -> u64 {
-        match self {
-            EventType::Acme(AcmeEvent::AuthCompleted) => 0,
-            EventType::Acme(AcmeEvent::AuthError) => 1,
-            EventType::Acme(AcmeEvent::AuthPending) => 2,
-            EventType::Acme(AcmeEvent::AuthStart) => 3,
-            EventType::Acme(AcmeEvent::AuthTooManyAttempts) => 4,
-            EventType::Acme(AcmeEvent::AuthValid) => 5,
-            EventType::Acme(AcmeEvent::ClientMissingSni) => 6,
-            EventType::Acme(AcmeEvent::ClientSuppliedSni) => 7,
-            EventType::Acme(AcmeEvent::DnsRecordCreated) => 8,
-            EventType::Acme(AcmeEvent::DnsRecordCreationFailed) => 9,
-            EventType::Acme(AcmeEvent::DnsRecordDeletionFailed) => 10,
-            EventType::Acme(AcmeEvent::DnsRecordLookupFailed) => 11,
-            EventType::Acme(AcmeEvent::DnsRecordNotPropagated) => 12,
-            EventType::Acme(AcmeEvent::DnsRecordPropagated) => 13,
-            EventType::Acme(AcmeEvent::DnsRecordPropagationTimeout) => 14,
-            EventType::Acme(AcmeEvent::Error) => 15,
-            EventType::Acme(AcmeEvent::OrderCompleted) => 16,
-            EventType::Acme(AcmeEvent::OrderInvalid) => 17,
-            EventType::Acme(AcmeEvent::OrderProcessing) => 18,
-            EventType::Acme(AcmeEvent::OrderReady) => 19,
-            EventType::Acme(AcmeEvent::OrderStart) => 20,
-            EventType::Acme(AcmeEvent::OrderValid) => 21,
-            EventType::Acme(AcmeEvent::ProcessCert) => 22,
-            EventType::Acme(AcmeEvent::RenewBackoff) => 23,
-            EventType::Acme(AcmeEvent::TlsAlpnError) => 24,
-            EventType::Acme(AcmeEvent::TlsAlpnReceived) => 25,
-            EventType::Acme(AcmeEvent::TokenNotFound) => 26,
-            EventType::Arc(ArcEvent::BrokenChain) => 27,
-            EventType::Arc(ArcEvent::ChainTooLong) => 28,
-            EventType::Arc(ArcEvent::HasHeaderTag) => 29,
-            EventType::Arc(ArcEvent::InvalidCv) => 30,
-            EventType::Arc(ArcEvent::InvalidInstance) => 31,
-            EventType::Arc(ArcEvent::SealerNotFound) => 32,
-            EventType::Security(SecurityEvent::AuthenticationBan) => 33,
-            EventType::Auth(AuthEvent::Error) => 34,
-            EventType::Auth(AuthEvent::Failed) => 35,
-            EventType::Auth(AuthEvent::MissingTotp) => 36,
-            EventType::Auth(AuthEvent::Success) => 37,
-            EventType::Auth(AuthEvent::TooManyAttempts) => 38,
-            EventType::Cluster(ClusterEvent::SubscriberStart) => 39,
-            EventType::Cluster(ClusterEvent::SubscriberStop) => 40,
-            EventType::Cluster(ClusterEvent::SubscriberError) => 41,
-            EventType::Cluster(ClusterEvent::SubscriberDisconnected) => 42,
-            EventType::Cluster(ClusterEvent::PublisherStart) => 43,
-            EventType::Cluster(ClusterEvent::PublisherStop) => 44,
-            EventType::Cluster(ClusterEvent::PublisherError) => 45,
-            EventType::Cluster(ClusterEvent::MessageReceived) => 46,
-            EventType::Cluster(ClusterEvent::MessageSkipped) => 47,
-            EventType::Cluster(ClusterEvent::MessageInvalid) => 49,
-            EventType::Config(ConfigEvent::AlreadyUpToDate) => 53,
-            EventType::Config(ConfigEvent::BuildError) => 54,
-            EventType::Config(ConfigEvent::BuildWarning) => 55,
-            EventType::Config(ConfigEvent::DefaultApplied) => 56,
-            EventType::Config(ConfigEvent::FetchError) => 58,
-            EventType::Config(ConfigEvent::ImportExternal) => 59,
-            EventType::Config(ConfigEvent::MacroError) => 60,
-            EventType::Config(ConfigEvent::MissingSetting) => 61,
-            EventType::Config(ConfigEvent::ParseError) => 62,
-            EventType::Config(ConfigEvent::ParseWarning) => 63,
-            EventType::Config(ConfigEvent::UnusedSetting) => 64,
-            EventType::Config(ConfigEvent::WriteError) => 65,
-            EventType::Dane(DaneEvent::AuthenticationFailure) => 66,
-            EventType::Dane(DaneEvent::AuthenticationSuccess) => 67,
-            EventType::Dane(DaneEvent::CertificateParseError) => 68,
-            EventType::Dane(DaneEvent::NoCertificatesFound) => 69,
-            EventType::Dane(DaneEvent::TlsaRecordFetch) => 70,
-            EventType::Dane(DaneEvent::TlsaRecordFetchError) => 71,
-            EventType::Dane(DaneEvent::TlsaRecordInvalid) => 72,
-            EventType::Dane(DaneEvent::TlsaRecordMatch) => 73,
-            EventType::Dane(DaneEvent::TlsaRecordNotDnssecSigned) => 74,
-            EventType::Dane(DaneEvent::TlsaRecordNotFound) => 75,
-            EventType::Delivery(DeliveryEvent::AttemptEnd) => 76,
-            EventType::Delivery(DeliveryEvent::AttemptStart) => 77,
-            EventType::Delivery(DeliveryEvent::Auth) => 78,
-            EventType::Delivery(DeliveryEvent::AuthFailed) => 79,
-            EventType::Delivery(DeliveryEvent::Completed) => 80,
-            EventType::Delivery(DeliveryEvent::ConcurrencyLimitExceeded) => 81,
-            EventType::Delivery(DeliveryEvent::Connect) => 82,
-            EventType::Delivery(DeliveryEvent::ConnectError) => 83,
-            EventType::Delivery(DeliveryEvent::Delivered) => 84,
-            EventType::Delivery(DeliveryEvent::DomainDeliveryStart) => 85,
-            EventType::Delivery(DeliveryEvent::DoubleBounce) => 86,
-            EventType::Delivery(DeliveryEvent::DsnPermFail) => 87,
-            EventType::Delivery(DeliveryEvent::DsnSuccess) => 88,
-            EventType::Delivery(DeliveryEvent::DsnTempFail) => 89,
-            EventType::Delivery(DeliveryEvent::Ehlo) => 90,
-            EventType::Delivery(DeliveryEvent::EhloRejected) => 91,
-            EventType::Delivery(DeliveryEvent::Failed) => 92,
-            EventType::Delivery(DeliveryEvent::GreetingFailed) => 93,
-            EventType::Delivery(DeliveryEvent::ImplicitTlsError) => 94,
-            EventType::Delivery(DeliveryEvent::IpLookup) => 95,
-            EventType::Delivery(DeliveryEvent::IpLookupFailed) => 96,
-            EventType::Delivery(DeliveryEvent::MailFrom) => 97,
-            EventType::Delivery(DeliveryEvent::MailFromRejected) => 98,
-            EventType::Delivery(DeliveryEvent::MessageRejected) => 99,
-            EventType::Delivery(DeliveryEvent::MissingOutboundHostname) => 100,
-            EventType::Delivery(DeliveryEvent::MxLookup) => 101,
-            EventType::Delivery(DeliveryEvent::MxLookupFailed) => 102,
-            EventType::Delivery(DeliveryEvent::NullMx) => 103,
-            EventType::Delivery(DeliveryEvent::RateLimitExceeded) => 104,
-            EventType::Delivery(DeliveryEvent::RawInput) => 105,
-            EventType::Delivery(DeliveryEvent::RawOutput) => 106,
-            EventType::Delivery(DeliveryEvent::RcptTo) => 107,
-            EventType::Delivery(DeliveryEvent::RcptToFailed) => 108,
-            EventType::Delivery(DeliveryEvent::RcptToRejected) => 109,
-            EventType::Delivery(DeliveryEvent::StartTls) => 110,
-            EventType::Delivery(DeliveryEvent::StartTlsDisabled) => 111,
-            EventType::Delivery(DeliveryEvent::StartTlsError) => 112,
-            EventType::Delivery(DeliveryEvent::StartTlsUnavailable) => 113,
-            EventType::Dkim(DkimEvent::Fail) => 114,
-            EventType::Dkim(DkimEvent::FailedAuidMatch) => 115,
-            EventType::Dkim(DkimEvent::FailedBodyHashMatch) => 116,
-            EventType::Dkim(DkimEvent::FailedVerification) => 117,
-            EventType::Dkim(DkimEvent::IncompatibleAlgorithms) => 118,
-            EventType::Dkim(DkimEvent::Neutral) => 119,
-            EventType::Dkim(DkimEvent::None) => 120,
-            EventType::Dkim(DkimEvent::Pass) => 121,
-            EventType::Dkim(DkimEvent::PermError) => 122,
-            EventType::Dkim(DkimEvent::RevokedPublicKey) => 123,
-            EventType::Dkim(DkimEvent::SignatureExpired) => 124,
-            EventType::Dkim(DkimEvent::SignatureLength) => 125,
-            EventType::Dkim(DkimEvent::SignerNotFound) => 126,
-            EventType::Dkim(DkimEvent::TempError) => 127,
-            EventType::Dkim(DkimEvent::UnsupportedAlgorithm) => 128,
-            EventType::Dkim(DkimEvent::UnsupportedCanonicalization) => 129,
-            EventType::Dkim(DkimEvent::UnsupportedKeyType) => 130,
-            EventType::Dkim(DkimEvent::UnsupportedVersion) => 131,
-            EventType::Dmarc(DmarcEvent::Fail) => 132,
-            EventType::Dmarc(DmarcEvent::None) => 133,
-            EventType::Dmarc(DmarcEvent::Pass) => 134,
-            EventType::Dmarc(DmarcEvent::PermError) => 135,
-            EventType::Dmarc(DmarcEvent::TempError) => 136,
-            EventType::Eval(EvalEvent::DirectoryNotFound) => 137,
-            EventType::Eval(EvalEvent::Error) => 138,
-            EventType::Eval(EvalEvent::Result) => 139,
-            EventType::Eval(EvalEvent::StoreNotFound) => 140,
-            EventType::TaskQueue(TaskQueueEvent::BlobNotFound) => 141,
-            EventType::MessageIngest(MessageIngestEvent::FtsIndex) => 142,
-            EventType::Spam(SpamEvent::TrainAccount) => 143,
-            EventType::TaskQueue(TaskQueueEvent::TaskLocked) => 144,
-            EventType::TaskQueue(TaskQueueEvent::MetadataNotFound) => 145,
-            EventType::Housekeeper(HousekeeperEvent::Run) => 146,
-            EventType::Housekeeper(HousekeeperEvent::Schedule) => 149,
-            EventType::Housekeeper(HousekeeperEvent::Start) => 150,
-            EventType::Housekeeper(HousekeeperEvent::Stop) => 151,
-            EventType::Http(HttpEvent::ConnectionEnd) => 152,
-            EventType::Http(HttpEvent::ConnectionStart) => 153,
-            EventType::Http(HttpEvent::Error) => 154,
-            EventType::Http(HttpEvent::RequestBody) => 155,
-            EventType::Http(HttpEvent::RequestUrl) => 156,
-            EventType::Http(HttpEvent::ResponseBody) => 157,
-            EventType::Http(HttpEvent::XForwardedMissing) => 158,
-            EventType::Imap(ImapEvent::Append) => 159,
-            EventType::Imap(ImapEvent::Capabilities) => 160,
-            EventType::Imap(ImapEvent::Close) => 161,
-            EventType::Imap(ImapEvent::ConnectionEnd) => 162,
-            EventType::Imap(ImapEvent::ConnectionStart) => 163,
-            EventType::Imap(ImapEvent::Copy) => 164,
-            EventType::Imap(ImapEvent::CreateMailbox) => 165,
-            EventType::Imap(ImapEvent::DeleteMailbox) => 166,
-            EventType::Imap(ImapEvent::Enable) => 167,
-            EventType::Imap(ImapEvent::Error) => 168,
-            EventType::Imap(ImapEvent::Expunge) => 169,
-            EventType::Imap(ImapEvent::Fetch) => 170,
-            EventType::Imap(ImapEvent::GetAcl) => 171,
-            EventType::Imap(ImapEvent::Id) => 172,
-            EventType::Imap(ImapEvent::IdleStart) => 173,
-            EventType::Imap(ImapEvent::IdleStop) => 174,
-            EventType::Imap(ImapEvent::List) => 175,
-            EventType::Imap(ImapEvent::ListRights) => 176,
-            EventType::Imap(ImapEvent::Logout) => 177,
-            EventType::Imap(ImapEvent::Lsub) => 178,
-            EventType::Imap(ImapEvent::Move) => 179,
-            EventType::Imap(ImapEvent::MyRights) => 180,
-            EventType::Imap(ImapEvent::Namespace) => 181,
-            EventType::Imap(ImapEvent::Noop) => 182,
-            EventType::Imap(ImapEvent::RawInput) => 183,
-            EventType::Imap(ImapEvent::RawOutput) => 184,
-            EventType::Imap(ImapEvent::RenameMailbox) => 185,
-            EventType::Imap(ImapEvent::Search) => 186,
-            EventType::Imap(ImapEvent::Select) => 187,
-            EventType::Imap(ImapEvent::SetAcl) => 188,
-            EventType::Imap(ImapEvent::Sort) => 189,
-            EventType::Imap(ImapEvent::Status) => 190,
-            EventType::Imap(ImapEvent::Store) => 191,
-            EventType::Imap(ImapEvent::Subscribe) => 192,
-            EventType::Imap(ImapEvent::Thread) => 193,
-            EventType::Imap(ImapEvent::Unsubscribe) => 194,
-            EventType::IncomingReport(IncomingReportEvent::AbuseReport) => 195,
-            EventType::IncomingReport(IncomingReportEvent::ArfParseFailed) => 196,
-            EventType::IncomingReport(IncomingReportEvent::AuthFailureReport) => 197,
-            EventType::IncomingReport(IncomingReportEvent::DecompressError) => 198,
-            EventType::IncomingReport(IncomingReportEvent::DmarcParseFailed) => 199,
-            EventType::IncomingReport(IncomingReportEvent::DmarcReport) => 200,
-            EventType::IncomingReport(IncomingReportEvent::DmarcReportWithWarnings) => 201,
-            EventType::IncomingReport(IncomingReportEvent::FraudReport) => 202,
-            EventType::IncomingReport(IncomingReportEvent::MessageParseFailed) => 203,
-            EventType::IncomingReport(IncomingReportEvent::NotSpamReport) => 204,
-            EventType::IncomingReport(IncomingReportEvent::OtherReport) => 205,
-            EventType::IncomingReport(IncomingReportEvent::TlsReport) => 206,
-            EventType::IncomingReport(IncomingReportEvent::TlsReportWithWarnings) => 207,
-            EventType::IncomingReport(IncomingReportEvent::TlsRpcParseFailed) => 208,
-            EventType::IncomingReport(IncomingReportEvent::VirusReport) => 209,
-            EventType::Iprev(IprevEvent::Fail) => 210,
-            EventType::Iprev(IprevEvent::None) => 211,
-            EventType::Iprev(IprevEvent::Pass) => 212,
-            EventType::Iprev(IprevEvent::PermError) => 213,
-            EventType::Iprev(IprevEvent::TempError) => 214,
-            EventType::Jmap(JmapEvent::AccountNotFound) => 215,
-            EventType::Jmap(JmapEvent::AccountNotSupportedByMethod) => 216,
-            EventType::Jmap(JmapEvent::AccountReadOnly) => 217,
-            EventType::Jmap(JmapEvent::AnchorNotFound) => 218,
-            EventType::Jmap(JmapEvent::CannotCalculateChanges) => 219,
-            EventType::Jmap(JmapEvent::Forbidden) => 220,
-            EventType::Jmap(JmapEvent::InvalidArguments) => 221,
-            EventType::Jmap(JmapEvent::InvalidResultReference) => 222,
-            EventType::Jmap(JmapEvent::MethodCall) => 223,
-            EventType::Jmap(JmapEvent::NotFound) => 224,
-            EventType::Jmap(JmapEvent::NotJson) => 225,
-            EventType::Jmap(JmapEvent::NotRequest) => 226,
-            EventType::Jmap(JmapEvent::RequestTooLarge) => 227,
-            EventType::Jmap(JmapEvent::StateMismatch) => 228,
-            EventType::Jmap(JmapEvent::UnknownCapability) => 229,
-            EventType::Jmap(JmapEvent::UnknownDataType) => 230,
-            EventType::Jmap(JmapEvent::UnknownMethod) => 231,
-            EventType::Jmap(JmapEvent::UnsupportedFilter) => 232,
-            EventType::Jmap(JmapEvent::UnsupportedSort) => 233,
-            EventType::Jmap(JmapEvent::WebsocketError) => 234,
-            EventType::Jmap(JmapEvent::WebsocketStart) => 235,
-            EventType::Jmap(JmapEvent::WebsocketStop) => 236,
-            EventType::Limit(LimitEvent::BlobQuota) => 237,
-            EventType::Limit(LimitEvent::CallsIn) => 238,
-            EventType::Limit(LimitEvent::ConcurrentConnection) => 239,
-            EventType::Limit(LimitEvent::ConcurrentRequest) => 240,
-            EventType::Limit(LimitEvent::ConcurrentUpload) => 241,
-            EventType::Limit(LimitEvent::Quota) => 242,
-            EventType::Limit(LimitEvent::SizeRequest) => 243,
-            EventType::Limit(LimitEvent::SizeUpload) => 244,
-            EventType::Limit(LimitEvent::TooManyRequests) => 245,
-            EventType::MailAuth(MailAuthEvent::Base64) => 246,
-            EventType::MailAuth(MailAuthEvent::Crypto) => 247,
-            EventType::MailAuth(MailAuthEvent::DnsError) => 248,
-            EventType::MailAuth(MailAuthEvent::DnsInvalidRecordType) => 249,
-            EventType::MailAuth(MailAuthEvent::DnsRecordNotFound) => 250,
-            EventType::MailAuth(MailAuthEvent::Io) => 251,
-            EventType::MailAuth(MailAuthEvent::MissingParameters) => 252,
-            EventType::MailAuth(MailAuthEvent::NoHeadersFound) => 253,
-            EventType::MailAuth(MailAuthEvent::ParseError) => 254,
-            EventType::MailAuth(MailAuthEvent::PolicyNotAligned) => 255,
-            EventType::ManageSieve(ManageSieveEvent::Capabilities) => 256,
-            EventType::ManageSieve(ManageSieveEvent::CheckScript) => 257,
-            EventType::ManageSieve(ManageSieveEvent::ConnectionEnd) => 258,
-            EventType::ManageSieve(ManageSieveEvent::ConnectionStart) => 259,
-            EventType::ManageSieve(ManageSieveEvent::CreateScript) => 260,
-            EventType::ManageSieve(ManageSieveEvent::DeleteScript) => 261,
-            EventType::ManageSieve(ManageSieveEvent::Error) => 262,
-            EventType::ManageSieve(ManageSieveEvent::GetScript) => 263,
-            EventType::ManageSieve(ManageSieveEvent::HaveSpace) => 264,
-            EventType::ManageSieve(ManageSieveEvent::ListScripts) => 265,
-            EventType::ManageSieve(ManageSieveEvent::Logout) => 266,
-            EventType::ManageSieve(ManageSieveEvent::Noop) => 267,
-            EventType::ManageSieve(ManageSieveEvent::RawInput) => 268,
-            EventType::ManageSieve(ManageSieveEvent::RawOutput) => 269,
-            EventType::ManageSieve(ManageSieveEvent::RenameScript) => 270,
-            EventType::ManageSieve(ManageSieveEvent::SetActive) => 271,
-            EventType::ManageSieve(ManageSieveEvent::StartTls) => 272,
-            EventType::ManageSieve(ManageSieveEvent::Unauthenticate) => 273,
-            EventType::ManageSieve(ManageSieveEvent::UpdateScript) => 274,
-            EventType::Manage(ManageEvent::AlreadyExists) => 275,
-            EventType::Manage(ManageEvent::AssertFailed) => 276,
-            EventType::Manage(ManageEvent::Error) => 277,
-            EventType::Manage(ManageEvent::MissingParameter) => 278,
-            EventType::Manage(ManageEvent::NotFound) => 279,
-            EventType::Manage(ManageEvent::NotSupported) => 280,
-            EventType::MessageIngest(MessageIngestEvent::Duplicate) => 281,
-            EventType::MessageIngest(MessageIngestEvent::Error) => 282,
-            EventType::MessageIngest(MessageIngestEvent::Ham) => 283,
-            EventType::MessageIngest(MessageIngestEvent::ImapAppend) => 284,
-            EventType::MessageIngest(MessageIngestEvent::JmapAppend) => 285,
-            EventType::MessageIngest(MessageIngestEvent::Spam) => 286,
-            EventType::Milter(MilterEvent::ActionAccept) => 287,
-            EventType::Milter(MilterEvent::ActionConnectionFailure) => 288,
-            EventType::Milter(MilterEvent::ActionDiscard) => 289,
-            EventType::Milter(MilterEvent::ActionReject) => 290,
-            EventType::Milter(MilterEvent::ActionReplyCode) => 291,
-            EventType::Milter(MilterEvent::ActionShutdown) => 292,
-            EventType::Milter(MilterEvent::ActionTempFail) => 293,
-            EventType::Milter(MilterEvent::Disconnected) => 294,
-            EventType::Milter(MilterEvent::FrameInvalid) => 295,
-            EventType::Milter(MilterEvent::FrameTooLarge) => 296,
-            EventType::Milter(MilterEvent::IoError) => 297,
-            EventType::Milter(MilterEvent::ParseError) => 298,
-            EventType::Milter(MilterEvent::Read) => 299,
-            EventType::Milter(MilterEvent::Timeout) => 300,
-            EventType::Milter(MilterEvent::TlsInvalidName) => 301,
-            EventType::Milter(MilterEvent::UnexpectedResponse) => 302,
-            EventType::Milter(MilterEvent::Write) => 303,
-            EventType::MtaHook(MtaHookEvent::ActionAccept) => 304,
-            EventType::MtaHook(MtaHookEvent::ActionDiscard) => 305,
-            EventType::MtaHook(MtaHookEvent::ActionQuarantine) => 306,
-            EventType::MtaHook(MtaHookEvent::ActionReject) => 307,
-            EventType::MtaHook(MtaHookEvent::Error) => 308,
-            EventType::MtaSts(MtaStsEvent::Authorized) => 309,
-            EventType::MtaSts(MtaStsEvent::InvalidPolicy) => 310,
-            EventType::MtaSts(MtaStsEvent::NotAuthorized) => 311,
-            EventType::MtaSts(MtaStsEvent::PolicyFetch) => 312,
-            EventType::MtaSts(MtaStsEvent::PolicyFetchError) => 313,
-            EventType::MtaSts(MtaStsEvent::PolicyNotFound) => 314,
-            EventType::Network(NetworkEvent::AcceptError) => 315,
-            EventType::Network(NetworkEvent::BindError) => 316,
-            EventType::Network(NetworkEvent::Closed) => 317,
-            EventType::Security(SecurityEvent::IpBlocked) => 318,
-            EventType::Network(NetworkEvent::FlushError) => 319,
-            EventType::Network(NetworkEvent::ListenError) => 320,
-            EventType::Network(NetworkEvent::ListenStart) => 321,
-            EventType::Network(NetworkEvent::ListenStop) => 322,
-            EventType::Network(NetworkEvent::ProxyError) => 323,
-            EventType::Network(NetworkEvent::ReadError) => 324,
-            EventType::Network(NetworkEvent::SetOptError) => 325,
-            EventType::Network(NetworkEvent::SplitError) => 326,
-            EventType::Network(NetworkEvent::Timeout) => 327,
-            EventType::Network(NetworkEvent::WriteError) => 328,
-            EventType::OutgoingReport(OutgoingReportEvent::DkimRateLimited) => 329,
-            EventType::OutgoingReport(OutgoingReportEvent::DkimReport) => 330,
-            EventType::OutgoingReport(OutgoingReportEvent::DmarcAggregateReport) => 331,
-            EventType::OutgoingReport(OutgoingReportEvent::DmarcRateLimited) => 332,
-            EventType::OutgoingReport(OutgoingReportEvent::DmarcReport) => 333,
-            EventType::OutgoingReport(OutgoingReportEvent::HttpSubmission) => 334,
-            EventType::OutgoingReport(OutgoingReportEvent::Locked) => 337,
-            EventType::OutgoingReport(OutgoingReportEvent::NoRecipientsFound) => 338,
-            EventType::OutgoingReport(OutgoingReportEvent::NotFound) => 339,
-            EventType::OutgoingReport(OutgoingReportEvent::ReportingAddressValidationError) => 340,
-            EventType::OutgoingReport(OutgoingReportEvent::SpfRateLimited) => 341,
-            EventType::OutgoingReport(OutgoingReportEvent::SpfReport) => 342,
-            EventType::OutgoingReport(OutgoingReportEvent::SubmissionError) => 343,
-            EventType::OutgoingReport(OutgoingReportEvent::TlsAggregate) => 344,
-            EventType::OutgoingReport(OutgoingReportEvent::UnauthorizedReportingAddress) => 345,
-            EventType::Pop3(Pop3Event::Capabilities) => 346,
-            EventType::Pop3(Pop3Event::ConnectionEnd) => 347,
-            EventType::Pop3(Pop3Event::ConnectionStart) => 348,
-            EventType::Pop3(Pop3Event::Delete) => 349,
-            EventType::Pop3(Pop3Event::Error) => 350,
-            EventType::Pop3(Pop3Event::Fetch) => 351,
-            EventType::Pop3(Pop3Event::List) => 352,
-            EventType::Pop3(Pop3Event::ListMessage) => 353,
-            EventType::Pop3(Pop3Event::Noop) => 354,
-            EventType::Pop3(Pop3Event::Quit) => 355,
-            EventType::Pop3(Pop3Event::RawInput) => 356,
-            EventType::Pop3(Pop3Event::RawOutput) => 357,
-            EventType::Pop3(Pop3Event::Reset) => 358,
-            EventType::Pop3(Pop3Event::StartTls) => 359,
-            EventType::Pop3(Pop3Event::Stat) => 360,
-            EventType::Pop3(Pop3Event::Uidl) => 361,
-            EventType::Pop3(Pop3Event::UidlMessage) => 362,
-            EventType::Pop3(Pop3Event::Utf8) => 363,
-            EventType::Purge(PurgeEvent::AutoExpunge) => 364,
-            EventType::Purge(PurgeEvent::Error) => 365,
-            EventType::Purge(PurgeEvent::Finished) => 366,
-            EventType::Purge(PurgeEvent::InProgress) => 367,
-            EventType::Purge(PurgeEvent::Running) => 368,
-            EventType::Purge(PurgeEvent::Started) => 369,
-            EventType::Purge(PurgeEvent::TombstoneCleanup) => 370,
-            EventType::PushSubscription(PushSubscriptionEvent::Error) => 371,
-            EventType::PushSubscription(PushSubscriptionEvent::NotFound) => 372,
-            EventType::PushSubscription(PushSubscriptionEvent::Success) => 373,
-            EventType::Queue(QueueEvent::BlobNotFound) => 374,
-            EventType::Queue(QueueEvent::ConcurrencyLimitExceeded) => 375,
-            EventType::Queue(QueueEvent::Locked) => 377,
-            EventType::Queue(QueueEvent::QueueAutogenerated) => 378,
-            EventType::Queue(QueueEvent::QueueDsn) => 379,
-            EventType::Queue(QueueEvent::QueueMessage) => 380,
-            EventType::Queue(QueueEvent::QueueMessageAuthenticated) => 381,
-            EventType::Queue(QueueEvent::QueueReport) => 382,
-            EventType::Queue(QueueEvent::QuotaExceeded) => 383,
-            EventType::Queue(QueueEvent::RateLimitExceeded) => 384,
-            EventType::Queue(QueueEvent::Rescheduled) => 385,
-            EventType::Resource(ResourceEvent::BadParameters) => 386,
-            EventType::Resource(ResourceEvent::DownloadExternal) => 387,
-            EventType::Resource(ResourceEvent::Error) => 388,
-            EventType::Resource(ResourceEvent::NotFound) => 389,
-            EventType::Resource(ResourceEvent::WebadminUnpacked) => 390,
-            EventType::Server(ServerEvent::Licensing) => 391,
-            EventType::Server(ServerEvent::Shutdown) => 392,
-            EventType::Server(ServerEvent::Startup) => 393,
-            EventType::Server(ServerEvent::StartupError) => 394,
-            EventType::Server(ServerEvent::ThreadError) => 395,
-            EventType::Sieve(SieveEvent::ActionAccept) => 396,
-            EventType::Sieve(SieveEvent::ActionAcceptReplace) => 397,
-            EventType::Sieve(SieveEvent::ActionDiscard) => 398,
-            EventType::Sieve(SieveEvent::ActionReject) => 399,
-            EventType::Sieve(SieveEvent::ListNotFound) => 400,
-            EventType::Sieve(SieveEvent::MessageTooLarge) => 401,
-            EventType::Sieve(SieveEvent::NotSupported) => 402,
-            EventType::Sieve(SieveEvent::QuotaExceeded) => 403,
-            EventType::Sieve(SieveEvent::RuntimeError) => 404,
-            EventType::Sieve(SieveEvent::ScriptNotFound) => 405,
-            EventType::Sieve(SieveEvent::SendMessage) => 406,
-            EventType::Sieve(SieveEvent::UnexpectedError) => 407,
-            EventType::Smtp(SmtpEvent::AlreadyAuthenticated) => 408,
-            EventType::Smtp(SmtpEvent::ArcFail) => 409,
-            EventType::Smtp(SmtpEvent::ArcPass) => 410,
-            EventType::Smtp(SmtpEvent::AuthExchangeTooLong) => 411,
-            EventType::Smtp(SmtpEvent::AuthMechanismNotSupported) => 412,
-            EventType::Smtp(SmtpEvent::AuthNotAllowed) => 413,
-            EventType::Smtp(SmtpEvent::CommandNotImplemented) => 414,
-            EventType::Smtp(SmtpEvent::ConcurrencyLimitExceeded) => 415,
-            EventType::Smtp(SmtpEvent::ConnectionEnd) => 416,
-            EventType::Smtp(SmtpEvent::ConnectionStart) => 417,
-            EventType::Smtp(SmtpEvent::DeliverByDisabled) => 418,
-            EventType::Smtp(SmtpEvent::DeliverByInvalid) => 419,
-            EventType::Smtp(SmtpEvent::DidNotSayEhlo) => 420,
-            EventType::Smtp(SmtpEvent::DkimFail) => 421,
-            EventType::Smtp(SmtpEvent::DkimPass) => 422,
-            EventType::Smtp(SmtpEvent::DmarcFail) => 423,
-            EventType::Smtp(SmtpEvent::DmarcPass) => 424,
-            EventType::Smtp(SmtpEvent::DsnDisabled) => 425,
-            EventType::Smtp(SmtpEvent::Ehlo) => 426,
-            EventType::Smtp(SmtpEvent::EhloExpected) => 427,
-            EventType::Smtp(SmtpEvent::Error) => 428,
-            EventType::Smtp(SmtpEvent::Expn) => 429,
-            EventType::Smtp(SmtpEvent::ExpnDisabled) => 430,
-            EventType::Smtp(SmtpEvent::ExpnNotFound) => 431,
-            EventType::Smtp(SmtpEvent::FutureReleaseDisabled) => 432,
-            EventType::Smtp(SmtpEvent::FutureReleaseInvalid) => 433,
-            EventType::Smtp(SmtpEvent::Help) => 434,
-            EventType::Smtp(SmtpEvent::InvalidCommand) => 435,
-            EventType::Smtp(SmtpEvent::InvalidEhlo) => 436,
-            EventType::Smtp(SmtpEvent::InvalidParameter) => 437,
-            EventType::Smtp(SmtpEvent::InvalidRecipientAddress) => 438,
-            EventType::Smtp(SmtpEvent::InvalidSenderAddress) => 439,
-            EventType::Smtp(SmtpEvent::IprevFail) => 440,
-            EventType::Smtp(SmtpEvent::IprevPass) => 441,
-            EventType::Smtp(SmtpEvent::LhloExpected) => 442,
-            EventType::Smtp(SmtpEvent::LoopDetected) => 443,
-            EventType::Smtp(SmtpEvent::MailFrom) => 444,
-            EventType::Smtp(SmtpEvent::MailFromMissing) => 445,
-            EventType::Smtp(SmtpEvent::MailFromRewritten) => 446,
-            EventType::Smtp(SmtpEvent::MailFromUnauthenticated) => 447,
-            EventType::Smtp(SmtpEvent::MailFromUnauthorized) => 448,
-            EventType::Smtp(SmtpEvent::MailboxDoesNotExist) => 449,
-            EventType::Smtp(SmtpEvent::MessageParseFailed) => 450,
-            EventType::Smtp(SmtpEvent::MessageTooLarge) => 451,
-            EventType::Smtp(SmtpEvent::MissingAuthDirectory) => 452,
-            EventType::Smtp(SmtpEvent::MissingLocalHostname) => 453,
-            EventType::Smtp(SmtpEvent::MtPriorityDisabled) => 454,
-            EventType::Smtp(SmtpEvent::MtPriorityInvalid) => 455,
-            EventType::Smtp(SmtpEvent::MultipleMailFrom) => 456,
-            EventType::Smtp(SmtpEvent::Noop) => 457,
-            EventType::Smtp(SmtpEvent::Quit) => 460,
-            EventType::Smtp(SmtpEvent::RateLimitExceeded) => 461,
-            EventType::Smtp(SmtpEvent::RawInput) => 462,
-            EventType::Smtp(SmtpEvent::RawOutput) => 463,
-            EventType::Smtp(SmtpEvent::RcptTo) => 464,
-            EventType::Smtp(SmtpEvent::RcptToDuplicate) => 465,
-            EventType::Smtp(SmtpEvent::RcptToMissing) => 466,
-            EventType::Smtp(SmtpEvent::RcptToRewritten) => 467,
-            EventType::Smtp(SmtpEvent::RelayNotAllowed) => 468,
-            EventType::Smtp(SmtpEvent::IdNotFound) => 469,
-            EventType::Smtp(SmtpEvent::RequestTooLarge) => 470,
-            EventType::Smtp(SmtpEvent::RequireTlsDisabled) => 471,
-            EventType::Smtp(SmtpEvent::Rset) => 472,
-            EventType::Smtp(SmtpEvent::SpfEhloFail) => 473,
-            EventType::Smtp(SmtpEvent::SpfEhloPass) => 474,
-            EventType::Smtp(SmtpEvent::SpfFromFail) => 475,
-            EventType::Smtp(SmtpEvent::SpfFromPass) => 476,
-            EventType::Smtp(SmtpEvent::StartTls) => 477,
-            EventType::Smtp(SmtpEvent::StartTlsAlready) => 478,
-            EventType::Smtp(SmtpEvent::StartTlsUnavailable) => 479,
-            EventType::Smtp(SmtpEvent::SyntaxError) => 480,
-            EventType::Smtp(SmtpEvent::TimeLimitExceeded) => 481,
-            EventType::Smtp(SmtpEvent::TooManyInvalidRcpt) => 482,
-            EventType::Smtp(SmtpEvent::TooManyMessages) => 483,
-            EventType::Smtp(SmtpEvent::TooManyRecipients) => 484,
-            EventType::Smtp(SmtpEvent::TransferLimitExceeded) => 485,
-            EventType::Smtp(SmtpEvent::UnsupportedParameter) => 486,
-            EventType::Smtp(SmtpEvent::Vrfy) => 487,
-            EventType::Smtp(SmtpEvent::VrfyDisabled) => 488,
-            EventType::Smtp(SmtpEvent::VrfyNotFound) => 489,
-            EventType::Spam(SpamEvent::Classify) => 490,
-            EventType::Spam(SpamEvent::ClassifyError) => 491,
-            EventType::Store(StoreEvent::HttpStoreFetch) => 492,
-            EventType::Store(StoreEvent::HttpStoreError) => 493,
-            EventType::Spam(SpamEvent::PyzorError) => 494,
-            EventType::Spam(SpamEvent::Train) => 495,
-            EventType::Spam(SpamEvent::TrainBalance) => 496,
-            EventType::Spam(SpamEvent::TrainError) => 497,
-            EventType::Spf(SpfEvent::Fail) => 498,
-            EventType::Spf(SpfEvent::Neutral) => 499,
-            EventType::Spf(SpfEvent::None) => 500,
-            EventType::Spf(SpfEvent::Pass) => 501,
-            EventType::Spf(SpfEvent::PermError) => 502,
-            EventType::Spf(SpfEvent::SoftFail) => 503,
-            EventType::Spf(SpfEvent::TempError) => 504,
-            EventType::Store(StoreEvent::AssertValueFailed) => 505,
-            EventType::Store(StoreEvent::BlobDelete) => 506,
-            EventType::Store(StoreEvent::BlobMissingMarker) => 507,
-            EventType::Store(StoreEvent::BlobRead) => 508,
-            EventType::Store(StoreEvent::BlobWrite) => 509,
-            EventType::Store(StoreEvent::CryptoError) => 510,
-            EventType::Store(StoreEvent::DataCorruption) => 511,
-            EventType::Store(StoreEvent::DataIterate) => 512,
-            EventType::Store(StoreEvent::DataWrite) => 513,
-            EventType::Store(StoreEvent::DecompressError) => 514,
-            EventType::Store(StoreEvent::DeserializeError) => 515,
-            EventType::Store(StoreEvent::ElasticsearchError) => 516,
-            EventType::Store(StoreEvent::FilesystemError) => 517,
-            EventType::Store(StoreEvent::FoundationdbError) => 518,
-            EventType::Store(StoreEvent::LdapWarning) => 519,
-            EventType::Store(StoreEvent::LdapError) => 520,
-            EventType::Store(StoreEvent::LdapQuery) => 521,
-            EventType::Store(StoreEvent::MysqlError) => 522,
-            EventType::Store(StoreEvent::NotConfigured) => 523,
-            EventType::Store(StoreEvent::NotFound) => 524,
-            EventType::Store(StoreEvent::NotSupported) => 525,
-            EventType::Store(StoreEvent::PoolError) => 526,
-            EventType::Store(StoreEvent::PostgresqlError) => 527,
-            EventType::Store(StoreEvent::RedisError) => 528,
-            EventType::Store(StoreEvent::RocksdbError) => 529,
-            EventType::Store(StoreEvent::S3Error) => 530,
-            EventType::Store(StoreEvent::SqlQuery) => 531,
-            EventType::Store(StoreEvent::SqliteError) => 532,
-            EventType::Store(StoreEvent::UnexpectedError) => 533,
-            EventType::Telemetry(TelemetryEvent::JournalError) => 534,
-            EventType::Telemetry(TelemetryEvent::LogError) => 535,
-            EventType::Telemetry(TelemetryEvent::OtelExporterError) => 536,
-            EventType::Telemetry(TelemetryEvent::OtelMetricsExporterError) => 537,
-            EventType::Telemetry(TelemetryEvent::PrometheusExporterError) => 538,
-            EventType::Telemetry(TelemetryEvent::WebhookError) => 539,
-            EventType::TlsRpt(TlsRptEvent::RecordFetch) => 540,
-            EventType::TlsRpt(TlsRptEvent::RecordFetchError) => 541,
-            EventType::Tls(TlsEvent::CertificateNotFound) => 542,
-            EventType::Tls(TlsEvent::Handshake) => 543,
-            EventType::Tls(TlsEvent::HandshakeError) => 544,
-            EventType::Tls(TlsEvent::MultipleCertificatesAvailable) => 545,
-            EventType::Tls(TlsEvent::NoCertificatesAvailable) => 546,
-            EventType::Tls(TlsEvent::NotConfigured) => 547,
-            EventType::Telemetry(TelemetryEvent::Alert) => 548,
-            EventType::Security(SecurityEvent::AbuseBan) => 549,
-            EventType::Security(SecurityEvent::LoiterBan) => 550,
-            EventType::Smtp(SmtpEvent::MailFromNotAllowed) => 551,
-            EventType::Security(SecurityEvent::Unauthorized) => 552,
-            EventType::Limit(LimitEvent::TenantQuota) => 553,
-            EventType::Auth(AuthEvent::TokenExpired) => 554,
-            EventType::Auth(AuthEvent::ClientRegistration) => 555,
-            EventType::Ai(AiEvent::LlmResponse) => 556,
-            EventType::Ai(AiEvent::ApiError) => 557,
-            EventType::Security(SecurityEvent::ScanBan) => 558,
-            EventType::Store(StoreEvent::AzureError) => 559,
-            EventType::TlsRpt(TlsRptEvent::RecordNotFound) => 560,
-            EventType::Smtp(SmtpEvent::RcptToGreylisted) => 561,
-            EventType::Spam(SpamEvent::Dnsbl) => 562,
-            EventType::Spam(SpamEvent::DnsblError) => 563,
-            EventType::Spam(SpamEvent::Pyzor) => 564,
-            EventType::Queue(QueueEvent::BackPressure) => 48,
-            EventType::Imap(ImapEvent::GetQuota) => 57,
-            EventType::WebDav(WebDavEvent::Propfind) => 147,
-            EventType::WebDav(WebDavEvent::Proppatch) => 148,
-            EventType::WebDav(WebDavEvent::Get) => 335,
-            EventType::WebDav(WebDavEvent::Report) => 336,
-            EventType::WebDav(WebDavEvent::Mkcol) => 376,
-            EventType::WebDav(WebDavEvent::Delete) => 458,
-            EventType::WebDav(WebDavEvent::Put) => 459,
-            EventType::WebDav(WebDavEvent::Post) => 565,
-            EventType::WebDav(WebDavEvent::Patch) => 566,
-            EventType::WebDav(WebDavEvent::Copy) => 567,
-            EventType::WebDav(WebDavEvent::Move) => 568,
-            EventType::WebDav(WebDavEvent::Lock) => 569,
-            EventType::WebDav(WebDavEvent::Unlock) => 570,
-            EventType::WebDav(WebDavEvent::Acl) => 571,
-            EventType::WebDav(WebDavEvent::Error) => 572,
-            EventType::WebDav(WebDavEvent::Options) => 573,
-            EventType::WebDav(WebDavEvent::Head) => 574,
-            EventType::WebDav(WebDavEvent::Mkcalendar) => 575,
-            EventType::Calendar(CalendarEvent::RuleExpansionError) => 576,
-            EventType::Store(StoreEvent::CacheMiss) => 50,
-            EventType::Store(StoreEvent::CacheHit) => 51,
-            EventType::Store(StoreEvent::CacheStale) => 52,
-            EventType::Store(StoreEvent::CacheUpdate) => 577,
-            EventType::TaskQueue(TaskQueueEvent::TaskAcquired) => 578,
-            EventType::Calendar(CalendarEvent::AlarmSent) => 579,
-            EventType::Calendar(CalendarEvent::AlarmSkipped) => 580,
-            EventType::Calendar(CalendarEvent::AlarmRecipientOverride) => 581,
-            EventType::Calendar(CalendarEvent::AlarmFailed) => 582,
-            EventType::Calendar(CalendarEvent::ItipMessageSent) => 583,
-            EventType::Calendar(CalendarEvent::ItipMessageReceived) => 584,
-            EventType::Calendar(CalendarEvent::ItipMessageError) => 585,
-        }
-    }
-
-    pub fn from_code(code: u64) -> Option<Self> {
-        match code {
-            0 => Some(EventType::Acme(AcmeEvent::AuthCompleted)),
-            1 => Some(EventType::Acme(AcmeEvent::AuthError)),
-            2 => Some(EventType::Acme(AcmeEvent::AuthPending)),
-            3 => Some(EventType::Acme(AcmeEvent::AuthStart)),
-            4 => Some(EventType::Acme(AcmeEvent::AuthTooManyAttempts)),
-            5 => Some(EventType::Acme(AcmeEvent::AuthValid)),
-            6 => Some(EventType::Acme(AcmeEvent::ClientMissingSni)),
-            7 => Some(EventType::Acme(AcmeEvent::ClientSuppliedSni)),
-            8 => Some(EventType::Acme(AcmeEvent::DnsRecordCreated)),
-            9 => Some(EventType::Acme(AcmeEvent::DnsRecordCreationFailed)),
-            10 => Some(EventType::Acme(AcmeEvent::DnsRecordDeletionFailed)),
-            11 => Some(EventType::Acme(AcmeEvent::DnsRecordLookupFailed)),
-            12 => Some(EventType::Acme(AcmeEvent::DnsRecordNotPropagated)),
-            13 => Some(EventType::Acme(AcmeEvent::DnsRecordPropagated)),
-            14 => Some(EventType::Acme(AcmeEvent::DnsRecordPropagationTimeout)),
-            15 => Some(EventType::Acme(AcmeEvent::Error)),
-            16 => Some(EventType::Acme(AcmeEvent::OrderCompleted)),
-            17 => Some(EventType::Acme(AcmeEvent::OrderInvalid)),
-            18 => Some(EventType::Acme(AcmeEvent::OrderProcessing)),
-            19 => Some(EventType::Acme(AcmeEvent::OrderReady)),
-            20 => Some(EventType::Acme(AcmeEvent::OrderStart)),
-            21 => Some(EventType::Acme(AcmeEvent::OrderValid)),
-            22 => Some(EventType::Acme(AcmeEvent::ProcessCert)),
-            23 => Some(EventType::Acme(AcmeEvent::RenewBackoff)),
-            24 => Some(EventType::Acme(AcmeEvent::TlsAlpnError)),
-            25 => Some(EventType::Acme(AcmeEvent::TlsAlpnReceived)),
-            26 => Some(EventType::Acme(AcmeEvent::TokenNotFound)),
-            27 => Some(EventType::Arc(ArcEvent::BrokenChain)),
-            28 => Some(EventType::Arc(ArcEvent::ChainTooLong)),
-            29 => Some(EventType::Arc(ArcEvent::HasHeaderTag)),
-            30 => Some(EventType::Arc(ArcEvent::InvalidCv)),
-            31 => Some(EventType::Arc(ArcEvent::InvalidInstance)),
-            32 => Some(EventType::Arc(ArcEvent::SealerNotFound)),
-            33 => Some(EventType::Security(SecurityEvent::AuthenticationBan)),
-            34 => Some(EventType::Auth(AuthEvent::Error)),
-            35 => Some(EventType::Auth(AuthEvent::Failed)),
-            36 => Some(EventType::Auth(AuthEvent::MissingTotp)),
-            37 => Some(EventType::Auth(AuthEvent::Success)),
-            38 => Some(EventType::Auth(AuthEvent::TooManyAttempts)),
-            39 => Some(EventType::Cluster(ClusterEvent::SubscriberStart)),
-            40 => Some(EventType::Cluster(ClusterEvent::SubscriberStop)),
-            41 => Some(EventType::Cluster(ClusterEvent::SubscriberError)),
-            42 => Some(EventType::Cluster(ClusterEvent::SubscriberDisconnected)),
-            43 => Some(EventType::Cluster(ClusterEvent::PublisherStart)),
-            44 => Some(EventType::Cluster(ClusterEvent::PublisherStop)),
-            45 => Some(EventType::Cluster(ClusterEvent::PublisherError)),
-            46 => Some(EventType::Cluster(ClusterEvent::MessageReceived)),
-            47 => Some(EventType::Cluster(ClusterEvent::MessageSkipped)),
-            49 => Some(EventType::Cluster(ClusterEvent::MessageInvalid)),
-            53 => Some(EventType::Config(ConfigEvent::AlreadyUpToDate)),
-            54 => Some(EventType::Config(ConfigEvent::BuildError)),
-            55 => Some(EventType::Config(ConfigEvent::BuildWarning)),
-            56 => Some(EventType::Config(ConfigEvent::DefaultApplied)),
-            58 => Some(EventType::Config(ConfigEvent::FetchError)),
-            59 => Some(EventType::Config(ConfigEvent::ImportExternal)),
-            60 => Some(EventType::Config(ConfigEvent::MacroError)),
-            61 => Some(EventType::Config(ConfigEvent::MissingSetting)),
-            62 => Some(EventType::Config(ConfigEvent::ParseError)),
-            63 => Some(EventType::Config(ConfigEvent::ParseWarning)),
-            64 => Some(EventType::Config(ConfigEvent::UnusedSetting)),
-            65 => Some(EventType::Config(ConfigEvent::WriteError)),
-            66 => Some(EventType::Dane(DaneEvent::AuthenticationFailure)),
-            67 => Some(EventType::Dane(DaneEvent::AuthenticationSuccess)),
-            68 => Some(EventType::Dane(DaneEvent::CertificateParseError)),
-            69 => Some(EventType::Dane(DaneEvent::NoCertificatesFound)),
-            70 => Some(EventType::Dane(DaneEvent::TlsaRecordFetch)),
-            71 => Some(EventType::Dane(DaneEvent::TlsaRecordFetchError)),
-            72 => Some(EventType::Dane(DaneEvent::TlsaRecordInvalid)),
-            73 => Some(EventType::Dane(DaneEvent::TlsaRecordMatch)),
-            74 => Some(EventType::Dane(DaneEvent::TlsaRecordNotDnssecSigned)),
-            75 => Some(EventType::Dane(DaneEvent::TlsaRecordNotFound)),
-            76 => Some(EventType::Delivery(DeliveryEvent::AttemptEnd)),
-            77 => Some(EventType::Delivery(DeliveryEvent::AttemptStart)),
-            78 => Some(EventType::Delivery(DeliveryEvent::Auth)),
-            79 => Some(EventType::Delivery(DeliveryEvent::AuthFailed)),
-            80 => Some(EventType::Delivery(DeliveryEvent::Completed)),
-            81 => Some(EventType::Delivery(DeliveryEvent::ConcurrencyLimitExceeded)),
-            82 => Some(EventType::Delivery(DeliveryEvent::Connect)),
-            83 => Some(EventType::Delivery(DeliveryEvent::ConnectError)),
-            84 => Some(EventType::Delivery(DeliveryEvent::Delivered)),
-            85 => Some(EventType::Delivery(DeliveryEvent::DomainDeliveryStart)),
-            86 => Some(EventType::Delivery(DeliveryEvent::DoubleBounce)),
-            87 => Some(EventType::Delivery(DeliveryEvent::DsnPermFail)),
-            88 => Some(EventType::Delivery(DeliveryEvent::DsnSuccess)),
-            89 => Some(EventType::Delivery(DeliveryEvent::DsnTempFail)),
-            90 => Some(EventType::Delivery(DeliveryEvent::Ehlo)),
-            91 => Some(EventType::Delivery(DeliveryEvent::EhloRejected)),
-            92 => Some(EventType::Delivery(DeliveryEvent::Failed)),
-            93 => Some(EventType::Delivery(DeliveryEvent::GreetingFailed)),
-            94 => Some(EventType::Delivery(DeliveryEvent::ImplicitTlsError)),
-            95 => Some(EventType::Delivery(DeliveryEvent::IpLookup)),
-            96 => Some(EventType::Delivery(DeliveryEvent::IpLookupFailed)),
-            97 => Some(EventType::Delivery(DeliveryEvent::MailFrom)),
-            98 => Some(EventType::Delivery(DeliveryEvent::MailFromRejected)),
-            99 => Some(EventType::Delivery(DeliveryEvent::MessageRejected)),
-            100 => Some(EventType::Delivery(DeliveryEvent::MissingOutboundHostname)),
-            101 => Some(EventType::Delivery(DeliveryEvent::MxLookup)),
-            102 => Some(EventType::Delivery(DeliveryEvent::MxLookupFailed)),
-            103 => Some(EventType::Delivery(DeliveryEvent::NullMx)),
-            104 => Some(EventType::Delivery(DeliveryEvent::RateLimitExceeded)),
-            105 => Some(EventType::Delivery(DeliveryEvent::RawInput)),
-            106 => Some(EventType::Delivery(DeliveryEvent::RawOutput)),
-            107 => Some(EventType::Delivery(DeliveryEvent::RcptTo)),
-            108 => Some(EventType::Delivery(DeliveryEvent::RcptToFailed)),
-            109 => Some(EventType::Delivery(DeliveryEvent::RcptToRejected)),
-            110 => Some(EventType::Delivery(DeliveryEvent::StartTls)),
-            111 => Some(EventType::Delivery(DeliveryEvent::StartTlsDisabled)),
-            112 => Some(EventType::Delivery(DeliveryEvent::StartTlsError)),
-            113 => Some(EventType::Delivery(DeliveryEvent::StartTlsUnavailable)),
-            114 => Some(EventType::Dkim(DkimEvent::Fail)),
-            115 => Some(EventType::Dkim(DkimEvent::FailedAuidMatch)),
-            116 => Some(EventType::Dkim(DkimEvent::FailedBodyHashMatch)),
-            117 => Some(EventType::Dkim(DkimEvent::FailedVerification)),
-            118 => Some(EventType::Dkim(DkimEvent::IncompatibleAlgorithms)),
-            119 => Some(EventType::Dkim(DkimEvent::Neutral)),
-            120 => Some(EventType::Dkim(DkimEvent::None)),
-            121 => Some(EventType::Dkim(DkimEvent::Pass)),
-            122 => Some(EventType::Dkim(DkimEvent::PermError)),
-            123 => Some(EventType::Dkim(DkimEvent::RevokedPublicKey)),
-            124 => Some(EventType::Dkim(DkimEvent::SignatureExpired)),
-            125 => Some(EventType::Dkim(DkimEvent::SignatureLength)),
-            126 => Some(EventType::Dkim(DkimEvent::SignerNotFound)),
-            127 => Some(EventType::Dkim(DkimEvent::TempError)),
-            128 => Some(EventType::Dkim(DkimEvent::UnsupportedAlgorithm)),
-            129 => Some(EventType::Dkim(DkimEvent::UnsupportedCanonicalization)),
-            130 => Some(EventType::Dkim(DkimEvent::UnsupportedKeyType)),
-            131 => Some(EventType::Dkim(DkimEvent::UnsupportedVersion)),
-            132 => Some(EventType::Dmarc(DmarcEvent::Fail)),
-            133 => Some(EventType::Dmarc(DmarcEvent::None)),
-            134 => Some(EventType::Dmarc(DmarcEvent::Pass)),
-            135 => Some(EventType::Dmarc(DmarcEvent::PermError)),
-            136 => Some(EventType::Dmarc(DmarcEvent::TempError)),
-            137 => Some(EventType::Eval(EvalEvent::DirectoryNotFound)),
-            138 => Some(EventType::Eval(EvalEvent::Error)),
-            139 => Some(EventType::Eval(EvalEvent::Result)),
-            140 => Some(EventType::Eval(EvalEvent::StoreNotFound)),
-            141 => Some(EventType::TaskQueue(TaskQueueEvent::BlobNotFound)),
-            142 => Some(EventType::MessageIngest(MessageIngestEvent::FtsIndex)),
-            143 => Some(EventType::Spam(SpamEvent::TrainAccount)),
-            144 => Some(EventType::TaskQueue(TaskQueueEvent::TaskLocked)),
-            145 => Some(EventType::TaskQueue(TaskQueueEvent::MetadataNotFound)),
-            146 => Some(EventType::Housekeeper(HousekeeperEvent::Run)),
-            149 => Some(EventType::Housekeeper(HousekeeperEvent::Schedule)),
-            150 => Some(EventType::Housekeeper(HousekeeperEvent::Start)),
-            151 => Some(EventType::Housekeeper(HousekeeperEvent::Stop)),
-            152 => Some(EventType::Http(HttpEvent::ConnectionEnd)),
-            153 => Some(EventType::Http(HttpEvent::ConnectionStart)),
-            154 => Some(EventType::Http(HttpEvent::Error)),
-            155 => Some(EventType::Http(HttpEvent::RequestBody)),
-            156 => Some(EventType::Http(HttpEvent::RequestUrl)),
-            157 => Some(EventType::Http(HttpEvent::ResponseBody)),
-            158 => Some(EventType::Http(HttpEvent::XForwardedMissing)),
-            159 => Some(EventType::Imap(ImapEvent::Append)),
-            160 => Some(EventType::Imap(ImapEvent::Capabilities)),
-            161 => Some(EventType::Imap(ImapEvent::Close)),
-            162 => Some(EventType::Imap(ImapEvent::ConnectionEnd)),
-            163 => Some(EventType::Imap(ImapEvent::ConnectionStart)),
-            164 => Some(EventType::Imap(ImapEvent::Copy)),
-            165 => Some(EventType::Imap(ImapEvent::CreateMailbox)),
-            166 => Some(EventType::Imap(ImapEvent::DeleteMailbox)),
-            167 => Some(EventType::Imap(ImapEvent::Enable)),
-            168 => Some(EventType::Imap(ImapEvent::Error)),
-            169 => Some(EventType::Imap(ImapEvent::Expunge)),
-            170 => Some(EventType::Imap(ImapEvent::Fetch)),
-            171 => Some(EventType::Imap(ImapEvent::GetAcl)),
-            172 => Some(EventType::Imap(ImapEvent::Id)),
-            173 => Some(EventType::Imap(ImapEvent::IdleStart)),
-            174 => Some(EventType::Imap(ImapEvent::IdleStop)),
-            175 => Some(EventType::Imap(ImapEvent::List)),
-            176 => Some(EventType::Imap(ImapEvent::ListRights)),
-            177 => Some(EventType::Imap(ImapEvent::Logout)),
-            178 => Some(EventType::Imap(ImapEvent::Lsub)),
-            179 => Some(EventType::Imap(ImapEvent::Move)),
-            180 => Some(EventType::Imap(ImapEvent::MyRights)),
-            181 => Some(EventType::Imap(ImapEvent::Namespace)),
-            182 => Some(EventType::Imap(ImapEvent::Noop)),
-            183 => Some(EventType::Imap(ImapEvent::RawInput)),
-            184 => Some(EventType::Imap(ImapEvent::RawOutput)),
-            185 => Some(EventType::Imap(ImapEvent::RenameMailbox)),
-            186 => Some(EventType::Imap(ImapEvent::Search)),
-            187 => Some(EventType::Imap(ImapEvent::Select)),
-            188 => Some(EventType::Imap(ImapEvent::SetAcl)),
-            189 => Some(EventType::Imap(ImapEvent::Sort)),
-            190 => Some(EventType::Imap(ImapEvent::Status)),
-            191 => Some(EventType::Imap(ImapEvent::Store)),
-            192 => Some(EventType::Imap(ImapEvent::Subscribe)),
-            193 => Some(EventType::Imap(ImapEvent::Thread)),
-            194 => Some(EventType::Imap(ImapEvent::Unsubscribe)),
-            195 => Some(EventType::IncomingReport(IncomingReportEvent::AbuseReport)),
-            196 => Some(EventType::IncomingReport(
-                IncomingReportEvent::ArfParseFailed,
-            )),
-            197 => Some(EventType::IncomingReport(
-                IncomingReportEvent::AuthFailureReport,
-            )),
-            198 => Some(EventType::IncomingReport(
-                IncomingReportEvent::DecompressError,
-            )),
-            199 => Some(EventType::IncomingReport(
-                IncomingReportEvent::DmarcParseFailed,
-            )),
-            200 => Some(EventType::IncomingReport(IncomingReportEvent::DmarcReport)),
-            201 => Some(EventType::IncomingReport(
-                IncomingReportEvent::DmarcReportWithWarnings,
-            )),
-            202 => Some(EventType::IncomingReport(IncomingReportEvent::FraudReport)),
-            203 => Some(EventType::IncomingReport(
-                IncomingReportEvent::MessageParseFailed,
-            )),
-            204 => Some(EventType::IncomingReport(
-                IncomingReportEvent::NotSpamReport,
-            )),
-            205 => Some(EventType::IncomingReport(IncomingReportEvent::OtherReport)),
-            206 => Some(EventType::IncomingReport(IncomingReportEvent::TlsReport)),
-            207 => Some(EventType::IncomingReport(
-                IncomingReportEvent::TlsReportWithWarnings,
-            )),
-            208 => Some(EventType::IncomingReport(
-                IncomingReportEvent::TlsRpcParseFailed,
-            )),
-            209 => Some(EventType::IncomingReport(IncomingReportEvent::VirusReport)),
-            210 => Some(EventType::Iprev(IprevEvent::Fail)),
-            211 => Some(EventType::Iprev(IprevEvent::None)),
-            212 => Some(EventType::Iprev(IprevEvent::Pass)),
-            213 => Some(EventType::Iprev(IprevEvent::PermError)),
-            214 => Some(EventType::Iprev(IprevEvent::TempError)),
-            215 => Some(EventType::Jmap(JmapEvent::AccountNotFound)),
-            216 => Some(EventType::Jmap(JmapEvent::AccountNotSupportedByMethod)),
-            217 => Some(EventType::Jmap(JmapEvent::AccountReadOnly)),
-            218 => Some(EventType::Jmap(JmapEvent::AnchorNotFound)),
-            219 => Some(EventType::Jmap(JmapEvent::CannotCalculateChanges)),
-            220 => Some(EventType::Jmap(JmapEvent::Forbidden)),
-            221 => Some(EventType::Jmap(JmapEvent::InvalidArguments)),
-            222 => Some(EventType::Jmap(JmapEvent::InvalidResultReference)),
-            223 => Some(EventType::Jmap(JmapEvent::MethodCall)),
-            224 => Some(EventType::Jmap(JmapEvent::NotFound)),
-            225 => Some(EventType::Jmap(JmapEvent::NotJson)),
-            226 => Some(EventType::Jmap(JmapEvent::NotRequest)),
-            227 => Some(EventType::Jmap(JmapEvent::RequestTooLarge)),
-            228 => Some(EventType::Jmap(JmapEvent::StateMismatch)),
-            229 => Some(EventType::Jmap(JmapEvent::UnknownCapability)),
-            230 => Some(EventType::Jmap(JmapEvent::UnknownDataType)),
-            231 => Some(EventType::Jmap(JmapEvent::UnknownMethod)),
-            232 => Some(EventType::Jmap(JmapEvent::UnsupportedFilter)),
-            233 => Some(EventType::Jmap(JmapEvent::UnsupportedSort)),
-            234 => Some(EventType::Jmap(JmapEvent::WebsocketError)),
-            235 => Some(EventType::Jmap(JmapEvent::WebsocketStart)),
-            236 => Some(EventType::Jmap(JmapEvent::WebsocketStop)),
-            237 => Some(EventType::Limit(LimitEvent::BlobQuota)),
-            238 => Some(EventType::Limit(LimitEvent::CallsIn)),
-            239 => Some(EventType::Limit(LimitEvent::ConcurrentConnection)),
-            240 => Some(EventType::Limit(LimitEvent::ConcurrentRequest)),
-            241 => Some(EventType::Limit(LimitEvent::ConcurrentUpload)),
-            242 => Some(EventType::Limit(LimitEvent::Quota)),
-            243 => Some(EventType::Limit(LimitEvent::SizeRequest)),
-            244 => Some(EventType::Limit(LimitEvent::SizeUpload)),
-            245 => Some(EventType::Limit(LimitEvent::TooManyRequests)),
-            246 => Some(EventType::MailAuth(MailAuthEvent::Base64)),
-            247 => Some(EventType::MailAuth(MailAuthEvent::Crypto)),
-            248 => Some(EventType::MailAuth(MailAuthEvent::DnsError)),
-            249 => Some(EventType::MailAuth(MailAuthEvent::DnsInvalidRecordType)),
-            250 => Some(EventType::MailAuth(MailAuthEvent::DnsRecordNotFound)),
-            251 => Some(EventType::MailAuth(MailAuthEvent::Io)),
-            252 => Some(EventType::MailAuth(MailAuthEvent::MissingParameters)),
-            253 => Some(EventType::MailAuth(MailAuthEvent::NoHeadersFound)),
-            254 => Some(EventType::MailAuth(MailAuthEvent::ParseError)),
-            255 => Some(EventType::MailAuth(MailAuthEvent::PolicyNotAligned)),
-            256 => Some(EventType::ManageSieve(ManageSieveEvent::Capabilities)),
-            257 => Some(EventType::ManageSieve(ManageSieveEvent::CheckScript)),
-            258 => Some(EventType::ManageSieve(ManageSieveEvent::ConnectionEnd)),
-            259 => Some(EventType::ManageSieve(ManageSieveEvent::ConnectionStart)),
-            260 => Some(EventType::ManageSieve(ManageSieveEvent::CreateScript)),
-            261 => Some(EventType::ManageSieve(ManageSieveEvent::DeleteScript)),
-            262 => Some(EventType::ManageSieve(ManageSieveEvent::Error)),
-            263 => Some(EventType::ManageSieve(ManageSieveEvent::GetScript)),
-            264 => Some(EventType::ManageSieve(ManageSieveEvent::HaveSpace)),
-            265 => Some(EventType::ManageSieve(ManageSieveEvent::ListScripts)),
-            266 => Some(EventType::ManageSieve(ManageSieveEvent::Logout)),
-            267 => Some(EventType::ManageSieve(ManageSieveEvent::Noop)),
-            268 => Some(EventType::ManageSieve(ManageSieveEvent::RawInput)),
-            269 => Some(EventType::ManageSieve(ManageSieveEvent::RawOutput)),
-            270 => Some(EventType::ManageSieve(ManageSieveEvent::RenameScript)),
-            271 => Some(EventType::ManageSieve(ManageSieveEvent::SetActive)),
-            272 => Some(EventType::ManageSieve(ManageSieveEvent::StartTls)),
-            273 => Some(EventType::ManageSieve(ManageSieveEvent::Unauthenticate)),
-            274 => Some(EventType::ManageSieve(ManageSieveEvent::UpdateScript)),
-            275 => Some(EventType::Manage(ManageEvent::AlreadyExists)),
-            276 => Some(EventType::Manage(ManageEvent::AssertFailed)),
-            277 => Some(EventType::Manage(ManageEvent::Error)),
-            278 => Some(EventType::Manage(ManageEvent::MissingParameter)),
-            279 => Some(EventType::Manage(ManageEvent::NotFound)),
-            280 => Some(EventType::Manage(ManageEvent::NotSupported)),
-            281 => Some(EventType::MessageIngest(MessageIngestEvent::Duplicate)),
-            282 => Some(EventType::MessageIngest(MessageIngestEvent::Error)),
-            283 => Some(EventType::MessageIngest(MessageIngestEvent::Ham)),
-            284 => Some(EventType::MessageIngest(MessageIngestEvent::ImapAppend)),
-            285 => Some(EventType::MessageIngest(MessageIngestEvent::JmapAppend)),
-            286 => Some(EventType::MessageIngest(MessageIngestEvent::Spam)),
-            287 => Some(EventType::Milter(MilterEvent::ActionAccept)),
-            288 => Some(EventType::Milter(MilterEvent::ActionConnectionFailure)),
-            289 => Some(EventType::Milter(MilterEvent::ActionDiscard)),
-            290 => Some(EventType::Milter(MilterEvent::ActionReject)),
-            291 => Some(EventType::Milter(MilterEvent::ActionReplyCode)),
-            292 => Some(EventType::Milter(MilterEvent::ActionShutdown)),
-            293 => Some(EventType::Milter(MilterEvent::ActionTempFail)),
-            294 => Some(EventType::Milter(MilterEvent::Disconnected)),
-            295 => Some(EventType::Milter(MilterEvent::FrameInvalid)),
-            296 => Some(EventType::Milter(MilterEvent::FrameTooLarge)),
-            297 => Some(EventType::Milter(MilterEvent::IoError)),
-            298 => Some(EventType::Milter(MilterEvent::ParseError)),
-            299 => Some(EventType::Milter(MilterEvent::Read)),
-            300 => Some(EventType::Milter(MilterEvent::Timeout)),
-            301 => Some(EventType::Milter(MilterEvent::TlsInvalidName)),
-            302 => Some(EventType::Milter(MilterEvent::UnexpectedResponse)),
-            303 => Some(EventType::Milter(MilterEvent::Write)),
-            304 => Some(EventType::MtaHook(MtaHookEvent::ActionAccept)),
-            305 => Some(EventType::MtaHook(MtaHookEvent::ActionDiscard)),
-            306 => Some(EventType::MtaHook(MtaHookEvent::ActionQuarantine)),
-            307 => Some(EventType::MtaHook(MtaHookEvent::ActionReject)),
-            308 => Some(EventType::MtaHook(MtaHookEvent::Error)),
-            309 => Some(EventType::MtaSts(MtaStsEvent::Authorized)),
-            310 => Some(EventType::MtaSts(MtaStsEvent::InvalidPolicy)),
-            311 => Some(EventType::MtaSts(MtaStsEvent::NotAuthorized)),
-            312 => Some(EventType::MtaSts(MtaStsEvent::PolicyFetch)),
-            313 => Some(EventType::MtaSts(MtaStsEvent::PolicyFetchError)),
-            314 => Some(EventType::MtaSts(MtaStsEvent::PolicyNotFound)),
-            315 => Some(EventType::Network(NetworkEvent::AcceptError)),
-            316 => Some(EventType::Network(NetworkEvent::BindError)),
-            317 => Some(EventType::Network(NetworkEvent::Closed)),
-            318 => Some(EventType::Security(SecurityEvent::IpBlocked)),
-            319 => Some(EventType::Network(NetworkEvent::FlushError)),
-            320 => Some(EventType::Network(NetworkEvent::ListenError)),
-            321 => Some(EventType::Network(NetworkEvent::ListenStart)),
-            322 => Some(EventType::Network(NetworkEvent::ListenStop)),
-            323 => Some(EventType::Network(NetworkEvent::ProxyError)),
-            324 => Some(EventType::Network(NetworkEvent::ReadError)),
-            325 => Some(EventType::Network(NetworkEvent::SetOptError)),
-            326 => Some(EventType::Network(NetworkEvent::SplitError)),
-            327 => Some(EventType::Network(NetworkEvent::Timeout)),
-            328 => Some(EventType::Network(NetworkEvent::WriteError)),
-            329 => Some(EventType::OutgoingReport(
-                OutgoingReportEvent::DkimRateLimited,
-            )),
-            330 => Some(EventType::OutgoingReport(OutgoingReportEvent::DkimReport)),
-            331 => Some(EventType::OutgoingReport(
-                OutgoingReportEvent::DmarcAggregateReport,
-            )),
-            332 => Some(EventType::OutgoingReport(
-                OutgoingReportEvent::DmarcRateLimited,
-            )),
-            333 => Some(EventType::OutgoingReport(OutgoingReportEvent::DmarcReport)),
-            334 => Some(EventType::OutgoingReport(
-                OutgoingReportEvent::HttpSubmission,
-            )),
-            337 => Some(EventType::OutgoingReport(OutgoingReportEvent::Locked)),
-            338 => Some(EventType::OutgoingReport(
-                OutgoingReportEvent::NoRecipientsFound,
-            )),
-            339 => Some(EventType::OutgoingReport(OutgoingReportEvent::NotFound)),
-            340 => Some(EventType::OutgoingReport(
-                OutgoingReportEvent::ReportingAddressValidationError,
-            )),
-            341 => Some(EventType::OutgoingReport(
-                OutgoingReportEvent::SpfRateLimited,
-            )),
-            342 => Some(EventType::OutgoingReport(OutgoingReportEvent::SpfReport)),
-            343 => Some(EventType::OutgoingReport(
-                OutgoingReportEvent::SubmissionError,
-            )),
-            344 => Some(EventType::OutgoingReport(OutgoingReportEvent::TlsAggregate)),
-            345 => Some(EventType::OutgoingReport(
-                OutgoingReportEvent::UnauthorizedReportingAddress,
-            )),
-            346 => Some(EventType::Pop3(Pop3Event::Capabilities)),
-            347 => Some(EventType::Pop3(Pop3Event::ConnectionEnd)),
-            348 => Some(EventType::Pop3(Pop3Event::ConnectionStart)),
-            349 => Some(EventType::Pop3(Pop3Event::Delete)),
-            350 => Some(EventType::Pop3(Pop3Event::Error)),
-            351 => Some(EventType::Pop3(Pop3Event::Fetch)),
-            352 => Some(EventType::Pop3(Pop3Event::List)),
-            353 => Some(EventType::Pop3(Pop3Event::ListMessage)),
-            354 => Some(EventType::Pop3(Pop3Event::Noop)),
-            355 => Some(EventType::Pop3(Pop3Event::Quit)),
-            356 => Some(EventType::Pop3(Pop3Event::RawInput)),
-            357 => Some(EventType::Pop3(Pop3Event::RawOutput)),
-            358 => Some(EventType::Pop3(Pop3Event::Reset)),
-            359 => Some(EventType::Pop3(Pop3Event::StartTls)),
-            360 => Some(EventType::Pop3(Pop3Event::Stat)),
-            361 => Some(EventType::Pop3(Pop3Event::Uidl)),
-            362 => Some(EventType::Pop3(Pop3Event::UidlMessage)),
-            363 => Some(EventType::Pop3(Pop3Event::Utf8)),
-            364 => Some(EventType::Purge(PurgeEvent::AutoExpunge)),
-            365 => Some(EventType::Purge(PurgeEvent::Error)),
-            366 => Some(EventType::Purge(PurgeEvent::Finished)),
-            367 => Some(EventType::Purge(PurgeEvent::InProgress)),
-            368 => Some(EventType::Purge(PurgeEvent::Running)),
-            369 => Some(EventType::Purge(PurgeEvent::Started)),
-            370 => Some(EventType::Purge(PurgeEvent::TombstoneCleanup)),
-            371 => Some(EventType::PushSubscription(PushSubscriptionEvent::Error)),
-            372 => Some(EventType::PushSubscription(PushSubscriptionEvent::NotFound)),
-            373 => Some(EventType::PushSubscription(PushSubscriptionEvent::Success)),
-            374 => Some(EventType::Queue(QueueEvent::BlobNotFound)),
-            375 => Some(EventType::Queue(QueueEvent::ConcurrencyLimitExceeded)),
-            377 => Some(EventType::Queue(QueueEvent::Locked)),
-            378 => Some(EventType::Queue(QueueEvent::QueueAutogenerated)),
-            379 => Some(EventType::Queue(QueueEvent::QueueDsn)),
-            380 => Some(EventType::Queue(QueueEvent::QueueMessage)),
-            381 => Some(EventType::Queue(QueueEvent::QueueMessageAuthenticated)),
-            382 => Some(EventType::Queue(QueueEvent::QueueReport)),
-            383 => Some(EventType::Queue(QueueEvent::QuotaExceeded)),
-            384 => Some(EventType::Queue(QueueEvent::RateLimitExceeded)),
-            385 => Some(EventType::Queue(QueueEvent::Rescheduled)),
-            386 => Some(EventType::Resource(ResourceEvent::BadParameters)),
-            387 => Some(EventType::Resource(ResourceEvent::DownloadExternal)),
-            388 => Some(EventType::Resource(ResourceEvent::Error)),
-            389 => Some(EventType::Resource(ResourceEvent::NotFound)),
-            390 => Some(EventType::Resource(ResourceEvent::WebadminUnpacked)),
-            391 => Some(EventType::Server(ServerEvent::Licensing)),
-            392 => Some(EventType::Server(ServerEvent::Shutdown)),
-            393 => Some(EventType::Server(ServerEvent::Startup)),
-            394 => Some(EventType::Server(ServerEvent::StartupError)),
-            395 => Some(EventType::Server(ServerEvent::ThreadError)),
-            396 => Some(EventType::Sieve(SieveEvent::ActionAccept)),
-            397 => Some(EventType::Sieve(SieveEvent::ActionAcceptReplace)),
-            398 => Some(EventType::Sieve(SieveEvent::ActionDiscard)),
-            399 => Some(EventType::Sieve(SieveEvent::ActionReject)),
-            400 => Some(EventType::Sieve(SieveEvent::ListNotFound)),
-            401 => Some(EventType::Sieve(SieveEvent::MessageTooLarge)),
-            402 => Some(EventType::Sieve(SieveEvent::NotSupported)),
-            403 => Some(EventType::Sieve(SieveEvent::QuotaExceeded)),
-            404 => Some(EventType::Sieve(SieveEvent::RuntimeError)),
-            405 => Some(EventType::Sieve(SieveEvent::ScriptNotFound)),
-            406 => Some(EventType::Sieve(SieveEvent::SendMessage)),
-            407 => Some(EventType::Sieve(SieveEvent::UnexpectedError)),
-            408 => Some(EventType::Smtp(SmtpEvent::AlreadyAuthenticated)),
-            409 => Some(EventType::Smtp(SmtpEvent::ArcFail)),
-            410 => Some(EventType::Smtp(SmtpEvent::ArcPass)),
-            411 => Some(EventType::Smtp(SmtpEvent::AuthExchangeTooLong)),
-            412 => Some(EventType::Smtp(SmtpEvent::AuthMechanismNotSupported)),
-            413 => Some(EventType::Smtp(SmtpEvent::AuthNotAllowed)),
-            414 => Some(EventType::Smtp(SmtpEvent::CommandNotImplemented)),
-            415 => Some(EventType::Smtp(SmtpEvent::ConcurrencyLimitExceeded)),
-            416 => Some(EventType::Smtp(SmtpEvent::ConnectionEnd)),
-            417 => Some(EventType::Smtp(SmtpEvent::ConnectionStart)),
-            418 => Some(EventType::Smtp(SmtpEvent::DeliverByDisabled)),
-            419 => Some(EventType::Smtp(SmtpEvent::DeliverByInvalid)),
-            420 => Some(EventType::Smtp(SmtpEvent::DidNotSayEhlo)),
-            421 => Some(EventType::Smtp(SmtpEvent::DkimFail)),
-            422 => Some(EventType::Smtp(SmtpEvent::DkimPass)),
-            423 => Some(EventType::Smtp(SmtpEvent::DmarcFail)),
-            424 => Some(EventType::Smtp(SmtpEvent::DmarcPass)),
-            425 => Some(EventType::Smtp(SmtpEvent::DsnDisabled)),
-            426 => Some(EventType::Smtp(SmtpEvent::Ehlo)),
-            427 => Some(EventType::Smtp(SmtpEvent::EhloExpected)),
-            428 => Some(EventType::Smtp(SmtpEvent::Error)),
-            429 => Some(EventType::Smtp(SmtpEvent::Expn)),
-            430 => Some(EventType::Smtp(SmtpEvent::ExpnDisabled)),
-            431 => Some(EventType::Smtp(SmtpEvent::ExpnNotFound)),
-            432 => Some(EventType::Smtp(SmtpEvent::FutureReleaseDisabled)),
-            433 => Some(EventType::Smtp(SmtpEvent::FutureReleaseInvalid)),
-            434 => Some(EventType::Smtp(SmtpEvent::Help)),
-            435 => Some(EventType::Smtp(SmtpEvent::InvalidCommand)),
-            436 => Some(EventType::Smtp(SmtpEvent::InvalidEhlo)),
-            437 => Some(EventType::Smtp(SmtpEvent::InvalidParameter)),
-            438 => Some(EventType::Smtp(SmtpEvent::InvalidRecipientAddress)),
-            439 => Some(EventType::Smtp(SmtpEvent::InvalidSenderAddress)),
-            440 => Some(EventType::Smtp(SmtpEvent::IprevFail)),
-            441 => Some(EventType::Smtp(SmtpEvent::IprevPass)),
-            442 => Some(EventType::Smtp(SmtpEvent::LhloExpected)),
-            443 => Some(EventType::Smtp(SmtpEvent::LoopDetected)),
-            444 => Some(EventType::Smtp(SmtpEvent::MailFrom)),
-            445 => Some(EventType::Smtp(SmtpEvent::MailFromMissing)),
-            446 => Some(EventType::Smtp(SmtpEvent::MailFromRewritten)),
-            447 => Some(EventType::Smtp(SmtpEvent::MailFromUnauthenticated)),
-            448 => Some(EventType::Smtp(SmtpEvent::MailFromUnauthorized)),
-            449 => Some(EventType::Smtp(SmtpEvent::MailboxDoesNotExist)),
-            450 => Some(EventType::Smtp(SmtpEvent::MessageParseFailed)),
-            451 => Some(EventType::Smtp(SmtpEvent::MessageTooLarge)),
-            452 => Some(EventType::Smtp(SmtpEvent::MissingAuthDirectory)),
-            453 => Some(EventType::Smtp(SmtpEvent::MissingLocalHostname)),
-            454 => Some(EventType::Smtp(SmtpEvent::MtPriorityDisabled)),
-            455 => Some(EventType::Smtp(SmtpEvent::MtPriorityInvalid)),
-            456 => Some(EventType::Smtp(SmtpEvent::MultipleMailFrom)),
-            457 => Some(EventType::Smtp(SmtpEvent::Noop)),
-            460 => Some(EventType::Smtp(SmtpEvent::Quit)),
-            461 => Some(EventType::Smtp(SmtpEvent::RateLimitExceeded)),
-            462 => Some(EventType::Smtp(SmtpEvent::RawInput)),
-            463 => Some(EventType::Smtp(SmtpEvent::RawOutput)),
-            464 => Some(EventType::Smtp(SmtpEvent::RcptTo)),
-            465 => Some(EventType::Smtp(SmtpEvent::RcptToDuplicate)),
-            466 => Some(EventType::Smtp(SmtpEvent::RcptToMissing)),
-            467 => Some(EventType::Smtp(SmtpEvent::RcptToRewritten)),
-            468 => Some(EventType::Smtp(SmtpEvent::RelayNotAllowed)),
-            469 => Some(EventType::Smtp(SmtpEvent::IdNotFound)),
-            470 => Some(EventType::Smtp(SmtpEvent::RequestTooLarge)),
-            471 => Some(EventType::Smtp(SmtpEvent::RequireTlsDisabled)),
-            472 => Some(EventType::Smtp(SmtpEvent::Rset)),
-            473 => Some(EventType::Smtp(SmtpEvent::SpfEhloFail)),
-            474 => Some(EventType::Smtp(SmtpEvent::SpfEhloPass)),
-            475 => Some(EventType::Smtp(SmtpEvent::SpfFromFail)),
-            476 => Some(EventType::Smtp(SmtpEvent::SpfFromPass)),
-            477 => Some(EventType::Smtp(SmtpEvent::StartTls)),
-            478 => Some(EventType::Smtp(SmtpEvent::StartTlsAlready)),
-            479 => Some(EventType::Smtp(SmtpEvent::StartTlsUnavailable)),
-            480 => Some(EventType::Smtp(SmtpEvent::SyntaxError)),
-            481 => Some(EventType::Smtp(SmtpEvent::TimeLimitExceeded)),
-            482 => Some(EventType::Smtp(SmtpEvent::TooManyInvalidRcpt)),
-            483 => Some(EventType::Smtp(SmtpEvent::TooManyMessages)),
-            484 => Some(EventType::Smtp(SmtpEvent::TooManyRecipients)),
-            485 => Some(EventType::Smtp(SmtpEvent::TransferLimitExceeded)),
-            486 => Some(EventType::Smtp(SmtpEvent::UnsupportedParameter)),
-            487 => Some(EventType::Smtp(SmtpEvent::Vrfy)),
-            488 => Some(EventType::Smtp(SmtpEvent::VrfyDisabled)),
-            489 => Some(EventType::Smtp(SmtpEvent::VrfyNotFound)),
-            490 => Some(EventType::Spam(SpamEvent::Classify)),
-            491 => Some(EventType::Spam(SpamEvent::ClassifyError)),
-            492 => Some(EventType::Store(StoreEvent::HttpStoreFetch)),
-            493 => Some(EventType::Store(StoreEvent::HttpStoreError)),
-            494 => Some(EventType::Spam(SpamEvent::PyzorError)),
-            495 => Some(EventType::Spam(SpamEvent::Train)),
-            496 => Some(EventType::Spam(SpamEvent::TrainBalance)),
-            497 => Some(EventType::Spam(SpamEvent::TrainError)),
-            498 => Some(EventType::Spf(SpfEvent::Fail)),
-            499 => Some(EventType::Spf(SpfEvent::Neutral)),
-            500 => Some(EventType::Spf(SpfEvent::None)),
-            501 => Some(EventType::Spf(SpfEvent::Pass)),
-            502 => Some(EventType::Spf(SpfEvent::PermError)),
-            503 => Some(EventType::Spf(SpfEvent::SoftFail)),
-            504 => Some(EventType::Spf(SpfEvent::TempError)),
-            505 => Some(EventType::Store(StoreEvent::AssertValueFailed)),
-            506 => Some(EventType::Store(StoreEvent::BlobDelete)),
-            507 => Some(EventType::Store(StoreEvent::BlobMissingMarker)),
-            508 => Some(EventType::Store(StoreEvent::BlobRead)),
-            509 => Some(EventType::Store(StoreEvent::BlobWrite)),
-            510 => Some(EventType::Store(StoreEvent::CryptoError)),
-            511 => Some(EventType::Store(StoreEvent::DataCorruption)),
-            512 => Some(EventType::Store(StoreEvent::DataIterate)),
-            513 => Some(EventType::Store(StoreEvent::DataWrite)),
-            514 => Some(EventType::Store(StoreEvent::DecompressError)),
-            515 => Some(EventType::Store(StoreEvent::DeserializeError)),
-            516 => Some(EventType::Store(StoreEvent::ElasticsearchError)),
-            517 => Some(EventType::Store(StoreEvent::FilesystemError)),
-            518 => Some(EventType::Store(StoreEvent::FoundationdbError)),
-            519 => Some(EventType::Store(StoreEvent::LdapWarning)),
-            520 => Some(EventType::Store(StoreEvent::LdapError)),
-            521 => Some(EventType::Store(StoreEvent::LdapQuery)),
-            522 => Some(EventType::Store(StoreEvent::MysqlError)),
-            523 => Some(EventType::Store(StoreEvent::NotConfigured)),
-            524 => Some(EventType::Store(StoreEvent::NotFound)),
-            525 => Some(EventType::Store(StoreEvent::NotSupported)),
-            526 => Some(EventType::Store(StoreEvent::PoolError)),
-            527 => Some(EventType::Store(StoreEvent::PostgresqlError)),
-            528 => Some(EventType::Store(StoreEvent::RedisError)),
-            529 => Some(EventType::Store(StoreEvent::RocksdbError)),
-            530 => Some(EventType::Store(StoreEvent::S3Error)),
-            531 => Some(EventType::Store(StoreEvent::SqlQuery)),
-            532 => Some(EventType::Store(StoreEvent::SqliteError)),
-            533 => Some(EventType::Store(StoreEvent::UnexpectedError)),
-            534 => Some(EventType::Telemetry(TelemetryEvent::JournalError)),
-            535 => Some(EventType::Telemetry(TelemetryEvent::LogError)),
-            536 => Some(EventType::Telemetry(TelemetryEvent::OtelExporterError)),
-            537 => Some(EventType::Telemetry(
-                TelemetryEvent::OtelMetricsExporterError,
-            )),
-            538 => Some(EventType::Telemetry(
-                TelemetryEvent::PrometheusExporterError,
-            )),
-            539 => Some(EventType::Telemetry(TelemetryEvent::WebhookError)),
-            540 => Some(EventType::TlsRpt(TlsRptEvent::RecordFetch)),
-            541 => Some(EventType::TlsRpt(TlsRptEvent::RecordFetchError)),
-            542 => Some(EventType::Tls(TlsEvent::CertificateNotFound)),
-            543 => Some(EventType::Tls(TlsEvent::Handshake)),
-            544 => Some(EventType::Tls(TlsEvent::HandshakeError)),
-            545 => Some(EventType::Tls(TlsEvent::MultipleCertificatesAvailable)),
-            546 => Some(EventType::Tls(TlsEvent::NoCertificatesAvailable)),
-            547 => Some(EventType::Tls(TlsEvent::NotConfigured)),
-            548 => Some(EventType::Telemetry(TelemetryEvent::Alert)),
-            549 => Some(EventType::Security(SecurityEvent::AbuseBan)),
-            550 => Some(EventType::Security(SecurityEvent::LoiterBan)),
-            551 => Some(EventType::Smtp(SmtpEvent::MailFromNotAllowed)),
-            552 => Some(EventType::Security(SecurityEvent::Unauthorized)),
-            553 => Some(EventType::Limit(LimitEvent::TenantQuota)),
-            554 => Some(EventType::Auth(AuthEvent::TokenExpired)),
-            555 => Some(EventType::Auth(AuthEvent::ClientRegistration)),
-            556 => Some(EventType::Ai(AiEvent::LlmResponse)),
-            557 => Some(EventType::Ai(AiEvent::ApiError)),
-            558 => Some(EventType::Security(SecurityEvent::ScanBan)),
-            559 => Some(EventType::Store(StoreEvent::AzureError)),
-            560 => Some(EventType::TlsRpt(TlsRptEvent::RecordNotFound)),
-            561 => Some(EventType::Smtp(SmtpEvent::RcptToGreylisted)),
-            562 => Some(EventType::Spam(SpamEvent::Dnsbl)),
-            563 => Some(EventType::Spam(SpamEvent::DnsblError)),
-            564 => Some(EventType::Spam(SpamEvent::Pyzor)),
-            48 => Some(EventType::Queue(QueueEvent::BackPressure)),
-            57 => Some(EventType::Imap(ImapEvent::GetQuota)),
-            147 => Some(EventType::WebDav(WebDavEvent::Propfind)),
-            148 => Some(EventType::WebDav(WebDavEvent::Proppatch)),
-            335 => Some(EventType::WebDav(WebDavEvent::Get)),
-            336 => Some(EventType::WebDav(WebDavEvent::Report)),
-            376 => Some(EventType::WebDav(WebDavEvent::Mkcol)),
-            458 => Some(EventType::WebDav(WebDavEvent::Delete)),
-            459 => Some(EventType::WebDav(WebDavEvent::Put)),
-            565 => Some(EventType::WebDav(WebDavEvent::Post)),
-            566 => Some(EventType::WebDav(WebDavEvent::Patch)),
-            567 => Some(EventType::WebDav(WebDavEvent::Copy)),
-            568 => Some(EventType::WebDav(WebDavEvent::Move)),
-            569 => Some(EventType::WebDav(WebDavEvent::Lock)),
-            570 => Some(EventType::WebDav(WebDavEvent::Unlock)),
-            571 => Some(EventType::WebDav(WebDavEvent::Acl)),
-            572 => Some(EventType::WebDav(WebDavEvent::Error)),
-            573 => Some(EventType::WebDav(WebDavEvent::Options)),
-            574 => Some(EventType::WebDav(WebDavEvent::Head)),
-            575 => Some(EventType::WebDav(WebDavEvent::Mkcalendar)),
-            576 => Some(EventType::Calendar(CalendarEvent::RuleExpansionError)),
-            50 => Some(EventType::Store(StoreEvent::CacheMiss)),
-            51 => Some(EventType::Store(StoreEvent::CacheHit)),
-            52 => Some(EventType::Store(StoreEvent::CacheStale)),
-            577 => Some(EventType::Store(StoreEvent::CacheUpdate)),
-            578 => Some(EventType::TaskQueue(TaskQueueEvent::TaskAcquired)),
-            579 => Some(EventType::Calendar(CalendarEvent::AlarmSent)),
-            580 => Some(EventType::Calendar(CalendarEvent::AlarmSkipped)),
-            581 => Some(EventType::Calendar(CalendarEvent::AlarmRecipientOverride)),
-            582 => Some(EventType::Calendar(CalendarEvent::AlarmFailed)),
-            583 => Some(EventType::Calendar(CalendarEvent::ItipMessageSent)),
-            584 => Some(EventType::Calendar(CalendarEvent::ItipMessageReceived)),
-            585 => Some(EventType::Calendar(CalendarEvent::ItipMessageError)),
-            _ => None,
-        }
-    }
-}
-
-impl Key {
-    fn code(&self) -> u64 {
-        match self {
-            Key::AccountName => 0,
-            Key::AccountId => 1,
-            Key::BlobId => 2,
-            Key::CausedBy => 3,
-            Key::ChangeId => 4,
-            Key::Code => 5,
-            Key::Collection => 6,
-            Key::Contents => 7,
-            Key::Details => 8,
-            Key::DkimFail => 9,
-            Key::DkimNone => 10,
-            Key::DkimPass => 11,
-            Key::DmarcNone => 12,
-            Key::DmarcPass => 13,
-            Key::DmarcQuarantine => 14,
-            Key::DmarcReject => 15,
-            Key::DocumentId => 16,
-            Key::Domain => 17,
-            Key::Due => 18,
-            Key::Elapsed => 19,
-            Key::Expires => 20,
-            Key::From => 21,
-            Key::Hostname => 22,
-            Key::Id => 23,
-            Key::Key => 24,
-            Key::Limit => 25,
-            Key::ListenerId => 26,
-            Key::LocalIp => 27,
-            Key::LocalPort => 28,
-            Key::MailboxName => 29,
-            Key::MailboxId => 30,
-            Key::MessageId => 31,
-            Key::NextDsn => 32,
-            Key::NextRetry => 33,
-            Key::Path => 34,
-            Key::Policy => 35,
-            Key::QueueId => 36,
-            Key::RangeFrom => 37,
-            Key::RangeTo => 38,
-            Key::Reason => 39,
-            Key::RemoteIp => 40,
-            Key::RemotePort => 41,
-            Key::ReportId => 42,
-            Key::Result => 43,
-            Key::Size => 44,
-            Key::Source => 45,
-            Key::SpanId => 46,
-            Key::SpfFail => 47,
-            Key::SpfNone => 48,
-            Key::SpfPass => 49,
-            Key::Strict => 50,
-            Key::Tls => 51,
-            Key::To => 52,
-            Key::Total => 53,
-            Key::TotalFailures => 54,
-            Key::TotalSuccesses => 55,
-            Key::Type => 56,
-            Key::Uid => 57,
-            Key::UidNext => 58,
-            Key::UidValidity => 59,
-            Key::Url => 60,
-            Key::ValidFrom => 61,
-            Key::ValidTo => 62,
-            Key::Value => 63,
-            Key::Version => 64,
-            Key::QueueName => 65,
-        }
-    }
-
-    fn from_code(code: u64) -> Option<Self> {
-        match code {
-            0 => Some(Key::AccountName),
-            1 => Some(Key::AccountId),
-            2 => Some(Key::BlobId),
-            3 => Some(Key::CausedBy),
-            4 => Some(Key::ChangeId),
-            5 => Some(Key::Code),
-            6 => Some(Key::Collection),
-            7 => Some(Key::Contents),
-            8 => Some(Key::Details),
-            9 => Some(Key::DkimFail),
-            10 => Some(Key::DkimNone),
-            11 => Some(Key::DkimPass),
-            12 => Some(Key::DmarcNone),
-            13 => Some(Key::DmarcPass),
-            14 => Some(Key::DmarcQuarantine),
-            15 => Some(Key::DmarcReject),
-            16 => Some(Key::DocumentId),
-            17 => Some(Key::Domain),
-            18 => Some(Key::Due),
-            19 => Some(Key::Elapsed),
-            20 => Some(Key::Expires),
-            21 => Some(Key::From),
-            22 => Some(Key::Hostname),
-            23 => Some(Key::Id),
-            24 => Some(Key::Key),
-            25 => Some(Key::Limit),
-            26 => Some(Key::ListenerId),
-            27 => Some(Key::LocalIp),
-            28 => Some(Key::LocalPort),
-            29 => Some(Key::MailboxName),
-            30 => Some(Key::MailboxId),
-            31 => Some(Key::MessageId),
-            32 => Some(Key::NextDsn),
-            33 => Some(Key::NextRetry),
-            34 => Some(Key::Path),
-            35 => Some(Key::Policy),
-            36 => Some(Key::QueueId),
-            37 => Some(Key::RangeFrom),
-            38 => Some(Key::RangeTo),
-            39 => Some(Key::Reason),
-            40 => Some(Key::RemoteIp),
-            41 => Some(Key::RemotePort),
-            42 => Some(Key::ReportId),
-            43 => Some(Key::Result),
-            44 => Some(Key::Size),
-            45 => Some(Key::Source),
-            46 => Some(Key::SpanId),
-            47 => Some(Key::SpfFail),
-            48 => Some(Key::SpfNone),
-            49 => Some(Key::SpfPass),
-            50 => Some(Key::Strict),
-            51 => Some(Key::Tls),
-            52 => Some(Key::To),
-            53 => Some(Key::Total),
-            54 => Some(Key::TotalFailures),
-            55 => Some(Key::TotalSuccesses),
-            56 => Some(Key::Type),
-            57 => Some(Key::Uid),
-            58 => Some(Key::UidNext),
-            59 => Some(Key::UidValidity),
-            60 => Some(Key::Url),
-            61 => Some(Key::ValidFrom),
-            62 => Some(Key::ValidTo),
-            63 => Some(Key::Value),
-            64 => Some(Key::Version),
-            65 => Some(Key::QueueName),
-            _ => None,
-        }
-    }
-}
diff --git a/crates/trc/src/serializers/mod.rs b/crates/trc/src/serializers/mod.rs
index 4eb40bbe..6c744fdf 100644
--- a/crates/trc/src/serializers/mod.rs
+++ b/crates/trc/src/serializers/mod.rs
@@ -7,9 +7,3 @@
 pub mod json;
 pub mod text;
 
-// SPDX-SnippetBegin
-// SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
-// SPDX-License-Identifier: LicenseRef-SEL
-#[cfg(feature = "enterprise")]
-pub mod binary;
-// SPDX-SnippetEnd
diff --git a/tests/src/directory/oidc.rs b/tests/src/directory/oidc.rs
deleted file mode 100644
index 7221d89d..00000000
--- a/tests/src/directory/oidc.rs
+++ /dev/null
@@ -1,140 +0,0 @@
-/*
- * SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
- *
- * SPDX-License-Identifier: LicenseRef-SEL
- *
- * This file is subject to the Stalwart Enterprise License Agreement (SEL) and
- * is NOT open source software.
- *
- */
-
-use std::sync::Arc;
-
-use base64::{Engine, engine::general_purpose};
-use directory::QueryParams;
-use http_proto::{JsonProblemResponse, JsonResponse, ToHttpResponse};
-use hyper::{Method, StatusCode};
-use mail_send::Credentials;
-use serde_json::json;
-use trc::{AuthEvent, EventType};
-
-use crate::{
-    directory::DirectoryTest,
-    http_server::{HttpMessage, spawn_mock_http_server},
-};
-
-static TEST_TOKEN: &str = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ";
-
-#[tokio::test]
-async fn oidc_directory() {
-    // Obtain directory handle
-    let mut config = DirectoryTest::new("rocksdb".into()).await;
-
-    // Spawn mock OIDC server
-    let _tx = spawn_mock_http_server(Arc::new(|req: HttpMessage| {
-        let success_response = JsonResponse::new(json!({
-            "email": "john@example.org",
-            "preferred_username": "jdoe",
-            "name": "John Doe",
-        }))
-        .into_http_response();
-
-        match (req.method.clone(), req.uri.path().split('/').nth(1)) {
-            (Method::GET, Some("userinfo")) => match req.headers.get("authorization") {
-                Some(auth) if auth == &format!("Bearer {TEST_TOKEN}") => success_response,
-                Some(_) => JsonProblemResponse(StatusCode::UNAUTHORIZED).into_http_response(),
-                None => panic!("Missing Authorization header: {req:#?}"),
-            },
-            (Method::POST, Some("introspect-none")) => {
-                assert!(req.headers.get("authorization").is_none());
-                if req.get_url_encoded("token").as_deref() == Some(TEST_TOKEN) {
-                    success_response
-                } else {
-                    JsonProblemResponse(StatusCode::UNAUTHORIZED).into_http_response()
-                }
-            }
-            (Method::POST, Some("introspect-user-token")) => match req.headers.get("authorization")
-            {
-                Some(auth)
-                    if auth == &format!("Bearer {TEST_TOKEN}")
-                        && req.get_url_encoded("token").as_deref() == Some(TEST_TOKEN) =>
-                {
-                    success_response
-                }
-                Some(_) => JsonProblemResponse(StatusCode::UNAUTHORIZED).into_http_response(),
-                None => panic!("Missing Authorization header: {req:#?}"),
-            },
-            (Method::POST, Some("introspect-token")) => match req.headers.get("authorization") {
-                Some(auth)
-                    if auth == "Bearer token_of_gratitude"
-                        && req.get_url_encoded("token").as_deref() == Some(TEST_TOKEN) =>
-                {
-                    success_response
-                }
-                Some(_) => JsonProblemResponse(StatusCode::UNAUTHORIZED).into_http_response(),
-                None => panic!("Missing Authorization header: {req:#?}"),
-            },
-            (Method::POST, Some("introspect-basic")) => match req.headers.get("authorization") {
-                Some(auth)
-                    if auth
-                        == &format!(
-                            "Basic {}",
-                            general_purpose::STANDARD.encode("myuser:mypass".as_bytes())
-                        )
-                        && req.get_url_encoded("token").as_deref() == Some(TEST_TOKEN) =>
-                {
-                    success_response
-                }
-                Some(_) => JsonProblemResponse(StatusCode::UNAUTHORIZED).into_http_response(),
-                None => panic!("Missing Authorization header: {req:#?}"),
-            },
-            _ => panic!("Unexpected request: {:?}", req),
-        }
-    }))
-    .await;
-
-    for test in [
-        "oidc-userinfo",
-        "oidc-introspect-none",
-        "oidc-introspect-user-token",
-        "oidc-introspect-token",
-        "oidc-introspect-basic",
-    ] {
-        println!("Running OIDC test {test:?}...");
-        let directory = config.directories.directories.remove(test).unwrap();
-
-        // Test an invalid token
-        let err = directory
-            .query(
-                QueryParams::credentials(&Credentials::OAuthBearer {
-                    token: "invalid_or_expired_token".to_string(),
-                })
-                .with_return_member_of(false),
-            )
-            .await
-            .unwrap_err();
-        assert!(
-            err.matches(EventType::Auth(AuthEvent::Failed)),
-            "Unexpected error: {:?}",
-            err
-        );
-
-        // Test a valid token
-        let principal = directory
-            .query(
-                QueryParams::credentials(&Credentials::OAuthBearer {
-                    token: TEST_TOKEN.to_string(),
-                })
-                .with_return_member_of(false),
-            )
-            .await
-            .unwrap()
-            .unwrap();
-        assert_eq!(principal.name(), "jdoe");
-        assert_eq!(
-            principal.emails.first().map(|s| s.as_str()),
-            Some("john@example.org")
-        );
-        assert_eq!(principal.description(), Some("John Doe"));
-    }
-}
diff --git a/tests/src/jmap/enterprise.rs b/tests/src/jmap/enterprise.rs
deleted file mode 100644
index 8d93dcee..00000000
--- a/tests/src/jmap/enterprise.rs
+++ /dev/null
@@ -1,518 +0,0 @@
-/*
- * SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
- *
- * SPDX-License-Identifier: LicenseRef-SEL
- *
- * This file is subject to the Stalwart Enterprise License Agreement (SEL) and
- * is NOT open source software.
- *
- */
-
-use std::{sync::Arc, time::Duration};
-
-use common::{
-    Core, Server,
-    config::telemetry::{StoreTracer, TelemetrySubscriberType},
-    core::BuildServer,
-    enterprise::{
-        Enterprise, MetricStore, TraceStore, Undelete, config::parse_metric_alerts,
-        license::LicenseKey, undelete::DeletedBlob,
-    },
-    telemetry::{
-        metrics::store::{Metric, MetricsStore, SharedMetricHistory},
-        tracers::store::{TracingQuery, TracingStore},
-    },
-};
-use http::management::enterprise::undelete::{UndeleteRequest, UndeleteResponse};
-use imap_proto::ResponseType;
-use store::{
-    rand::{self, Rng},
-    write::now,
-};
-use trc::{
-    ipc::{bitset::Bitset, subscriber::SubscriberBuilder},
-    *,
-};
-use utils::config::{Config, cron::SimpleCron};
-
-use crate::{
-    AssertConfig,
-    directory::internal::TestInternalDirectory,
-    imap::{ImapConnection, Type},
-    jmap::delivery::SmtpConnection,
-};
-
-use super::{JMAPTest, ManagementApi, delivery::AssertResult};
-
-const METRICS_CONFIG: &str = r#"
-[metrics.alerts.expected]
-enable = true
-condition = "domain_count > 1 && cluster_publisher_error > 3"
-
-[metrics.alerts.expected.notify.event]
-enable = true
-message = "Yikes! Found %{cluster.publisher-error}% cluster errors!"
-
-[metrics.alerts.expected.notify.email]
-enable = true
-from-name = "Alert Subsystem"
-from-addr = "alert@example.com"
-to = ["jdoe@example.com"]
-subject = "Found %{cluster.publisher-error}% cluster errors"
-body = "Sorry for the bad news, but we found %{domain.count}% domains and %{cluster.publisher-error}% cluster errors."
-
-[metrics.alerts.unexpected]
-enable = true
-condition = "domain_count < 1 || cluster_publisher_error < 3"
-
-[metrics.alerts.unexpected.notify.event]
-enable = true
-message = "this should not have happened"
-
-"#;
-
-const RAW_MESSAGE: &str = "From: john@example.com
-To: john@example.com
-Subject: undelete test
-
-test
-";
-
-pub async fn test(params: &mut JMAPTest) {
-    // Enable Enterprise
-    println!("Running Enterprise tests...");
-    let mut core = params.server.inner.shared_core.load_full().as_ref().clone();
-    let mut config = Config::new(METRICS_CONFIG).unwrap();
-    core.enterprise = Enterprise {
-        license: LicenseKey {
-            valid_to: now() + 3600,
-            valid_from: now() - 3600,
-            domain: String::new(),
-            accounts: 100,
-        },
-        undelete: Undelete {
-            retention: Duration::from_secs(2),
-        }
-        .into(),
-        trace_store: TraceStore {
-            retention: Some(Duration::from_secs(1)),
-            store: core.storage.data.clone(),
-        }
-        .into(),
-        metrics_store: MetricStore {
-            retention: Some(Duration::from_secs(1)),
-            store: core.storage.data.clone(),
-            interval: SimpleCron::Day { hour: 0, minute: 0 },
-        }
-        .into(),
-        metrics_alerts: parse_metric_alerts(&mut config),
-        logo_url: None,
-        ai_apis: Default::default(),
-        spam_filter_llm: None,
-        template_calendar_alarm: None,
-        template_scheduling_email: None,
-        template_scheduling_web: None,
-    }
-    .into();
-    config.assert_no_errors();
-    assert_ne!(core.enterprise.as_ref().unwrap().metrics_alerts.len(), 0);
-    params.server.inner.shared_core.store(core.into());
-    assert!(
-        params
-            .server
-            .inner
-            .shared_core
-            .load()
-            .is_enterprise_edition()
-    );
-
-    // Create test account
-    params
-        .server
-        .inner
-        .shared_core
-        .load()
-        .storage
-        .data
-        .create_test_user(
-            "jdoe@example.com",
-            "secret",
-            "John Doe",
-            &["jdoe@example.com"],
-        )
-        .await;
-
-    alerts(&params.server.inner.build_server()).await;
-    undelete(params).await;
-    tracing(params).await;
-    metrics(params).await;
-
-    params.server.inner.shared_core.store(
-        params
-            .server
-            .inner
-            .shared_core
-            .load_full()
-            .as_ref()
-            .clone()
-            .enable_enterprise()
-            .into(),
-    );
-}
-
-pub trait EnterpriseCore {
-    fn enable_enterprise(self) -> Self;
-}
-
-impl EnterpriseCore for Core {
-    fn enable_enterprise(mut self) -> Self {
-        self.enterprise = Enterprise {
-            license: LicenseKey {
-                valid_to: now() + 3600,
-                valid_from: now() - 3600,
-                domain: String::new(),
-                accounts: 100,
-            },
-            undelete: None,
-            trace_store: None,
-            metrics_store: None,
-            metrics_alerts: vec![],
-            logo_url: None,
-            ai_apis: Default::default(),
-            spam_filter_llm: None,
-            template_calendar_alarm: None,
-            template_scheduling_email: None,
-            template_scheduling_web: None,
-        }
-        .into();
-        self
-    }
-}
-
-async fn alerts(server: &Server) {
-    // Make sure the required metrics are set to 0
-    assert_eq!(
-        Collector::read_event_metric(EventType::Cluster(ClusterEvent::PublisherError).id()),
-        0
-    );
-    assert_eq!(Collector::read_metric(MetricType::DomainCount), 0.0);
-    assert_eq!(
-        Collector::read_event_metric(EventType::Telemetry(TelemetryEvent::Alert).id()),
-        0
-    );
-
-    // Increment metrics to trigger alerts
-    Collector::update_event_counter(EventType::Cluster(ClusterEvent::PublisherError), 5);
-    Collector::update_gauge(MetricType::DomainCount, 3);
-
-    // Make sure the values were set
-    assert_eq!(
-        Collector::read_event_metric(EventType::Cluster(ClusterEvent::PublisherError).id()),
-        5
-    );
-    assert_eq!(Collector::read_metric(MetricType::DomainCount), 3.0);
-
-    // Process alerts
-    let message = server.process_alerts().await.unwrap().pop().unwrap();
-    assert_eq!(message.from, "alert@example.com");
-    assert_eq!(message.to, vec!["jdoe@example.com".to_string()]);
-    let body = String::from_utf8(message.body).unwrap();
-    assert!(
-        body.contains("Sorry for the bad news, but we found 3 domains and 5 cluster errors."),
-        "{body:?}"
-    );
-    assert!(body.contains("Subject: Found 5 cluster errors"), "{body:?}");
-    assert!(
-        body.contains("From: \"Alert Subsystem\" <alert@example.com>"),
-        "{body:?}"
-    );
-    assert!(body.contains("To: <jdoe@example.com>"), "{body:?}");
-
-    // Make sure the event was triggered
-    assert_eq!(
-        Collector::read_event_metric(EventType::Telemetry(TelemetryEvent::Alert).id()),
-        1
-    );
-}
-
-async fn tracing(params: &mut JMAPTest) {
-    // Enable tracing
-    let store = params.server.core.storage.data.clone();
-    TelemetrySubscriberType::StoreTracer(StoreTracer {
-        store: store.clone(),
-    })
-    .spawn(
-        SubscriberBuilder::new("store-tracer".to_string()).with_interests(Box::new(Bitset::all())),
-        true,
-    );
-
-    // Make sure there are no span entries in the db
-    store.purge_spans(Duration::from_secs(0)).await.unwrap();
-    assert_eq!(
-        store
-            .query_spans(
-                &[TracingQuery::EventType(EventType::Smtp(
-                    SmtpEvent::ConnectionStart
-                ))],
-                0,
-                0
-            )
-            .await
-            .unwrap(),
-        Vec::<u64>::new()
-    );
-
-    // Send an email
-    let mut lmtp = SmtpConnection::connect().await;
-    lmtp.ingest(
-        "bill@example.com",
-        &["jdoe@example.com"],
-        concat!(
-            "From: bill@example.com\r\n",
-            "To: jdoe@example.com\r\n",
-            "Subject: TPS Report\r\n",
-            "X-Spam-Status: No\r\n",
-            "\r\n",
-            "I'm going to need those TPS reports ASAP. ",
-            "So, if you could do that, that'd be great."
-        ),
-    )
-    .await;
-    lmtp.quit().await;
-    tokio::time::sleep(Duration::from_millis(200)).await;
-
-    // Purge should not delete anything at this point
-    store.purge_spans(Duration::from_secs(1)).await.unwrap();
-
-    // There should be a span entry in the db
-    for span_type in [
-        EventType::Delivery(DeliveryEvent::AttemptStart),
-        EventType::Smtp(SmtpEvent::ConnectionStart),
-    ] {
-        let spans = store
-            .query_spans(&[TracingQuery::EventType(span_type)], 0, 0)
-            .await
-            .unwrap();
-        assert_eq!(spans.len(), 1, "{span_type:?}");
-        assert_eq!(
-            store.get_span(spans[0]).await.unwrap()[0].inner.typ,
-            span_type
-        );
-    }
-
-    // Try searching
-    for keyword in ["bill@example.com", "jdoe@example.com", "example.com"] {
-        let spans = store
-            .query_spans(&[TracingQuery::Keywords(keyword.to_string())], 0, 0)
-            .await
-            .unwrap();
-        assert_eq!(spans.len(), 2, "keyword: {keyword}");
-        assert!(spans[0] > spans[1], "keyword: {keyword}");
-    }
-
-    // Purge should delete the span entries
-    tokio::time::sleep(Duration::from_millis(800)).await;
-    store.purge_spans(Duration::from_secs(1)).await.unwrap();
-
-    for query in [
-        TracingQuery::EventType(EventType::Smtp(SmtpEvent::ConnectionStart)),
-        TracingQuery::EventType(EventType::Delivery(DeliveryEvent::AttemptStart)),
-        TracingQuery::Keywords("bill@example.com".to_string()),
-        TracingQuery::Keywords("jdoe@example.com".to_string()),
-        TracingQuery::Keywords("example.com".to_string()),
-    ] {
-        assert_eq!(
-            store.query_spans(&[query], 0, 0).await.unwrap(),
-            Vec::<u64>::new()
-        );
-    }
-}
-
-async fn metrics(params: &mut JMAPTest) {
-    // Make sure there are no span entries in the db
-    let store = params.server.core.storage.data.clone();
-    assert_eq!(
-        store.query_metrics(0, u64::MAX).await.unwrap(),
-        Vec::<Metric<EventType, MetricType, u64>>::new()
-    );
-
-    insert_test_metrics(params.server.core.clone()).await;
-
-    let total = store.query_metrics(0, u64::MAX).await.unwrap();
-    assert!(!total.is_empty(), "{total:?}");
-
-    store.purge_metrics(Duration::from_secs(0)).await.unwrap();
-    assert_eq!(
-        store.query_metrics(0, u64::MAX).await.unwrap(),
-        Vec::<Metric<EventType, MetricType, u64>>::new()
-    );
-}
-
-async fn undelete(_params: &mut JMAPTest) {
-    // Authenticate
-    let mut imap = ImapConnection::connect(b"_x ").await;
-    imap.send("AUTHENTICATE PLAIN {32+}\r\nAGpkb2VAZXhhbXBsZS5jb20Ac2VjcmV0")
-        .await;
-    imap.assert_read(Type::Tagged, ResponseType::Ok).await;
-
-    // Insert test message
-    imap.send("STATUS INBOX (MESSAGES)").await;
-    imap.assert_read(Type::Tagged, ResponseType::Ok)
-        .await
-        .assert_contains("MESSAGES 0");
-    imap.send(&format!("APPEND INBOX {{{}}}", RAW_MESSAGE.len()))
-        .await;
-    imap.assert_read(Type::Continuation, ResponseType::Ok).await;
-    imap.send_untagged(RAW_MESSAGE).await;
-    imap.assert_read(Type::Tagged, ResponseType::Ok).await;
-
-    // Make sure the message is there
-    imap.send("STATUS INBOX (MESSAGES)").await;
-    imap.assert_read(Type::Tagged, ResponseType::Ok)
-        .await
-        .assert_contains("MESSAGES 1");
-    imap.send("SELECT INBOX").await;
-    imap.assert_read(Type::Tagged, ResponseType::Ok).await;
-
-    // Fetch message body
-    imap.send("FETCH 1 BODY[]").await;
-    imap.assert_read(Type::Tagged, ResponseType::Ok)
-        .await
-        .assert_contains("Subject: undelete test");
-
-    // Delete and expunge message
-    imap.send("STORE 1 +FLAGS (\\Deleted)").await;
-    imap.assert_read(Type::Tagged, ResponseType::Ok).await;
-    imap.send("EXPUNGE").await;
-    imap.assert_read(Type::Tagged, ResponseType::Ok).await;
-
-    // Logout and reconnect
-    imap.send("LOGOUT").await;
-    imap.assert_read(Type::Tagged, ResponseType::Ok).await;
-    let mut imap = ImapConnection::connect(b"_x ").await;
-    imap.send("AUTHENTICATE PLAIN {32+}\r\nAGpkb2VAZXhhbXBsZS5jb20Ac2VjcmV0")
-        .await;
-    imap.assert_read(Type::Tagged, ResponseType::Ok).await;
-
-    // Make sure the message is gone
-    imap.send("STATUS INBOX (MESSAGES)").await;
-    imap.assert_read(Type::Tagged, ResponseType::Ok)
-        .await
-        .assert_contains("MESSAGES 0");
-
-    // Query undelete API
-    let api = ManagementApi::new(8899, "admin", "secret");
-    api.get::<serde_json::Value>("/api/store/purge/account/jdoe@example.com")
-        .await
-        .unwrap();
-    tokio::time::sleep(Duration::from_millis(200)).await;
-    let deleted = api
-        .get::<List<DeletedBlob<String, String, String>>>("/api/store/undelete/jdoe@example.com")
-        .await
-        .unwrap()
-        .unwrap_data()
-        .items;
-    assert_eq!(deleted.len(), 1);
-    let deleted = deleted.into_iter().next().unwrap();
-
-    // Undelete
-    let result = api
-        .post::<Vec<UndeleteResponse>>(
-            "/api/store/undelete/jdoe@example.com",
-            &vec![UndeleteRequest {
-                hash: deleted.hash,
-                collection: deleted.collection,
-                time: deleted.deleted_at,
-                cancel_deletion: deleted.expires_at.into(),
-            }],
-        )
-        .await
-        .unwrap()
-        .unwrap_data();
-    assert_eq!(result, vec![UndeleteResponse::Success]);
-
-    // Make sure the message is back
-    imap.send("STATUS INBOX (MESSAGES)").await;
-    imap.assert_read(Type::Tagged, ResponseType::Ok)
-        .await
-        .assert_contains("MESSAGES 1");
-
-    imap.send("SELECT INBOX").await;
-    imap.assert_read(Type::Tagged, ResponseType::Ok).await;
-
-    // Fetch message body
-    imap.send("FETCH 1 BODY[]").await;
-    imap.assert_read(Type::Tagged, ResponseType::Ok)
-        .await
-        .assert_contains("Subject: undelete test");
-}
-
-pub async fn insert_test_metrics(core: Arc<Core>) {
-    let store = core.storage.data.clone();
-    store.purge_metrics(Duration::from_secs(0)).await.unwrap();
-    let mut start_time = now() - (90 * 24 * 60 * 60);
-    let timestamp = now();
-    let history = SharedMetricHistory::default();
-
-    while start_time < timestamp {
-        for event_type in [
-            EventType::Smtp(SmtpEvent::ConnectionStart),
-            EventType::Imap(ImapEvent::ConnectionStart),
-            EventType::Pop3(Pop3Event::ConnectionStart),
-            EventType::ManageSieve(ManageSieveEvent::ConnectionStart),
-            EventType::Http(HttpEvent::ConnectionStart),
-            EventType::Delivery(DeliveryEvent::AttemptStart),
-            EventType::Queue(QueueEvent::QueueMessage),
-            EventType::Queue(QueueEvent::QueueMessageAuthenticated),
-            EventType::Queue(QueueEvent::QueueDsn),
-            EventType::Queue(QueueEvent::QueueReport),
-            EventType::MessageIngest(MessageIngestEvent::Ham),
-            EventType::MessageIngest(MessageIngestEvent::Spam),
-            EventType::Auth(AuthEvent::Failed),
-            EventType::Security(SecurityEvent::AuthenticationBan),
-            EventType::Security(SecurityEvent::ScanBan),
-            EventType::Security(SecurityEvent::AbuseBan),
-            EventType::Security(SecurityEvent::LoiterBan),
-            EventType::Security(SecurityEvent::IpBlocked),
-            EventType::IncomingReport(IncomingReportEvent::DmarcReport),
-            EventType::IncomingReport(IncomingReportEvent::DmarcReportWithWarnings),
-            EventType::IncomingReport(IncomingReportEvent::TlsReport),
-            EventType::IncomingReport(IncomingReportEvent::TlsReportWithWarnings),
-        ] {
-            // Generate a random value between 0 and 100
-            Collector::update_event_counter(event_type, rand::rng().random_range(0..=100))
-        }
-
-        Collector::update_gauge(MetricType::QueueCount, rand::rng().random_range(0..=1000));
-        Collector::update_gauge(
-            MetricType::ServerMemory,
-            rand::rng().random_range(100 * 1024 * 1024..=300 * 1024 * 1024),
-        );
-
-        for metric_type in [
-            MetricType::MessageIngestionTime,
-            MetricType::MessageFtsIndexTime,
-            MetricType::DeliveryTime,
-            MetricType::DnsLookupTime,
-        ] {
-            Collector::update_histogram(metric_type, rand::rng().random_range(2..=1000))
-        }
-        Collector::update_histogram(
-            MetricType::DeliveryTotalTime,
-            rand::rng().random_range(1000..=5000),
-        );
-
-        store
-            .write_metrics(core.clone(), start_time, history.clone())
-            .await
-            .unwrap();
-        start_time += 60 * 60;
-    }
-}
-
-#[derive(serde::Deserialize, Debug)]
-#[allow(dead_code)]
-pub(super) struct List<T> {
-    pub items: Vec<T>,
-    pub total: usize,
-}
